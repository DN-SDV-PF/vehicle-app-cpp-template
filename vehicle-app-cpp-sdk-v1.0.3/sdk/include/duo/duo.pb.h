// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: duo/duo.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_duo_2fduo_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_duo_2fduo_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/struct.pb.h>
#include "google/api/annotations.pb.h"
#include "duo/types.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_duo_2fduo_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_duo_2fduo_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_duo_2fduo_2eproto;
namespace duo {
class CreateJobRequest;
struct CreateJobRequestDefaultTypeInternal;
extern CreateJobRequestDefaultTypeInternal _CreateJobRequest_default_instance_;
class CreateJobResponse;
struct CreateJobResponseDefaultTypeInternal;
extern CreateJobResponseDefaultTypeInternal _CreateJobResponse_default_instance_;
class DeleteFinishedJobsRequest;
struct DeleteFinishedJobsRequestDefaultTypeInternal;
extern DeleteFinishedJobsRequestDefaultTypeInternal _DeleteFinishedJobsRequest_default_instance_;
class DeleteRequest;
struct DeleteRequestDefaultTypeInternal;
extern DeleteRequestDefaultTypeInternal _DeleteRequest_default_instance_;
class DeleteResponse;
struct DeleteResponseDefaultTypeInternal;
extern DeleteResponseDefaultTypeInternal _DeleteResponse_default_instance_;
class GetDeltaRequest;
struct GetDeltaRequestDefaultTypeInternal;
extern GetDeltaRequestDefaultTypeInternal _GetDeltaRequest_default_instance_;
class GetDesireRequest;
struct GetDesireRequestDefaultTypeInternal;
extern GetDesireRequestDefaultTypeInternal _GetDesireRequest_default_instance_;
class GetFinishedJobsRequest;
struct GetFinishedJobsRequestDefaultTypeInternal;
extern GetFinishedJobsRequestDefaultTypeInternal _GetFinishedJobsRequest_default_instance_;
class GetJobRequest;
struct GetJobRequestDefaultTypeInternal;
extern GetJobRequestDefaultTypeInternal _GetJobRequest_default_instance_;
class GetJobResponse;
struct GetJobResponseDefaultTypeInternal;
extern GetJobResponseDefaultTypeInternal _GetJobResponse_default_instance_;
class GetJobsResponse;
struct GetJobsResponseDefaultTypeInternal;
extern GetJobsResponseDefaultTypeInternal _GetJobsResponse_default_instance_;
class GetNextJobRequest;
struct GetNextJobRequestDefaultTypeInternal;
extern GetNextJobRequestDefaultTypeInternal _GetNextJobRequest_default_instance_;
class GetReportRequest;
struct GetReportRequestDefaultTypeInternal;
extern GetReportRequestDefaultTypeInternal _GetReportRequest_default_instance_;
class GetResponse;
struct GetResponseDefaultTypeInternal;
extern GetResponseDefaultTypeInternal _GetResponse_default_instance_;
class GetThingListRequest;
struct GetThingListRequestDefaultTypeInternal;
extern GetThingListRequestDefaultTypeInternal _GetThingListRequest_default_instance_;
class GetThingListResponse;
struct GetThingListResponseDefaultTypeInternal;
extern GetThingListResponseDefaultTypeInternal _GetThingListResponse_default_instance_;
class GetUnfinishedJobsRequest;
struct GetUnfinishedJobsRequestDefaultTypeInternal;
extern GetUnfinishedJobsRequestDefaultTypeInternal _GetUnfinishedJobsRequest_default_instance_;
class Job;
struct JobDefaultTypeInternal;
extern JobDefaultTypeInternal _Job_default_instance_;
class JobCreateion;
struct JobCreateionDefaultTypeInternal;
extern JobCreateionDefaultTypeInternal _JobCreateion_default_instance_;
class JobDeleteResponse;
struct JobDeleteResponseDefaultTypeInternal;
extern JobDeleteResponseDefaultTypeInternal _JobDeleteResponse_default_instance_;
class JobListenEvent;
struct JobListenEventDefaultTypeInternal;
extern JobListenEventDefaultTypeInternal _JobListenEvent_default_instance_;
class JobModification;
struct JobModificationDefaultTypeInternal;
extern JobModificationDefaultTypeInternal _JobModification_default_instance_;
class ListenDeltaRequest;
struct ListenDeltaRequestDefaultTypeInternal;
extern ListenDeltaRequestDefaultTypeInternal _ListenDeltaRequest_default_instance_;
class ListenDesireRequest;
struct ListenDesireRequestDefaultTypeInternal;
extern ListenDesireRequestDefaultTypeInternal _ListenDesireRequest_default_instance_;
class ListenJobChangedRequest;
struct ListenJobChangedRequestDefaultTypeInternal;
extern ListenJobChangedRequestDefaultTypeInternal _ListenJobChangedRequest_default_instance_;
class ListenJobChangedResponse;
struct ListenJobChangedResponseDefaultTypeInternal;
extern ListenJobChangedResponseDefaultTypeInternal _ListenJobChangedResponse_default_instance_;
class ListenNextJobArrivedRequest;
struct ListenNextJobArrivedRequestDefaultTypeInternal;
extern ListenNextJobArrivedRequestDefaultTypeInternal _ListenNextJobArrivedRequest_default_instance_;
class ListenNextJobArrivedResponse;
struct ListenNextJobArrivedResponseDefaultTypeInternal;
extern ListenNextJobArrivedResponseDefaultTypeInternal _ListenNextJobArrivedResponse_default_instance_;
class ListenReportRequest;
struct ListenReportRequestDefaultTypeInternal;
extern ListenReportRequestDefaultTypeInternal _ListenReportRequest_default_instance_;
class ListenResponse;
struct ListenResponseDefaultTypeInternal;
extern ListenResponseDefaultTypeInternal _ListenResponse_default_instance_;
class PatchAndWaitResponse;
struct PatchAndWaitResponseDefaultTypeInternal;
extern PatchAndWaitResponseDefaultTypeInternal _PatchAndWaitResponse_default_instance_;
class PatchDesireRequest;
struct PatchDesireRequestDefaultTypeInternal;
extern PatchDesireRequestDefaultTypeInternal _PatchDesireRequest_default_instance_;
class PatchReportRequest;
struct PatchReportRequestDefaultTypeInternal;
extern PatchReportRequestDefaultTypeInternal _PatchReportRequest_default_instance_;
class PatchResponse;
struct PatchResponseDefaultTypeInternal;
extern PatchResponseDefaultTypeInternal _PatchResponse_default_instance_;
class PingRequest;
struct PingRequestDefaultTypeInternal;
extern PingRequestDefaultTypeInternal _PingRequest_default_instance_;
class PingResponse;
struct PingResponseDefaultTypeInternal;
extern PingResponseDefaultTypeInternal _PingResponse_default_instance_;
class UpdateJobRequest;
struct UpdateJobRequestDefaultTypeInternal;
extern UpdateJobRequestDefaultTypeInternal _UpdateJobRequest_default_instance_;
class UpdateJobResponse;
struct UpdateJobResponseDefaultTypeInternal;
extern UpdateJobResponseDefaultTypeInternal _UpdateJobResponse_default_instance_;
class UploadMetadata;
struct UploadMetadataDefaultTypeInternal;
extern UploadMetadataDefaultTypeInternal _UploadMetadata_default_instance_;
class UploadRequest;
struct UploadRequestDefaultTypeInternal;
extern UploadRequestDefaultTypeInternal _UploadRequest_default_instance_;
class UploadResponse;
struct UploadResponseDefaultTypeInternal;
extern UploadResponseDefaultTypeInternal _UploadResponse_default_instance_;
}  // namespace duo
PROTOBUF_NAMESPACE_OPEN
template<> ::duo::CreateJobRequest* Arena::CreateMaybeMessage<::duo::CreateJobRequest>(Arena*);
template<> ::duo::CreateJobResponse* Arena::CreateMaybeMessage<::duo::CreateJobResponse>(Arena*);
template<> ::duo::DeleteFinishedJobsRequest* Arena::CreateMaybeMessage<::duo::DeleteFinishedJobsRequest>(Arena*);
template<> ::duo::DeleteRequest* Arena::CreateMaybeMessage<::duo::DeleteRequest>(Arena*);
template<> ::duo::DeleteResponse* Arena::CreateMaybeMessage<::duo::DeleteResponse>(Arena*);
template<> ::duo::GetDeltaRequest* Arena::CreateMaybeMessage<::duo::GetDeltaRequest>(Arena*);
template<> ::duo::GetDesireRequest* Arena::CreateMaybeMessage<::duo::GetDesireRequest>(Arena*);
template<> ::duo::GetFinishedJobsRequest* Arena::CreateMaybeMessage<::duo::GetFinishedJobsRequest>(Arena*);
template<> ::duo::GetJobRequest* Arena::CreateMaybeMessage<::duo::GetJobRequest>(Arena*);
template<> ::duo::GetJobResponse* Arena::CreateMaybeMessage<::duo::GetJobResponse>(Arena*);
template<> ::duo::GetJobsResponse* Arena::CreateMaybeMessage<::duo::GetJobsResponse>(Arena*);
template<> ::duo::GetNextJobRequest* Arena::CreateMaybeMessage<::duo::GetNextJobRequest>(Arena*);
template<> ::duo::GetReportRequest* Arena::CreateMaybeMessage<::duo::GetReportRequest>(Arena*);
template<> ::duo::GetResponse* Arena::CreateMaybeMessage<::duo::GetResponse>(Arena*);
template<> ::duo::GetThingListRequest* Arena::CreateMaybeMessage<::duo::GetThingListRequest>(Arena*);
template<> ::duo::GetThingListResponse* Arena::CreateMaybeMessage<::duo::GetThingListResponse>(Arena*);
template<> ::duo::GetUnfinishedJobsRequest* Arena::CreateMaybeMessage<::duo::GetUnfinishedJobsRequest>(Arena*);
template<> ::duo::Job* Arena::CreateMaybeMessage<::duo::Job>(Arena*);
template<> ::duo::JobCreateion* Arena::CreateMaybeMessage<::duo::JobCreateion>(Arena*);
template<> ::duo::JobDeleteResponse* Arena::CreateMaybeMessage<::duo::JobDeleteResponse>(Arena*);
template<> ::duo::JobListenEvent* Arena::CreateMaybeMessage<::duo::JobListenEvent>(Arena*);
template<> ::duo::JobModification* Arena::CreateMaybeMessage<::duo::JobModification>(Arena*);
template<> ::duo::ListenDeltaRequest* Arena::CreateMaybeMessage<::duo::ListenDeltaRequest>(Arena*);
template<> ::duo::ListenDesireRequest* Arena::CreateMaybeMessage<::duo::ListenDesireRequest>(Arena*);
template<> ::duo::ListenJobChangedRequest* Arena::CreateMaybeMessage<::duo::ListenJobChangedRequest>(Arena*);
template<> ::duo::ListenJobChangedResponse* Arena::CreateMaybeMessage<::duo::ListenJobChangedResponse>(Arena*);
template<> ::duo::ListenNextJobArrivedRequest* Arena::CreateMaybeMessage<::duo::ListenNextJobArrivedRequest>(Arena*);
template<> ::duo::ListenNextJobArrivedResponse* Arena::CreateMaybeMessage<::duo::ListenNextJobArrivedResponse>(Arena*);
template<> ::duo::ListenReportRequest* Arena::CreateMaybeMessage<::duo::ListenReportRequest>(Arena*);
template<> ::duo::ListenResponse* Arena::CreateMaybeMessage<::duo::ListenResponse>(Arena*);
template<> ::duo::PatchAndWaitResponse* Arena::CreateMaybeMessage<::duo::PatchAndWaitResponse>(Arena*);
template<> ::duo::PatchDesireRequest* Arena::CreateMaybeMessage<::duo::PatchDesireRequest>(Arena*);
template<> ::duo::PatchReportRequest* Arena::CreateMaybeMessage<::duo::PatchReportRequest>(Arena*);
template<> ::duo::PatchResponse* Arena::CreateMaybeMessage<::duo::PatchResponse>(Arena*);
template<> ::duo::PingRequest* Arena::CreateMaybeMessage<::duo::PingRequest>(Arena*);
template<> ::duo::PingResponse* Arena::CreateMaybeMessage<::duo::PingResponse>(Arena*);
template<> ::duo::UpdateJobRequest* Arena::CreateMaybeMessage<::duo::UpdateJobRequest>(Arena*);
template<> ::duo::UpdateJobResponse* Arena::CreateMaybeMessage<::duo::UpdateJobResponse>(Arena*);
template<> ::duo::UploadMetadata* Arena::CreateMaybeMessage<::duo::UploadMetadata>(Arena*);
template<> ::duo::UploadRequest* Arena::CreateMaybeMessage<::duo::UploadRequest>(Arena*);
template<> ::duo::UploadResponse* Arena::CreateMaybeMessage<::duo::UploadResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace duo {

enum StatusCode : int {
  INTERNAL_SERVER_ERROR = 0,
  OK = 1,
  BAD_REQUEST = 2,
  CONFLICT = 3,
  StatusCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  StatusCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool StatusCode_IsValid(int value);
constexpr StatusCode StatusCode_MIN = INTERNAL_SERVER_ERROR;
constexpr StatusCode StatusCode_MAX = CONFLICT;
constexpr int StatusCode_ARRAYSIZE = StatusCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StatusCode_descriptor();
template<typename T>
inline const std::string& StatusCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StatusCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StatusCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    StatusCode_descriptor(), enum_t_value);
}
inline bool StatusCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, StatusCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StatusCode>(
    StatusCode_descriptor(), name, value);
}
enum JobStatus : int {
  UNDEFINED = 0,
  CANCELED = 1,
  FAILED = 2,
  REJECTED = 3,
  SUCCEEDED = 4,
  ACCEPTED = 5,
  QUEUED = 6,
  IN_PROGRESS = 7,
  JobStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  JobStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool JobStatus_IsValid(int value);
constexpr JobStatus JobStatus_MIN = UNDEFINED;
constexpr JobStatus JobStatus_MAX = IN_PROGRESS;
constexpr int JobStatus_ARRAYSIZE = JobStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* JobStatus_descriptor();
template<typename T>
inline const std::string& JobStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, JobStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function JobStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    JobStatus_descriptor(), enum_t_value);
}
inline bool JobStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, JobStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<JobStatus>(
    JobStatus_descriptor(), name, value);
}
// ===================================================================

class GetReportRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:duo.GetReportRequest) */ {
 public:
  inline GetReportRequest() : GetReportRequest(nullptr) {}
  ~GetReportRequest() override;
  explicit PROTOBUF_CONSTEXPR GetReportRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetReportRequest(const GetReportRequest& from);
  GetReportRequest(GetReportRequest&& from) noexcept
    : GetReportRequest() {
    *this = ::std::move(from);
  }

  inline GetReportRequest& operator=(const GetReportRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetReportRequest& operator=(GetReportRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetReportRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetReportRequest* internal_default_instance() {
    return reinterpret_cast<const GetReportRequest*>(
               &_GetReportRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(GetReportRequest& a, GetReportRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetReportRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetReportRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetReportRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetReportRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetReportRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetReportRequest& from) {
    GetReportRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetReportRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "duo.GetReportRequest";
  }
  protected:
  explicit GetReportRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFiltersFieldNumber = 3,
    kThingFieldNumber = 1,
    kPathFieldNumber = 2,
  };
  // repeated string filters = 3;
  int filters_size() const;
  private:
  int _internal_filters_size() const;
  public:
  void clear_filters();
  const std::string& filters(int index) const;
  std::string* mutable_filters(int index);
  void set_filters(int index, const std::string& value);
  void set_filters(int index, std::string&& value);
  void set_filters(int index, const char* value);
  void set_filters(int index, const char* value, size_t size);
  std::string* add_filters();
  void add_filters(const std::string& value);
  void add_filters(std::string&& value);
  void add_filters(const char* value);
  void add_filters(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& filters() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_filters();
  private:
  const std::string& _internal_filters(int index) const;
  std::string* _internal_add_filters();
  public:

  // string thing = 1;
  void clear_thing();
  const std::string& thing() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_thing(ArgT0&& arg0, ArgT... args);
  std::string* mutable_thing();
  PROTOBUF_NODISCARD std::string* release_thing();
  void set_allocated_thing(std::string* thing);
  private:
  const std::string& _internal_thing() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_thing(const std::string& value);
  std::string* _internal_mutable_thing();
  public:

  // optional string path = 2;
  bool has_path() const;
  private:
  bool _internal_has_path() const;
  public:
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // @@protoc_insertion_point(class_scope:duo.GetReportRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> filters_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr thing_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_duo_2fduo_2eproto;
};
// -------------------------------------------------------------------

class GetDesireRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:duo.GetDesireRequest) */ {
 public:
  inline GetDesireRequest() : GetDesireRequest(nullptr) {}
  ~GetDesireRequest() override;
  explicit PROTOBUF_CONSTEXPR GetDesireRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetDesireRequest(const GetDesireRequest& from);
  GetDesireRequest(GetDesireRequest&& from) noexcept
    : GetDesireRequest() {
    *this = ::std::move(from);
  }

  inline GetDesireRequest& operator=(const GetDesireRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetDesireRequest& operator=(GetDesireRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetDesireRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetDesireRequest* internal_default_instance() {
    return reinterpret_cast<const GetDesireRequest*>(
               &_GetDesireRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(GetDesireRequest& a, GetDesireRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetDesireRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetDesireRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetDesireRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetDesireRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetDesireRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetDesireRequest& from) {
    GetDesireRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetDesireRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "duo.GetDesireRequest";
  }
  protected:
  explicit GetDesireRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFiltersFieldNumber = 3,
    kThingFieldNumber = 1,
    kPathFieldNumber = 2,
  };
  // repeated string filters = 3;
  int filters_size() const;
  private:
  int _internal_filters_size() const;
  public:
  void clear_filters();
  const std::string& filters(int index) const;
  std::string* mutable_filters(int index);
  void set_filters(int index, const std::string& value);
  void set_filters(int index, std::string&& value);
  void set_filters(int index, const char* value);
  void set_filters(int index, const char* value, size_t size);
  std::string* add_filters();
  void add_filters(const std::string& value);
  void add_filters(std::string&& value);
  void add_filters(const char* value);
  void add_filters(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& filters() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_filters();
  private:
  const std::string& _internal_filters(int index) const;
  std::string* _internal_add_filters();
  public:

  // string thing = 1;
  void clear_thing();
  const std::string& thing() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_thing(ArgT0&& arg0, ArgT... args);
  std::string* mutable_thing();
  PROTOBUF_NODISCARD std::string* release_thing();
  void set_allocated_thing(std::string* thing);
  private:
  const std::string& _internal_thing() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_thing(const std::string& value);
  std::string* _internal_mutable_thing();
  public:

  // optional string path = 2;
  bool has_path() const;
  private:
  bool _internal_has_path() const;
  public:
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // @@protoc_insertion_point(class_scope:duo.GetDesireRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> filters_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr thing_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_duo_2fduo_2eproto;
};
// -------------------------------------------------------------------

class GetDeltaRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:duo.GetDeltaRequest) */ {
 public:
  inline GetDeltaRequest() : GetDeltaRequest(nullptr) {}
  ~GetDeltaRequest() override;
  explicit PROTOBUF_CONSTEXPR GetDeltaRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetDeltaRequest(const GetDeltaRequest& from);
  GetDeltaRequest(GetDeltaRequest&& from) noexcept
    : GetDeltaRequest() {
    *this = ::std::move(from);
  }

  inline GetDeltaRequest& operator=(const GetDeltaRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetDeltaRequest& operator=(GetDeltaRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetDeltaRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetDeltaRequest* internal_default_instance() {
    return reinterpret_cast<const GetDeltaRequest*>(
               &_GetDeltaRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(GetDeltaRequest& a, GetDeltaRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetDeltaRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetDeltaRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetDeltaRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetDeltaRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetDeltaRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetDeltaRequest& from) {
    GetDeltaRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetDeltaRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "duo.GetDeltaRequest";
  }
  protected:
  explicit GetDeltaRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFiltersFieldNumber = 3,
    kThingFieldNumber = 1,
    kPathFieldNumber = 2,
  };
  // repeated string filters = 3;
  int filters_size() const;
  private:
  int _internal_filters_size() const;
  public:
  void clear_filters();
  const std::string& filters(int index) const;
  std::string* mutable_filters(int index);
  void set_filters(int index, const std::string& value);
  void set_filters(int index, std::string&& value);
  void set_filters(int index, const char* value);
  void set_filters(int index, const char* value, size_t size);
  std::string* add_filters();
  void add_filters(const std::string& value);
  void add_filters(std::string&& value);
  void add_filters(const char* value);
  void add_filters(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& filters() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_filters();
  private:
  const std::string& _internal_filters(int index) const;
  std::string* _internal_add_filters();
  public:

  // string thing = 1;
  void clear_thing();
  const std::string& thing() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_thing(ArgT0&& arg0, ArgT... args);
  std::string* mutable_thing();
  PROTOBUF_NODISCARD std::string* release_thing();
  void set_allocated_thing(std::string* thing);
  private:
  const std::string& _internal_thing() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_thing(const std::string& value);
  std::string* _internal_mutable_thing();
  public:

  // optional string path = 2;
  bool has_path() const;
  private:
  bool _internal_has_path() const;
  public:
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // @@protoc_insertion_point(class_scope:duo.GetDeltaRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> filters_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr thing_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_duo_2fduo_2eproto;
};
// -------------------------------------------------------------------

class PatchReportRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:duo.PatchReportRequest) */ {
 public:
  inline PatchReportRequest() : PatchReportRequest(nullptr) {}
  ~PatchReportRequest() override;
  explicit PROTOBUF_CONSTEXPR PatchReportRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PatchReportRequest(const PatchReportRequest& from);
  PatchReportRequest(PatchReportRequest&& from) noexcept
    : PatchReportRequest() {
    *this = ::std::move(from);
  }

  inline PatchReportRequest& operator=(const PatchReportRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PatchReportRequest& operator=(PatchReportRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PatchReportRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PatchReportRequest* internal_default_instance() {
    return reinterpret_cast<const PatchReportRequest*>(
               &_PatchReportRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(PatchReportRequest& a, PatchReportRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PatchReportRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PatchReportRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PatchReportRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PatchReportRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PatchReportRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PatchReportRequest& from) {
    PatchReportRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PatchReportRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "duo.PatchReportRequest";
  }
  protected:
  explicit PatchReportRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kThingFieldNumber = 1,
    kPathFieldNumber = 2,
    kIgnoreListenerIdFieldNumber = 6,
    kItemFieldNumber = 3,
    kConditionFieldNumber = 4,
    kMetaFieldNumber = 5,
    kItemsFieldNumber = 7,
  };
  // string thing = 1;
  void clear_thing();
  const std::string& thing() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_thing(ArgT0&& arg0, ArgT... args);
  std::string* mutable_thing();
  PROTOBUF_NODISCARD std::string* release_thing();
  void set_allocated_thing(std::string* thing);
  private:
  const std::string& _internal_thing() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_thing(const std::string& value);
  std::string* _internal_mutable_thing();
  public:

  // optional string path = 2;
  bool has_path() const;
  private:
  bool _internal_has_path() const;
  public:
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // optional string ignore_listener_id = 6;
  bool has_ignore_listener_id() const;
  private:
  bool _internal_has_ignore_listener_id() const;
  public:
  void clear_ignore_listener_id();
  const std::string& ignore_listener_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ignore_listener_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ignore_listener_id();
  PROTOBUF_NODISCARD std::string* release_ignore_listener_id();
  void set_allocated_ignore_listener_id(std::string* ignore_listener_id);
  private:
  const std::string& _internal_ignore_listener_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ignore_listener_id(const std::string& value);
  std::string* _internal_mutable_ignore_listener_id();
  public:

  // optional .google.protobuf.Value item = 3;
  bool has_item() const;
  private:
  bool _internal_has_item() const;
  public:
  void clear_item();
  const ::PROTOBUF_NAMESPACE_ID::Value& item() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Value* release_item();
  ::PROTOBUF_NAMESPACE_ID::Value* mutable_item();
  void set_allocated_item(::PROTOBUF_NAMESPACE_ID::Value* item);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Value& _internal_item() const;
  ::PROTOBUF_NAMESPACE_ID::Value* _internal_mutable_item();
  public:
  void unsafe_arena_set_allocated_item(
      ::PROTOBUF_NAMESPACE_ID::Value* item);
  ::PROTOBUF_NAMESPACE_ID::Value* unsafe_arena_release_item();

  // optional .google.protobuf.Value condition = 4;
  bool has_condition() const;
  private:
  bool _internal_has_condition() const;
  public:
  void clear_condition();
  const ::PROTOBUF_NAMESPACE_ID::Value& condition() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Value* release_condition();
  ::PROTOBUF_NAMESPACE_ID::Value* mutable_condition();
  void set_allocated_condition(::PROTOBUF_NAMESPACE_ID::Value* condition);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Value& _internal_condition() const;
  ::PROTOBUF_NAMESPACE_ID::Value* _internal_mutable_condition();
  public:
  void unsafe_arena_set_allocated_condition(
      ::PROTOBUF_NAMESPACE_ID::Value* condition);
  ::PROTOBUF_NAMESPACE_ID::Value* unsafe_arena_release_condition();

  // optional .google.protobuf.Struct meta = 5;
  bool has_meta() const;
  private:
  bool _internal_has_meta() const;
  public:
  void clear_meta();
  const ::PROTOBUF_NAMESPACE_ID::Struct& meta() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_meta();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_meta();
  void set_allocated_meta(::PROTOBUF_NAMESPACE_ID::Struct* meta);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_meta() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_meta();
  public:
  void unsafe_arena_set_allocated_meta(
      ::PROTOBUF_NAMESPACE_ID::Struct* meta);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_meta();

  // optional .google.protobuf.ListValue items = 7;
  bool has_items() const;
  private:
  bool _internal_has_items() const;
  public:
  void clear_items();
  const ::PROTOBUF_NAMESPACE_ID::ListValue& items() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::ListValue* release_items();
  ::PROTOBUF_NAMESPACE_ID::ListValue* mutable_items();
  void set_allocated_items(::PROTOBUF_NAMESPACE_ID::ListValue* items);
  private:
  const ::PROTOBUF_NAMESPACE_ID::ListValue& _internal_items() const;
  ::PROTOBUF_NAMESPACE_ID::ListValue* _internal_mutable_items();
  public:
  void unsafe_arena_set_allocated_items(
      ::PROTOBUF_NAMESPACE_ID::ListValue* items);
  ::PROTOBUF_NAMESPACE_ID::ListValue* unsafe_arena_release_items();

  // @@protoc_insertion_point(class_scope:duo.PatchReportRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr thing_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ignore_listener_id_;
    ::PROTOBUF_NAMESPACE_ID::Value* item_;
    ::PROTOBUF_NAMESPACE_ID::Value* condition_;
    ::PROTOBUF_NAMESPACE_ID::Struct* meta_;
    ::PROTOBUF_NAMESPACE_ID::ListValue* items_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_duo_2fduo_2eproto;
};
// -------------------------------------------------------------------

class PatchDesireRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:duo.PatchDesireRequest) */ {
 public:
  inline PatchDesireRequest() : PatchDesireRequest(nullptr) {}
  ~PatchDesireRequest() override;
  explicit PROTOBUF_CONSTEXPR PatchDesireRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PatchDesireRequest(const PatchDesireRequest& from);
  PatchDesireRequest(PatchDesireRequest&& from) noexcept
    : PatchDesireRequest() {
    *this = ::std::move(from);
  }

  inline PatchDesireRequest& operator=(const PatchDesireRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PatchDesireRequest& operator=(PatchDesireRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PatchDesireRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PatchDesireRequest* internal_default_instance() {
    return reinterpret_cast<const PatchDesireRequest*>(
               &_PatchDesireRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(PatchDesireRequest& a, PatchDesireRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PatchDesireRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PatchDesireRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PatchDesireRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PatchDesireRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PatchDesireRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PatchDesireRequest& from) {
    PatchDesireRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PatchDesireRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "duo.PatchDesireRequest";
  }
  protected:
  explicit PatchDesireRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kThingFieldNumber = 1,
    kPathFieldNumber = 2,
    kIgnoreListenerIdFieldNumber = 6,
    kItemFieldNumber = 3,
    kConditionFieldNumber = 4,
    kMetaFieldNumber = 5,
  };
  // string thing = 1;
  void clear_thing();
  const std::string& thing() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_thing(ArgT0&& arg0, ArgT... args);
  std::string* mutable_thing();
  PROTOBUF_NODISCARD std::string* release_thing();
  void set_allocated_thing(std::string* thing);
  private:
  const std::string& _internal_thing() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_thing(const std::string& value);
  std::string* _internal_mutable_thing();
  public:

  // optional string path = 2;
  bool has_path() const;
  private:
  bool _internal_has_path() const;
  public:
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // optional string ignore_listener_id = 6;
  bool has_ignore_listener_id() const;
  private:
  bool _internal_has_ignore_listener_id() const;
  public:
  void clear_ignore_listener_id();
  const std::string& ignore_listener_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ignore_listener_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ignore_listener_id();
  PROTOBUF_NODISCARD std::string* release_ignore_listener_id();
  void set_allocated_ignore_listener_id(std::string* ignore_listener_id);
  private:
  const std::string& _internal_ignore_listener_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ignore_listener_id(const std::string& value);
  std::string* _internal_mutable_ignore_listener_id();
  public:

  // .google.protobuf.Value item = 3;
  bool has_item() const;
  private:
  bool _internal_has_item() const;
  public:
  void clear_item();
  const ::PROTOBUF_NAMESPACE_ID::Value& item() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Value* release_item();
  ::PROTOBUF_NAMESPACE_ID::Value* mutable_item();
  void set_allocated_item(::PROTOBUF_NAMESPACE_ID::Value* item);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Value& _internal_item() const;
  ::PROTOBUF_NAMESPACE_ID::Value* _internal_mutable_item();
  public:
  void unsafe_arena_set_allocated_item(
      ::PROTOBUF_NAMESPACE_ID::Value* item);
  ::PROTOBUF_NAMESPACE_ID::Value* unsafe_arena_release_item();

  // optional .google.protobuf.Value condition = 4;
  bool has_condition() const;
  private:
  bool _internal_has_condition() const;
  public:
  void clear_condition();
  const ::PROTOBUF_NAMESPACE_ID::Value& condition() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Value* release_condition();
  ::PROTOBUF_NAMESPACE_ID::Value* mutable_condition();
  void set_allocated_condition(::PROTOBUF_NAMESPACE_ID::Value* condition);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Value& _internal_condition() const;
  ::PROTOBUF_NAMESPACE_ID::Value* _internal_mutable_condition();
  public:
  void unsafe_arena_set_allocated_condition(
      ::PROTOBUF_NAMESPACE_ID::Value* condition);
  ::PROTOBUF_NAMESPACE_ID::Value* unsafe_arena_release_condition();

  // optional .google.protobuf.Struct meta = 5;
  bool has_meta() const;
  private:
  bool _internal_has_meta() const;
  public:
  void clear_meta();
  const ::PROTOBUF_NAMESPACE_ID::Struct& meta() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_meta();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_meta();
  void set_allocated_meta(::PROTOBUF_NAMESPACE_ID::Struct* meta);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_meta() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_meta();
  public:
  void unsafe_arena_set_allocated_meta(
      ::PROTOBUF_NAMESPACE_ID::Struct* meta);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_meta();

  // @@protoc_insertion_point(class_scope:duo.PatchDesireRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr thing_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ignore_listener_id_;
    ::PROTOBUF_NAMESPACE_ID::Value* item_;
    ::PROTOBUF_NAMESPACE_ID::Value* condition_;
    ::PROTOBUF_NAMESPACE_ID::Struct* meta_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_duo_2fduo_2eproto;
};
// -------------------------------------------------------------------

class DeleteRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:duo.DeleteRequest) */ {
 public:
  inline DeleteRequest() : DeleteRequest(nullptr) {}
  ~DeleteRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteRequest(const DeleteRequest& from);
  DeleteRequest(DeleteRequest&& from) noexcept
    : DeleteRequest() {
    *this = ::std::move(from);
  }

  inline DeleteRequest& operator=(const DeleteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteRequest& operator=(DeleteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteRequest*>(
               &_DeleteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(DeleteRequest& a, DeleteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteRequest& from) {
    DeleteRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "duo.DeleteRequest";
  }
  protected:
  explicit DeleteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kThingFieldNumber = 1,
  };
  // string thing = 1;
  void clear_thing();
  const std::string& thing() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_thing(ArgT0&& arg0, ArgT... args);
  std::string* mutable_thing();
  PROTOBUF_NODISCARD std::string* release_thing();
  void set_allocated_thing(std::string* thing);
  private:
  const std::string& _internal_thing() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_thing(const std::string& value);
  std::string* _internal_mutable_thing();
  public:

  // @@protoc_insertion_point(class_scope:duo.DeleteRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr thing_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_duo_2fduo_2eproto;
};
// -------------------------------------------------------------------

class UploadMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:duo.UploadMetadata) */ {
 public:
  inline UploadMetadata() : UploadMetadata(nullptr) {}
  ~UploadMetadata() override;
  explicit PROTOBUF_CONSTEXPR UploadMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UploadMetadata(const UploadMetadata& from);
  UploadMetadata(UploadMetadata&& from) noexcept
    : UploadMetadata() {
    *this = ::std::move(from);
  }

  inline UploadMetadata& operator=(const UploadMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline UploadMetadata& operator=(UploadMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UploadMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const UploadMetadata* internal_default_instance() {
    return reinterpret_cast<const UploadMetadata*>(
               &_UploadMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(UploadMetadata& a, UploadMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(UploadMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UploadMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UploadMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UploadMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UploadMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UploadMetadata& from) {
    UploadMetadata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UploadMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "duo.UploadMetadata";
  }
  protected:
  explicit UploadMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kThingFieldNumber = 1,
    kPathFieldNumber = 2,
  };
  // string thing = 1;
  void clear_thing();
  const std::string& thing() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_thing(ArgT0&& arg0, ArgT... args);
  std::string* mutable_thing();
  PROTOBUF_NODISCARD std::string* release_thing();
  void set_allocated_thing(std::string* thing);
  private:
  const std::string& _internal_thing() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_thing(const std::string& value);
  std::string* _internal_mutable_thing();
  public:

  // string path = 2;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // @@protoc_insertion_point(class_scope:duo.UploadMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr thing_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_duo_2fduo_2eproto;
};
// -------------------------------------------------------------------

class UploadRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:duo.UploadRequest) */ {
 public:
  inline UploadRequest() : UploadRequest(nullptr) {}
  ~UploadRequest() override;
  explicit PROTOBUF_CONSTEXPR UploadRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UploadRequest(const UploadRequest& from);
  UploadRequest(UploadRequest&& from) noexcept
    : UploadRequest() {
    *this = ::std::move(from);
  }

  inline UploadRequest& operator=(const UploadRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UploadRequest& operator=(UploadRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UploadRequest& default_instance() {
    return *internal_default_instance();
  }
  enum DataCase {
    kMeta = 1,
    kChunk = 2,
    DATA_NOT_SET = 0,
  };

  static inline const UploadRequest* internal_default_instance() {
    return reinterpret_cast<const UploadRequest*>(
               &_UploadRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(UploadRequest& a, UploadRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UploadRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UploadRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UploadRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UploadRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UploadRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UploadRequest& from) {
    UploadRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UploadRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "duo.UploadRequest";
  }
  protected:
  explicit UploadRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetaFieldNumber = 1,
    kChunkFieldNumber = 2,
  };
  // .duo.UploadMetadata meta = 1;
  bool has_meta() const;
  private:
  bool _internal_has_meta() const;
  public:
  void clear_meta();
  const ::duo::UploadMetadata& meta() const;
  PROTOBUF_NODISCARD ::duo::UploadMetadata* release_meta();
  ::duo::UploadMetadata* mutable_meta();
  void set_allocated_meta(::duo::UploadMetadata* meta);
  private:
  const ::duo::UploadMetadata& _internal_meta() const;
  ::duo::UploadMetadata* _internal_mutable_meta();
  public:
  void unsafe_arena_set_allocated_meta(
      ::duo::UploadMetadata* meta);
  ::duo::UploadMetadata* unsafe_arena_release_meta();

  // bytes chunk = 2;
  bool has_chunk() const;
  private:
  bool _internal_has_chunk() const;
  public:
  void clear_chunk();
  const std::string& chunk() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_chunk(ArgT0&& arg0, ArgT... args);
  std::string* mutable_chunk();
  PROTOBUF_NODISCARD std::string* release_chunk();
  void set_allocated_chunk(std::string* chunk);
  private:
  const std::string& _internal_chunk() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chunk(const std::string& value);
  std::string* _internal_mutable_chunk();
  public:

  void clear_data();
  DataCase data_case() const;
  // @@protoc_insertion_point(class_scope:duo.UploadRequest)
 private:
  class _Internal;
  void set_has_meta();
  void set_has_chunk();

  inline bool has_data() const;
  inline void clear_has_data();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union DataUnion {
      constexpr DataUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::duo::UploadMetadata* meta_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chunk_;
    } data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_duo_2fduo_2eproto;
};
// -------------------------------------------------------------------

class GetThingListRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:duo.GetThingListRequest) */ {
 public:
  inline GetThingListRequest() : GetThingListRequest(nullptr) {}
  ~GetThingListRequest() override;
  explicit PROTOBUF_CONSTEXPR GetThingListRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetThingListRequest(const GetThingListRequest& from);
  GetThingListRequest(GetThingListRequest&& from) noexcept
    : GetThingListRequest() {
    *this = ::std::move(from);
  }

  inline GetThingListRequest& operator=(const GetThingListRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetThingListRequest& operator=(GetThingListRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetThingListRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetThingListRequest* internal_default_instance() {
    return reinterpret_cast<const GetThingListRequest*>(
               &_GetThingListRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(GetThingListRequest& a, GetThingListRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetThingListRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetThingListRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetThingListRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetThingListRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetThingListRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetThingListRequest& from) {
    GetThingListRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetThingListRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "duo.GetThingListRequest";
  }
  protected:
  explicit GetThingListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFromFieldNumber = 1,
    kFilterFieldNumber = 3,
    kPageSizeFieldNumber = 2,
  };
  // optional string from = 1;
  bool has_from() const;
  private:
  bool _internal_has_from() const;
  public:
  void clear_from();
  const std::string& from() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_from(ArgT0&& arg0, ArgT... args);
  std::string* mutable_from();
  PROTOBUF_NODISCARD std::string* release_from();
  void set_allocated_from(std::string* from);
  private:
  const std::string& _internal_from() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_from(const std::string& value);
  std::string* _internal_mutable_from();
  public:

  // optional string filter = 3;
  bool has_filter() const;
  private:
  bool _internal_has_filter() const;
  public:
  void clear_filter();
  const std::string& filter() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filter(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filter();
  PROTOBUF_NODISCARD std::string* release_filter();
  void set_allocated_filter(std::string* filter);
  private:
  const std::string& _internal_filter() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filter(const std::string& value);
  std::string* _internal_mutable_filter();
  public:

  // optional int32 page_size = 2;
  bool has_page_size() const;
  private:
  bool _internal_has_page_size() const;
  public:
  void clear_page_size();
  int32_t page_size() const;
  void set_page_size(int32_t value);
  private:
  int32_t _internal_page_size() const;
  void _internal_set_page_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:duo.GetThingListRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr from_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filter_;
    int32_t page_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_duo_2fduo_2eproto;
};
// -------------------------------------------------------------------

class ListenReportRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:duo.ListenReportRequest) */ {
 public:
  inline ListenReportRequest() : ListenReportRequest(nullptr) {}
  ~ListenReportRequest() override;
  explicit PROTOBUF_CONSTEXPR ListenReportRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListenReportRequest(const ListenReportRequest& from);
  ListenReportRequest(ListenReportRequest&& from) noexcept
    : ListenReportRequest() {
    *this = ::std::move(from);
  }

  inline ListenReportRequest& operator=(const ListenReportRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListenReportRequest& operator=(ListenReportRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListenReportRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListenReportRequest* internal_default_instance() {
    return reinterpret_cast<const ListenReportRequest*>(
               &_ListenReportRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ListenReportRequest& a, ListenReportRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListenReportRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListenReportRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListenReportRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListenReportRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListenReportRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListenReportRequest& from) {
    ListenReportRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListenReportRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "duo.ListenReportRequest";
  }
  protected:
  explicit ListenReportRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFiltersFieldNumber = 3,
    kThingFieldNumber = 1,
    kIdFieldNumber = 4,
    kNoMergeFieldNumber = 2,
    kNeedsInitialValueFieldNumber = 5,
  };
  // repeated string filters = 3;
  int filters_size() const;
  private:
  int _internal_filters_size() const;
  public:
  void clear_filters();
  const std::string& filters(int index) const;
  std::string* mutable_filters(int index);
  void set_filters(int index, const std::string& value);
  void set_filters(int index, std::string&& value);
  void set_filters(int index, const char* value);
  void set_filters(int index, const char* value, size_t size);
  std::string* add_filters();
  void add_filters(const std::string& value);
  void add_filters(std::string&& value);
  void add_filters(const char* value);
  void add_filters(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& filters() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_filters();
  private:
  const std::string& _internal_filters(int index) const;
  std::string* _internal_add_filters();
  public:

  // string thing = 1;
  void clear_thing();
  const std::string& thing() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_thing(ArgT0&& arg0, ArgT... args);
  std::string* mutable_thing();
  PROTOBUF_NODISCARD std::string* release_thing();
  void set_allocated_thing(std::string* thing);
  private:
  const std::string& _internal_thing() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_thing(const std::string& value);
  std::string* _internal_mutable_thing();
  public:

  // optional string id = 4;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // optional bool no_merge = 2;
  bool has_no_merge() const;
  private:
  bool _internal_has_no_merge() const;
  public:
  void clear_no_merge();
  bool no_merge() const;
  void set_no_merge(bool value);
  private:
  bool _internal_no_merge() const;
  void _internal_set_no_merge(bool value);
  public:

  // optional bool needs_initial_value = 5;
  bool has_needs_initial_value() const;
  private:
  bool _internal_has_needs_initial_value() const;
  public:
  void clear_needs_initial_value();
  bool needs_initial_value() const;
  void set_needs_initial_value(bool value);
  private:
  bool _internal_needs_initial_value() const;
  void _internal_set_needs_initial_value(bool value);
  public:

  // @@protoc_insertion_point(class_scope:duo.ListenReportRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> filters_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr thing_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    bool no_merge_;
    bool needs_initial_value_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_duo_2fduo_2eproto;
};
// -------------------------------------------------------------------

class ListenDesireRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:duo.ListenDesireRequest) */ {
 public:
  inline ListenDesireRequest() : ListenDesireRequest(nullptr) {}
  ~ListenDesireRequest() override;
  explicit PROTOBUF_CONSTEXPR ListenDesireRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListenDesireRequest(const ListenDesireRequest& from);
  ListenDesireRequest(ListenDesireRequest&& from) noexcept
    : ListenDesireRequest() {
    *this = ::std::move(from);
  }

  inline ListenDesireRequest& operator=(const ListenDesireRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListenDesireRequest& operator=(ListenDesireRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListenDesireRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListenDesireRequest* internal_default_instance() {
    return reinterpret_cast<const ListenDesireRequest*>(
               &_ListenDesireRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ListenDesireRequest& a, ListenDesireRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListenDesireRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListenDesireRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListenDesireRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListenDesireRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListenDesireRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListenDesireRequest& from) {
    ListenDesireRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListenDesireRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "duo.ListenDesireRequest";
  }
  protected:
  explicit ListenDesireRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFiltersFieldNumber = 2,
    kThingFieldNumber = 1,
    kIdFieldNumber = 3,
    kNeedsInitialValueFieldNumber = 4,
  };
  // repeated string filters = 2;
  int filters_size() const;
  private:
  int _internal_filters_size() const;
  public:
  void clear_filters();
  const std::string& filters(int index) const;
  std::string* mutable_filters(int index);
  void set_filters(int index, const std::string& value);
  void set_filters(int index, std::string&& value);
  void set_filters(int index, const char* value);
  void set_filters(int index, const char* value, size_t size);
  std::string* add_filters();
  void add_filters(const std::string& value);
  void add_filters(std::string&& value);
  void add_filters(const char* value);
  void add_filters(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& filters() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_filters();
  private:
  const std::string& _internal_filters(int index) const;
  std::string* _internal_add_filters();
  public:

  // string thing = 1;
  void clear_thing();
  const std::string& thing() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_thing(ArgT0&& arg0, ArgT... args);
  std::string* mutable_thing();
  PROTOBUF_NODISCARD std::string* release_thing();
  void set_allocated_thing(std::string* thing);
  private:
  const std::string& _internal_thing() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_thing(const std::string& value);
  std::string* _internal_mutable_thing();
  public:

  // optional string id = 3;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // optional bool needs_initial_value = 4;
  bool has_needs_initial_value() const;
  private:
  bool _internal_has_needs_initial_value() const;
  public:
  void clear_needs_initial_value();
  bool needs_initial_value() const;
  void set_needs_initial_value(bool value);
  private:
  bool _internal_needs_initial_value() const;
  void _internal_set_needs_initial_value(bool value);
  public:

  // @@protoc_insertion_point(class_scope:duo.ListenDesireRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> filters_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr thing_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    bool needs_initial_value_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_duo_2fduo_2eproto;
};
// -------------------------------------------------------------------

class ListenDeltaRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:duo.ListenDeltaRequest) */ {
 public:
  inline ListenDeltaRequest() : ListenDeltaRequest(nullptr) {}
  ~ListenDeltaRequest() override;
  explicit PROTOBUF_CONSTEXPR ListenDeltaRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListenDeltaRequest(const ListenDeltaRequest& from);
  ListenDeltaRequest(ListenDeltaRequest&& from) noexcept
    : ListenDeltaRequest() {
    *this = ::std::move(from);
  }

  inline ListenDeltaRequest& operator=(const ListenDeltaRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListenDeltaRequest& operator=(ListenDeltaRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListenDeltaRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListenDeltaRequest* internal_default_instance() {
    return reinterpret_cast<const ListenDeltaRequest*>(
               &_ListenDeltaRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ListenDeltaRequest& a, ListenDeltaRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListenDeltaRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListenDeltaRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListenDeltaRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListenDeltaRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListenDeltaRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListenDeltaRequest& from) {
    ListenDeltaRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListenDeltaRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "duo.ListenDeltaRequest";
  }
  protected:
  explicit ListenDeltaRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFiltersFieldNumber = 2,
    kThingFieldNumber = 1,
    kIdFieldNumber = 3,
    kNeedsInitialValueFieldNumber = 4,
  };
  // repeated string filters = 2;
  int filters_size() const;
  private:
  int _internal_filters_size() const;
  public:
  void clear_filters();
  const std::string& filters(int index) const;
  std::string* mutable_filters(int index);
  void set_filters(int index, const std::string& value);
  void set_filters(int index, std::string&& value);
  void set_filters(int index, const char* value);
  void set_filters(int index, const char* value, size_t size);
  std::string* add_filters();
  void add_filters(const std::string& value);
  void add_filters(std::string&& value);
  void add_filters(const char* value);
  void add_filters(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& filters() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_filters();
  private:
  const std::string& _internal_filters(int index) const;
  std::string* _internal_add_filters();
  public:

  // string thing = 1;
  void clear_thing();
  const std::string& thing() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_thing(ArgT0&& arg0, ArgT... args);
  std::string* mutable_thing();
  PROTOBUF_NODISCARD std::string* release_thing();
  void set_allocated_thing(std::string* thing);
  private:
  const std::string& _internal_thing() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_thing(const std::string& value);
  std::string* _internal_mutable_thing();
  public:

  // optional string id = 3;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // optional bool needs_initial_value = 4;
  bool has_needs_initial_value() const;
  private:
  bool _internal_has_needs_initial_value() const;
  public:
  void clear_needs_initial_value();
  bool needs_initial_value() const;
  void set_needs_initial_value(bool value);
  private:
  bool _internal_needs_initial_value() const;
  void _internal_set_needs_initial_value(bool value);
  public:

  // @@protoc_insertion_point(class_scope:duo.ListenDeltaRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> filters_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr thing_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    bool needs_initial_value_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_duo_2fduo_2eproto;
};
// -------------------------------------------------------------------

class GetResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:duo.GetResponse) */ {
 public:
  inline GetResponse() : GetResponse(nullptr) {}
  ~GetResponse() override;
  explicit PROTOBUF_CONSTEXPR GetResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetResponse(const GetResponse& from);
  GetResponse(GetResponse&& from) noexcept
    : GetResponse() {
    *this = ::std::move(from);
  }

  inline GetResponse& operator=(const GetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetResponse& operator=(GetResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetResponse* internal_default_instance() {
    return reinterpret_cast<const GetResponse*>(
               &_GetResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(GetResponse& a, GetResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetResponse& from) {
    GetResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "duo.GetResponse";
  }
  protected:
  explicit GetResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestIdFieldNumber = 2,
    kItemFieldNumber = 3,
    kCodeFieldNumber = 1,
  };
  // string request_id = 2;
  void clear_request_id();
  const std::string& request_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_request_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_request_id();
  PROTOBUF_NODISCARD std::string* release_request_id();
  void set_allocated_request_id(std::string* request_id);
  private:
  const std::string& _internal_request_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_request_id(const std::string& value);
  std::string* _internal_mutable_request_id();
  public:

  // .google.protobuf.Value item = 3;
  bool has_item() const;
  private:
  bool _internal_has_item() const;
  public:
  void clear_item();
  const ::PROTOBUF_NAMESPACE_ID::Value& item() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Value* release_item();
  ::PROTOBUF_NAMESPACE_ID::Value* mutable_item();
  void set_allocated_item(::PROTOBUF_NAMESPACE_ID::Value* item);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Value& _internal_item() const;
  ::PROTOBUF_NAMESPACE_ID::Value* _internal_mutable_item();
  public:
  void unsafe_arena_set_allocated_item(
      ::PROTOBUF_NAMESPACE_ID::Value* item);
  ::PROTOBUF_NAMESPACE_ID::Value* unsafe_arena_release_item();

  // .duo.StatusCode code = 1;
  void clear_code();
  ::duo::StatusCode code() const;
  void set_code(::duo::StatusCode value);
  private:
  ::duo::StatusCode _internal_code() const;
  void _internal_set_code(::duo::StatusCode value);
  public:

  // @@protoc_insertion_point(class_scope:duo.GetResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr request_id_;
    ::PROTOBUF_NAMESPACE_ID::Value* item_;
    int code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_duo_2fduo_2eproto;
};
// -------------------------------------------------------------------

class PatchResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:duo.PatchResponse) */ {
 public:
  inline PatchResponse() : PatchResponse(nullptr) {}
  ~PatchResponse() override;
  explicit PROTOBUF_CONSTEXPR PatchResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PatchResponse(const PatchResponse& from);
  PatchResponse(PatchResponse&& from) noexcept
    : PatchResponse() {
    *this = ::std::move(from);
  }

  inline PatchResponse& operator=(const PatchResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PatchResponse& operator=(PatchResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PatchResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PatchResponse* internal_default_instance() {
    return reinterpret_cast<const PatchResponse*>(
               &_PatchResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(PatchResponse& a, PatchResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PatchResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PatchResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PatchResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PatchResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PatchResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PatchResponse& from) {
    PatchResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PatchResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "duo.PatchResponse";
  }
  protected:
  explicit PatchResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestIdFieldNumber = 2,
    kMessageFieldNumber = 3,
    kCodeFieldNumber = 1,
  };
  // string request_id = 2;
  void clear_request_id();
  const std::string& request_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_request_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_request_id();
  PROTOBUF_NODISCARD std::string* release_request_id();
  void set_allocated_request_id(std::string* request_id);
  private:
  const std::string& _internal_request_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_request_id(const std::string& value);
  std::string* _internal_mutable_request_id();
  public:

  // string message = 3;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .duo.StatusCode code = 1;
  void clear_code();
  ::duo::StatusCode code() const;
  void set_code(::duo::StatusCode value);
  private:
  ::duo::StatusCode _internal_code() const;
  void _internal_set_code(::duo::StatusCode value);
  public:

  // @@protoc_insertion_point(class_scope:duo.PatchResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr request_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    int code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_duo_2fduo_2eproto;
};
// -------------------------------------------------------------------

class PatchAndWaitResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:duo.PatchAndWaitResponse) */ {
 public:
  inline PatchAndWaitResponse() : PatchAndWaitResponse(nullptr) {}
  ~PatchAndWaitResponse() override;
  explicit PROTOBUF_CONSTEXPR PatchAndWaitResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PatchAndWaitResponse(const PatchAndWaitResponse& from);
  PatchAndWaitResponse(PatchAndWaitResponse&& from) noexcept
    : PatchAndWaitResponse() {
    *this = ::std::move(from);
  }

  inline PatchAndWaitResponse& operator=(const PatchAndWaitResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PatchAndWaitResponse& operator=(PatchAndWaitResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PatchAndWaitResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PatchAndWaitResponse* internal_default_instance() {
    return reinterpret_cast<const PatchAndWaitResponse*>(
               &_PatchAndWaitResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(PatchAndWaitResponse& a, PatchAndWaitResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PatchAndWaitResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PatchAndWaitResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PatchAndWaitResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PatchAndWaitResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PatchAndWaitResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PatchAndWaitResponse& from) {
    PatchAndWaitResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PatchAndWaitResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "duo.PatchAndWaitResponse";
  }
  protected:
  explicit PatchAndWaitResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeltaFieldNumber = 2,
    kCompletedFieldNumber = 1,
  };
  // .google.protobuf.Value delta = 2;
  bool has_delta() const;
  private:
  bool _internal_has_delta() const;
  public:
  void clear_delta();
  const ::PROTOBUF_NAMESPACE_ID::Value& delta() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Value* release_delta();
  ::PROTOBUF_NAMESPACE_ID::Value* mutable_delta();
  void set_allocated_delta(::PROTOBUF_NAMESPACE_ID::Value* delta);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Value& _internal_delta() const;
  ::PROTOBUF_NAMESPACE_ID::Value* _internal_mutable_delta();
  public:
  void unsafe_arena_set_allocated_delta(
      ::PROTOBUF_NAMESPACE_ID::Value* delta);
  ::PROTOBUF_NAMESPACE_ID::Value* unsafe_arena_release_delta();

  // bool completed = 1;
  void clear_completed();
  bool completed() const;
  void set_completed(bool value);
  private:
  bool _internal_completed() const;
  void _internal_set_completed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:duo.PatchAndWaitResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::Value* delta_;
    bool completed_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_duo_2fduo_2eproto;
};
// -------------------------------------------------------------------

class DeleteResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:duo.DeleteResponse) */ {
 public:
  inline DeleteResponse() : DeleteResponse(nullptr) {}
  ~DeleteResponse() override;
  explicit PROTOBUF_CONSTEXPR DeleteResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteResponse(const DeleteResponse& from);
  DeleteResponse(DeleteResponse&& from) noexcept
    : DeleteResponse() {
    *this = ::std::move(from);
  }

  inline DeleteResponse& operator=(const DeleteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteResponse& operator=(DeleteResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteResponse*>(
               &_DeleteResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(DeleteResponse& a, DeleteResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteResponse& from) {
    DeleteResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "duo.DeleteResponse";
  }
  protected:
  explicit DeleteResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestIdFieldNumber = 2,
    kMessageFieldNumber = 3,
    kCodeFieldNumber = 1,
  };
  // string request_id = 2;
  void clear_request_id();
  const std::string& request_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_request_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_request_id();
  PROTOBUF_NODISCARD std::string* release_request_id();
  void set_allocated_request_id(std::string* request_id);
  private:
  const std::string& _internal_request_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_request_id(const std::string& value);
  std::string* _internal_mutable_request_id();
  public:

  // string message = 3;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .duo.StatusCode code = 1;
  void clear_code();
  ::duo::StatusCode code() const;
  void set_code(::duo::StatusCode value);
  private:
  ::duo::StatusCode _internal_code() const;
  void _internal_set_code(::duo::StatusCode value);
  public:

  // @@protoc_insertion_point(class_scope:duo.DeleteResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr request_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    int code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_duo_2fduo_2eproto;
};
// -------------------------------------------------------------------

class UploadResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:duo.UploadResponse) */ {
 public:
  inline UploadResponse() : UploadResponse(nullptr) {}
  ~UploadResponse() override;
  explicit PROTOBUF_CONSTEXPR UploadResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UploadResponse(const UploadResponse& from);
  UploadResponse(UploadResponse&& from) noexcept
    : UploadResponse() {
    *this = ::std::move(from);
  }

  inline UploadResponse& operator=(const UploadResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UploadResponse& operator=(UploadResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UploadResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UploadResponse* internal_default_instance() {
    return reinterpret_cast<const UploadResponse*>(
               &_UploadResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(UploadResponse& a, UploadResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UploadResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UploadResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UploadResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UploadResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UploadResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UploadResponse& from) {
    UploadResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UploadResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "duo.UploadResponse";
  }
  protected:
  explicit UploadResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestIdFieldNumber = 2,
    kMessageFieldNumber = 3,
    kCodeFieldNumber = 1,
  };
  // string request_id = 2;
  void clear_request_id();
  const std::string& request_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_request_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_request_id();
  PROTOBUF_NODISCARD std::string* release_request_id();
  void set_allocated_request_id(std::string* request_id);
  private:
  const std::string& _internal_request_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_request_id(const std::string& value);
  std::string* _internal_mutable_request_id();
  public:

  // string message = 3;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .duo.StatusCode code = 1;
  void clear_code();
  ::duo::StatusCode code() const;
  void set_code(::duo::StatusCode value);
  private:
  ::duo::StatusCode _internal_code() const;
  void _internal_set_code(::duo::StatusCode value);
  public:

  // @@protoc_insertion_point(class_scope:duo.UploadResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr request_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    int code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_duo_2fduo_2eproto;
};
// -------------------------------------------------------------------

class GetThingListResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:duo.GetThingListResponse) */ {
 public:
  inline GetThingListResponse() : GetThingListResponse(nullptr) {}
  ~GetThingListResponse() override;
  explicit PROTOBUF_CONSTEXPR GetThingListResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetThingListResponse(const GetThingListResponse& from);
  GetThingListResponse(GetThingListResponse&& from) noexcept
    : GetThingListResponse() {
    *this = ::std::move(from);
  }

  inline GetThingListResponse& operator=(const GetThingListResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetThingListResponse& operator=(GetThingListResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetThingListResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetThingListResponse* internal_default_instance() {
    return reinterpret_cast<const GetThingListResponse*>(
               &_GetThingListResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(GetThingListResponse& a, GetThingListResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetThingListResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetThingListResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetThingListResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetThingListResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetThingListResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetThingListResponse& from) {
    GetThingListResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetThingListResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "duo.GetThingListResponse";
  }
  protected:
  explicit GetThingListResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kThingNamesFieldNumber = 3,
    kRequestIdFieldNumber = 2,
    kNextTokenFieldNumber = 5,
    kTotalCountFieldNumber = 4,
    kCodeFieldNumber = 1,
  };
  // repeated string thing_names = 3;
  int thing_names_size() const;
  private:
  int _internal_thing_names_size() const;
  public:
  void clear_thing_names();
  const std::string& thing_names(int index) const;
  std::string* mutable_thing_names(int index);
  void set_thing_names(int index, const std::string& value);
  void set_thing_names(int index, std::string&& value);
  void set_thing_names(int index, const char* value);
  void set_thing_names(int index, const char* value, size_t size);
  std::string* add_thing_names();
  void add_thing_names(const std::string& value);
  void add_thing_names(std::string&& value);
  void add_thing_names(const char* value);
  void add_thing_names(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& thing_names() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_thing_names();
  private:
  const std::string& _internal_thing_names(int index) const;
  std::string* _internal_add_thing_names();
  public:

  // string request_id = 2;
  void clear_request_id();
  const std::string& request_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_request_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_request_id();
  PROTOBUF_NODISCARD std::string* release_request_id();
  void set_allocated_request_id(std::string* request_id);
  private:
  const std::string& _internal_request_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_request_id(const std::string& value);
  std::string* _internal_mutable_request_id();
  public:

  // optional string next_token = 5;
  bool has_next_token() const;
  private:
  bool _internal_has_next_token() const;
  public:
  void clear_next_token();
  const std::string& next_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_next_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_next_token();
  PROTOBUF_NODISCARD std::string* release_next_token();
  void set_allocated_next_token(std::string* next_token);
  private:
  const std::string& _internal_next_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_token(const std::string& value);
  std::string* _internal_mutable_next_token();
  public:

  // uint64 total_count = 4;
  void clear_total_count();
  uint64_t total_count() const;
  void set_total_count(uint64_t value);
  private:
  uint64_t _internal_total_count() const;
  void _internal_set_total_count(uint64_t value);
  public:

  // .duo.StatusCode code = 1;
  void clear_code();
  ::duo::StatusCode code() const;
  void set_code(::duo::StatusCode value);
  private:
  ::duo::StatusCode _internal_code() const;
  void _internal_set_code(::duo::StatusCode value);
  public:

  // @@protoc_insertion_point(class_scope:duo.GetThingListResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> thing_names_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr request_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_token_;
    uint64_t total_count_;
    int code_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_duo_2fduo_2eproto;
};
// -------------------------------------------------------------------

class ListenResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:duo.ListenResponse) */ {
 public:
  inline ListenResponse() : ListenResponse(nullptr) {}
  ~ListenResponse() override;
  explicit PROTOBUF_CONSTEXPR ListenResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListenResponse(const ListenResponse& from);
  ListenResponse(ListenResponse&& from) noexcept
    : ListenResponse() {
    *this = ::std::move(from);
  }

  inline ListenResponse& operator=(const ListenResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListenResponse& operator=(ListenResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListenResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListenResponse* internal_default_instance() {
    return reinterpret_cast<const ListenResponse*>(
               &_ListenResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ListenResponse& a, ListenResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListenResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListenResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListenResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListenResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListenResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListenResponse& from) {
    ListenResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListenResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "duo.ListenResponse";
  }
  protected:
  explicit ListenResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
    kMetaFieldNumber = 2,
  };
  // .google.protobuf.ListValue items = 1;
  bool has_items() const;
  private:
  bool _internal_has_items() const;
  public:
  void clear_items();
  const ::PROTOBUF_NAMESPACE_ID::ListValue& items() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::ListValue* release_items();
  ::PROTOBUF_NAMESPACE_ID::ListValue* mutable_items();
  void set_allocated_items(::PROTOBUF_NAMESPACE_ID::ListValue* items);
  private:
  const ::PROTOBUF_NAMESPACE_ID::ListValue& _internal_items() const;
  ::PROTOBUF_NAMESPACE_ID::ListValue* _internal_mutable_items();
  public:
  void unsafe_arena_set_allocated_items(
      ::PROTOBUF_NAMESPACE_ID::ListValue* items);
  ::PROTOBUF_NAMESPACE_ID::ListValue* unsafe_arena_release_items();

  // optional .google.protobuf.Struct meta = 2;
  bool has_meta() const;
  private:
  bool _internal_has_meta() const;
  public:
  void clear_meta();
  const ::PROTOBUF_NAMESPACE_ID::Struct& meta() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_meta();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_meta();
  void set_allocated_meta(::PROTOBUF_NAMESPACE_ID::Struct* meta);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_meta() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_meta();
  public:
  void unsafe_arena_set_allocated_meta(
      ::PROTOBUF_NAMESPACE_ID::Struct* meta);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_meta();

  // @@protoc_insertion_point(class_scope:duo.ListenResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::ListValue* items_;
    ::PROTOBUF_NAMESPACE_ID::Struct* meta_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_duo_2fduo_2eproto;
};
// -------------------------------------------------------------------

class PingRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:duo.PingRequest) */ {
 public:
  inline PingRequest() : PingRequest(nullptr) {}
  ~PingRequest() override;
  explicit PROTOBUF_CONSTEXPR PingRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PingRequest(const PingRequest& from);
  PingRequest(PingRequest&& from) noexcept
    : PingRequest() {
    *this = ::std::move(from);
  }

  inline PingRequest& operator=(const PingRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PingRequest& operator=(PingRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PingRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PingRequest* internal_default_instance() {
    return reinterpret_cast<const PingRequest*>(
               &_PingRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(PingRequest& a, PingRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PingRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PingRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PingRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PingRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PingRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PingRequest& from) {
    PingRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PingRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "duo.PingRequest";
  }
  protected:
  explicit PingRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSeedFieldNumber = 1,
  };
  // int32 seed = 1;
  void clear_seed();
  int32_t seed() const;
  void set_seed(int32_t value);
  private:
  int32_t _internal_seed() const;
  void _internal_set_seed(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:duo.PingRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t seed_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_duo_2fduo_2eproto;
};
// -------------------------------------------------------------------

class PingResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:duo.PingResponse) */ {
 public:
  inline PingResponse() : PingResponse(nullptr) {}
  ~PingResponse() override;
  explicit PROTOBUF_CONSTEXPR PingResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PingResponse(const PingResponse& from);
  PingResponse(PingResponse&& from) noexcept
    : PingResponse() {
    *this = ::std::move(from);
  }

  inline PingResponse& operator=(const PingResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PingResponse& operator=(PingResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PingResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PingResponse* internal_default_instance() {
    return reinterpret_cast<const PingResponse*>(
               &_PingResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(PingResponse& a, PingResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PingResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PingResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PingResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PingResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PingResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PingResponse& from) {
    PingResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PingResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "duo.PingResponse";
  }
  protected:
  explicit PingResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSeedFieldNumber = 1,
  };
  // int32 seed = 1;
  void clear_seed();
  int32_t seed() const;
  void set_seed(int32_t value);
  private:
  int32_t _internal_seed() const;
  void _internal_set_seed(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:duo.PingResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t seed_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_duo_2fduo_2eproto;
};
// -------------------------------------------------------------------

class GetNextJobRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:duo.GetNextJobRequest) */ {
 public:
  inline GetNextJobRequest() : GetNextJobRequest(nullptr) {}
  ~GetNextJobRequest() override;
  explicit PROTOBUF_CONSTEXPR GetNextJobRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetNextJobRequest(const GetNextJobRequest& from);
  GetNextJobRequest(GetNextJobRequest&& from) noexcept
    : GetNextJobRequest() {
    *this = ::std::move(from);
  }

  inline GetNextJobRequest& operator=(const GetNextJobRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetNextJobRequest& operator=(GetNextJobRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetNextJobRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetNextJobRequest* internal_default_instance() {
    return reinterpret_cast<const GetNextJobRequest*>(
               &_GetNextJobRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(GetNextJobRequest& a, GetNextJobRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetNextJobRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetNextJobRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetNextJobRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetNextJobRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetNextJobRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetNextJobRequest& from) {
    GetNextJobRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetNextJobRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "duo.GetNextJobRequest";
  }
  protected:
  explicit GetNextJobRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kThingFieldNumber = 1,
  };
  // string thing = 1;
  void clear_thing();
  const std::string& thing() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_thing(ArgT0&& arg0, ArgT... args);
  std::string* mutable_thing();
  PROTOBUF_NODISCARD std::string* release_thing();
  void set_allocated_thing(std::string* thing);
  private:
  const std::string& _internal_thing() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_thing(const std::string& value);
  std::string* _internal_mutable_thing();
  public:

  // @@protoc_insertion_point(class_scope:duo.GetNextJobRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr thing_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_duo_2fduo_2eproto;
};
// -------------------------------------------------------------------

class GetJobRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:duo.GetJobRequest) */ {
 public:
  inline GetJobRequest() : GetJobRequest(nullptr) {}
  ~GetJobRequest() override;
  explicit PROTOBUF_CONSTEXPR GetJobRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetJobRequest(const GetJobRequest& from);
  GetJobRequest(GetJobRequest&& from) noexcept
    : GetJobRequest() {
    *this = ::std::move(from);
  }

  inline GetJobRequest& operator=(const GetJobRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetJobRequest& operator=(GetJobRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetJobRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetJobRequest* internal_default_instance() {
    return reinterpret_cast<const GetJobRequest*>(
               &_GetJobRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(GetJobRequest& a, GetJobRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetJobRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetJobRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetJobRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetJobRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetJobRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetJobRequest& from) {
    GetJobRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetJobRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "duo.GetJobRequest";
  }
  protected:
  explicit GetJobRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kThingFieldNumber = 1,
    kJobIdFieldNumber = 2,
  };
  // string thing = 1;
  void clear_thing();
  const std::string& thing() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_thing(ArgT0&& arg0, ArgT... args);
  std::string* mutable_thing();
  PROTOBUF_NODISCARD std::string* release_thing();
  void set_allocated_thing(std::string* thing);
  private:
  const std::string& _internal_thing() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_thing(const std::string& value);
  std::string* _internal_mutable_thing();
  public:

  // string job_id = 2;
  void clear_job_id();
  const std::string& job_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_job_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_job_id();
  PROTOBUF_NODISCARD std::string* release_job_id();
  void set_allocated_job_id(std::string* job_id);
  private:
  const std::string& _internal_job_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_job_id(const std::string& value);
  std::string* _internal_mutable_job_id();
  public:

  // @@protoc_insertion_point(class_scope:duo.GetJobRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr thing_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr job_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_duo_2fduo_2eproto;
};
// -------------------------------------------------------------------

class GetUnfinishedJobsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:duo.GetUnfinishedJobsRequest) */ {
 public:
  inline GetUnfinishedJobsRequest() : GetUnfinishedJobsRequest(nullptr) {}
  ~GetUnfinishedJobsRequest() override;
  explicit PROTOBUF_CONSTEXPR GetUnfinishedJobsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetUnfinishedJobsRequest(const GetUnfinishedJobsRequest& from);
  GetUnfinishedJobsRequest(GetUnfinishedJobsRequest&& from) noexcept
    : GetUnfinishedJobsRequest() {
    *this = ::std::move(from);
  }

  inline GetUnfinishedJobsRequest& operator=(const GetUnfinishedJobsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetUnfinishedJobsRequest& operator=(GetUnfinishedJobsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetUnfinishedJobsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetUnfinishedJobsRequest* internal_default_instance() {
    return reinterpret_cast<const GetUnfinishedJobsRequest*>(
               &_GetUnfinishedJobsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(GetUnfinishedJobsRequest& a, GetUnfinishedJobsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetUnfinishedJobsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetUnfinishedJobsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetUnfinishedJobsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetUnfinishedJobsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetUnfinishedJobsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetUnfinishedJobsRequest& from) {
    GetUnfinishedJobsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetUnfinishedJobsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "duo.GetUnfinishedJobsRequest";
  }
  protected:
  explicit GetUnfinishedJobsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kThingFieldNumber = 1,
  };
  // string thing = 1;
  void clear_thing();
  const std::string& thing() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_thing(ArgT0&& arg0, ArgT... args);
  std::string* mutable_thing();
  PROTOBUF_NODISCARD std::string* release_thing();
  void set_allocated_thing(std::string* thing);
  private:
  const std::string& _internal_thing() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_thing(const std::string& value);
  std::string* _internal_mutable_thing();
  public:

  // @@protoc_insertion_point(class_scope:duo.GetUnfinishedJobsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr thing_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_duo_2fduo_2eproto;
};
// -------------------------------------------------------------------

class GetFinishedJobsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:duo.GetFinishedJobsRequest) */ {
 public:
  inline GetFinishedJobsRequest() : GetFinishedJobsRequest(nullptr) {}
  ~GetFinishedJobsRequest() override;
  explicit PROTOBUF_CONSTEXPR GetFinishedJobsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetFinishedJobsRequest(const GetFinishedJobsRequest& from);
  GetFinishedJobsRequest(GetFinishedJobsRequest&& from) noexcept
    : GetFinishedJobsRequest() {
    *this = ::std::move(from);
  }

  inline GetFinishedJobsRequest& operator=(const GetFinishedJobsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetFinishedJobsRequest& operator=(GetFinishedJobsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetFinishedJobsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetFinishedJobsRequest* internal_default_instance() {
    return reinterpret_cast<const GetFinishedJobsRequest*>(
               &_GetFinishedJobsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(GetFinishedJobsRequest& a, GetFinishedJobsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetFinishedJobsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetFinishedJobsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetFinishedJobsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetFinishedJobsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetFinishedJobsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetFinishedJobsRequest& from) {
    GetFinishedJobsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetFinishedJobsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "duo.GetFinishedJobsRequest";
  }
  protected:
  explicit GetFinishedJobsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kThingFieldNumber = 1,
  };
  // string thing = 1;
  void clear_thing();
  const std::string& thing() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_thing(ArgT0&& arg0, ArgT... args);
  std::string* mutable_thing();
  PROTOBUF_NODISCARD std::string* release_thing();
  void set_allocated_thing(std::string* thing);
  private:
  const std::string& _internal_thing() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_thing(const std::string& value);
  std::string* _internal_mutable_thing();
  public:

  // @@protoc_insertion_point(class_scope:duo.GetFinishedJobsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr thing_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_duo_2fduo_2eproto;
};
// -------------------------------------------------------------------

class CreateJobRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:duo.CreateJobRequest) */ {
 public:
  inline CreateJobRequest() : CreateJobRequest(nullptr) {}
  ~CreateJobRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateJobRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateJobRequest(const CreateJobRequest& from);
  CreateJobRequest(CreateJobRequest&& from) noexcept
    : CreateJobRequest() {
    *this = ::std::move(from);
  }

  inline CreateJobRequest& operator=(const CreateJobRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateJobRequest& operator=(CreateJobRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateJobRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateJobRequest* internal_default_instance() {
    return reinterpret_cast<const CreateJobRequest*>(
               &_CreateJobRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(CreateJobRequest& a, CreateJobRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateJobRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateJobRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateJobRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateJobRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateJobRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateJobRequest& from) {
    CreateJobRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateJobRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "duo.CreateJobRequest";
  }
  protected:
  explicit CreateJobRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kThingFieldNumber = 1,
    kDocumentFieldNumber = 2,
  };
  // string thing = 1;
  void clear_thing();
  const std::string& thing() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_thing(ArgT0&& arg0, ArgT... args);
  std::string* mutable_thing();
  PROTOBUF_NODISCARD std::string* release_thing();
  void set_allocated_thing(std::string* thing);
  private:
  const std::string& _internal_thing() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_thing(const std::string& value);
  std::string* _internal_mutable_thing();
  public:

  // .google.protobuf.Struct document = 2;
  bool has_document() const;
  private:
  bool _internal_has_document() const;
  public:
  void clear_document();
  const ::PROTOBUF_NAMESPACE_ID::Struct& document() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_document();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_document();
  void set_allocated_document(::PROTOBUF_NAMESPACE_ID::Struct* document);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_document() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_document();
  public:
  void unsafe_arena_set_allocated_document(
      ::PROTOBUF_NAMESPACE_ID::Struct* document);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_document();

  // @@protoc_insertion_point(class_scope:duo.CreateJobRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr thing_;
    ::PROTOBUF_NAMESPACE_ID::Struct* document_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_duo_2fduo_2eproto;
};
// -------------------------------------------------------------------

class UpdateJobRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:duo.UpdateJobRequest) */ {
 public:
  inline UpdateJobRequest() : UpdateJobRequest(nullptr) {}
  ~UpdateJobRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateJobRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateJobRequest(const UpdateJobRequest& from);
  UpdateJobRequest(UpdateJobRequest&& from) noexcept
    : UpdateJobRequest() {
    *this = ::std::move(from);
  }

  inline UpdateJobRequest& operator=(const UpdateJobRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateJobRequest& operator=(UpdateJobRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateJobRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateJobRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateJobRequest*>(
               &_UpdateJobRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(UpdateJobRequest& a, UpdateJobRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateJobRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateJobRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateJobRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateJobRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateJobRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateJobRequest& from) {
    UpdateJobRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateJobRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "duo.UpdateJobRequest";
  }
  protected:
  explicit UpdateJobRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kThingFieldNumber = 1,
    kJobIdFieldNumber = 2,
    kResponseFieldNumber = 5,
    kStatusFieldNumber = 3,
    kProgressFieldNumber = 4,
  };
  // string thing = 1;
  void clear_thing();
  const std::string& thing() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_thing(ArgT0&& arg0, ArgT... args);
  std::string* mutable_thing();
  PROTOBUF_NODISCARD std::string* release_thing();
  void set_allocated_thing(std::string* thing);
  private:
  const std::string& _internal_thing() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_thing(const std::string& value);
  std::string* _internal_mutable_thing();
  public:

  // string job_id = 2;
  void clear_job_id();
  const std::string& job_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_job_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_job_id();
  PROTOBUF_NODISCARD std::string* release_job_id();
  void set_allocated_job_id(std::string* job_id);
  private:
  const std::string& _internal_job_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_job_id(const std::string& value);
  std::string* _internal_mutable_job_id();
  public:

  // optional string response = 5;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const std::string& response() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_response(ArgT0&& arg0, ArgT... args);
  std::string* mutable_response();
  PROTOBUF_NODISCARD std::string* release_response();
  void set_allocated_response(std::string* response);
  private:
  const std::string& _internal_response() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_response(const std::string& value);
  std::string* _internal_mutable_response();
  public:

  // optional .duo.JobStatus status = 3;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::duo::JobStatus status() const;
  void set_status(::duo::JobStatus value);
  private:
  ::duo::JobStatus _internal_status() const;
  void _internal_set_status(::duo::JobStatus value);
  public:

  // optional uint32 progress = 4;
  bool has_progress() const;
  private:
  bool _internal_has_progress() const;
  public:
  void clear_progress();
  uint32_t progress() const;
  void set_progress(uint32_t value);
  private:
  uint32_t _internal_progress() const;
  void _internal_set_progress(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:duo.UpdateJobRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr thing_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr job_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr response_;
    int status_;
    uint32_t progress_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_duo_2fduo_2eproto;
};
// -------------------------------------------------------------------

class DeleteFinishedJobsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:duo.DeleteFinishedJobsRequest) */ {
 public:
  inline DeleteFinishedJobsRequest() : DeleteFinishedJobsRequest(nullptr) {}
  ~DeleteFinishedJobsRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteFinishedJobsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteFinishedJobsRequest(const DeleteFinishedJobsRequest& from);
  DeleteFinishedJobsRequest(DeleteFinishedJobsRequest&& from) noexcept
    : DeleteFinishedJobsRequest() {
    *this = ::std::move(from);
  }

  inline DeleteFinishedJobsRequest& operator=(const DeleteFinishedJobsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteFinishedJobsRequest& operator=(DeleteFinishedJobsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteFinishedJobsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteFinishedJobsRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteFinishedJobsRequest*>(
               &_DeleteFinishedJobsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(DeleteFinishedJobsRequest& a, DeleteFinishedJobsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteFinishedJobsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteFinishedJobsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteFinishedJobsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteFinishedJobsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteFinishedJobsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteFinishedJobsRequest& from) {
    DeleteFinishedJobsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteFinishedJobsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "duo.DeleteFinishedJobsRequest";
  }
  protected:
  explicit DeleteFinishedJobsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kThingFieldNumber = 1,
  };
  // string thing = 1;
  void clear_thing();
  const std::string& thing() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_thing(ArgT0&& arg0, ArgT... args);
  std::string* mutable_thing();
  PROTOBUF_NODISCARD std::string* release_thing();
  void set_allocated_thing(std::string* thing);
  private:
  const std::string& _internal_thing() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_thing(const std::string& value);
  std::string* _internal_mutable_thing();
  public:

  // @@protoc_insertion_point(class_scope:duo.DeleteFinishedJobsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr thing_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_duo_2fduo_2eproto;
};
// -------------------------------------------------------------------

class ListenNextJobArrivedRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:duo.ListenNextJobArrivedRequest) */ {
 public:
  inline ListenNextJobArrivedRequest() : ListenNextJobArrivedRequest(nullptr) {}
  ~ListenNextJobArrivedRequest() override;
  explicit PROTOBUF_CONSTEXPR ListenNextJobArrivedRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListenNextJobArrivedRequest(const ListenNextJobArrivedRequest& from);
  ListenNextJobArrivedRequest(ListenNextJobArrivedRequest&& from) noexcept
    : ListenNextJobArrivedRequest() {
    *this = ::std::move(from);
  }

  inline ListenNextJobArrivedRequest& operator=(const ListenNextJobArrivedRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListenNextJobArrivedRequest& operator=(ListenNextJobArrivedRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListenNextJobArrivedRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListenNextJobArrivedRequest* internal_default_instance() {
    return reinterpret_cast<const ListenNextJobArrivedRequest*>(
               &_ListenNextJobArrivedRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(ListenNextJobArrivedRequest& a, ListenNextJobArrivedRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListenNextJobArrivedRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListenNextJobArrivedRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListenNextJobArrivedRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListenNextJobArrivedRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListenNextJobArrivedRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListenNextJobArrivedRequest& from) {
    ListenNextJobArrivedRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListenNextJobArrivedRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "duo.ListenNextJobArrivedRequest";
  }
  protected:
  explicit ListenNextJobArrivedRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kThingFieldNumber = 1,
  };
  // string thing = 1;
  void clear_thing();
  const std::string& thing() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_thing(ArgT0&& arg0, ArgT... args);
  std::string* mutable_thing();
  PROTOBUF_NODISCARD std::string* release_thing();
  void set_allocated_thing(std::string* thing);
  private:
  const std::string& _internal_thing() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_thing(const std::string& value);
  std::string* _internal_mutable_thing();
  public:

  // @@protoc_insertion_point(class_scope:duo.ListenNextJobArrivedRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr thing_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_duo_2fduo_2eproto;
};
// -------------------------------------------------------------------

class ListenJobChangedRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:duo.ListenJobChangedRequest) */ {
 public:
  inline ListenJobChangedRequest() : ListenJobChangedRequest(nullptr) {}
  ~ListenJobChangedRequest() override;
  explicit PROTOBUF_CONSTEXPR ListenJobChangedRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListenJobChangedRequest(const ListenJobChangedRequest& from);
  ListenJobChangedRequest(ListenJobChangedRequest&& from) noexcept
    : ListenJobChangedRequest() {
    *this = ::std::move(from);
  }

  inline ListenJobChangedRequest& operator=(const ListenJobChangedRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListenJobChangedRequest& operator=(ListenJobChangedRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListenJobChangedRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListenJobChangedRequest* internal_default_instance() {
    return reinterpret_cast<const ListenJobChangedRequest*>(
               &_ListenJobChangedRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(ListenJobChangedRequest& a, ListenJobChangedRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListenJobChangedRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListenJobChangedRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListenJobChangedRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListenJobChangedRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListenJobChangedRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListenJobChangedRequest& from) {
    ListenJobChangedRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListenJobChangedRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "duo.ListenJobChangedRequest";
  }
  protected:
  explicit ListenJobChangedRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kThingFieldNumber = 1,
  };
  // string thing = 1;
  void clear_thing();
  const std::string& thing() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_thing(ArgT0&& arg0, ArgT... args);
  std::string* mutable_thing();
  PROTOBUF_NODISCARD std::string* release_thing();
  void set_allocated_thing(std::string* thing);
  private:
  const std::string& _internal_thing() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_thing(const std::string& value);
  std::string* _internal_mutable_thing();
  public:

  // @@protoc_insertion_point(class_scope:duo.ListenJobChangedRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr thing_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_duo_2fduo_2eproto;
};
// -------------------------------------------------------------------

class Job final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:duo.Job) */ {
 public:
  inline Job() : Job(nullptr) {}
  ~Job() override;
  explicit PROTOBUF_CONSTEXPR Job(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Job(const Job& from);
  Job(Job&& from) noexcept
    : Job() {
    *this = ::std::move(from);
  }

  inline Job& operator=(const Job& from) {
    CopyFrom(from);
    return *this;
  }
  inline Job& operator=(Job&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Job& default_instance() {
    return *internal_default_instance();
  }
  static inline const Job* internal_default_instance() {
    return reinterpret_cast<const Job*>(
               &_Job_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(Job& a, Job& b) {
    a.Swap(&b);
  }
  inline void Swap(Job* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Job* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Job* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Job>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Job& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Job& from) {
    Job::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Job* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "duo.Job";
  }
  protected:
  explicit Job(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJobIdFieldNumber = 1,
    kResponseFieldNumber = 6,
    kDocumentFieldNumber = 7,
    kStatusFieldNumber = 2,
    kProgressFieldNumber = 3,
    kQueuedAtFieldNumber = 4,
    kLastUpdatedAtFieldNumber = 5,
  };
  // string job_id = 1;
  void clear_job_id();
  const std::string& job_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_job_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_job_id();
  PROTOBUF_NODISCARD std::string* release_job_id();
  void set_allocated_job_id(std::string* job_id);
  private:
  const std::string& _internal_job_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_job_id(const std::string& value);
  std::string* _internal_mutable_job_id();
  public:

  // string response = 6;
  void clear_response();
  const std::string& response() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_response(ArgT0&& arg0, ArgT... args);
  std::string* mutable_response();
  PROTOBUF_NODISCARD std::string* release_response();
  void set_allocated_response(std::string* response);
  private:
  const std::string& _internal_response() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_response(const std::string& value);
  std::string* _internal_mutable_response();
  public:

  // .google.protobuf.Struct document = 7;
  bool has_document() const;
  private:
  bool _internal_has_document() const;
  public:
  void clear_document();
  const ::PROTOBUF_NAMESPACE_ID::Struct& document() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_document();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_document();
  void set_allocated_document(::PROTOBUF_NAMESPACE_ID::Struct* document);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_document() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_document();
  public:
  void unsafe_arena_set_allocated_document(
      ::PROTOBUF_NAMESPACE_ID::Struct* document);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_document();

  // .duo.JobStatus status = 2;
  void clear_status();
  ::duo::JobStatus status() const;
  void set_status(::duo::JobStatus value);
  private:
  ::duo::JobStatus _internal_status() const;
  void _internal_set_status(::duo::JobStatus value);
  public:

  // uint32 progress = 3;
  void clear_progress();
  uint32_t progress() const;
  void set_progress(uint32_t value);
  private:
  uint32_t _internal_progress() const;
  void _internal_set_progress(uint32_t value);
  public:

  // uint64 queuedAt = 4;
  void clear_queuedat();
  uint64_t queuedat() const;
  void set_queuedat(uint64_t value);
  private:
  uint64_t _internal_queuedat() const;
  void _internal_set_queuedat(uint64_t value);
  public:

  // uint64 lastUpdatedAt = 5;
  void clear_lastupdatedat();
  uint64_t lastupdatedat() const;
  void set_lastupdatedat(uint64_t value);
  private:
  uint64_t _internal_lastupdatedat() const;
  void _internal_set_lastupdatedat(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:duo.Job)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr job_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr response_;
    ::PROTOBUF_NAMESPACE_ID::Struct* document_;
    int status_;
    uint32_t progress_;
    uint64_t queuedat_;
    uint64_t lastupdatedat_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_duo_2fduo_2eproto;
};
// -------------------------------------------------------------------

class GetJobResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:duo.GetJobResponse) */ {
 public:
  inline GetJobResponse() : GetJobResponse(nullptr) {}
  ~GetJobResponse() override;
  explicit PROTOBUF_CONSTEXPR GetJobResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetJobResponse(const GetJobResponse& from);
  GetJobResponse(GetJobResponse&& from) noexcept
    : GetJobResponse() {
    *this = ::std::move(from);
  }

  inline GetJobResponse& operator=(const GetJobResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetJobResponse& operator=(GetJobResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetJobResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetJobResponse* internal_default_instance() {
    return reinterpret_cast<const GetJobResponse*>(
               &_GetJobResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(GetJobResponse& a, GetJobResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetJobResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetJobResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetJobResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetJobResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetJobResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetJobResponse& from) {
    GetJobResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetJobResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "duo.GetJobResponse";
  }
  protected:
  explicit GetJobResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestIdFieldNumber = 2,
    kJobFieldNumber = 3,
    kCodeFieldNumber = 1,
  };
  // string request_id = 2;
  void clear_request_id();
  const std::string& request_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_request_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_request_id();
  PROTOBUF_NODISCARD std::string* release_request_id();
  void set_allocated_request_id(std::string* request_id);
  private:
  const std::string& _internal_request_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_request_id(const std::string& value);
  std::string* _internal_mutable_request_id();
  public:

  // optional .duo.Job job = 3;
  bool has_job() const;
  private:
  bool _internal_has_job() const;
  public:
  void clear_job();
  const ::duo::Job& job() const;
  PROTOBUF_NODISCARD ::duo::Job* release_job();
  ::duo::Job* mutable_job();
  void set_allocated_job(::duo::Job* job);
  private:
  const ::duo::Job& _internal_job() const;
  ::duo::Job* _internal_mutable_job();
  public:
  void unsafe_arena_set_allocated_job(
      ::duo::Job* job);
  ::duo::Job* unsafe_arena_release_job();

  // .duo.StatusCode code = 1;
  void clear_code();
  ::duo::StatusCode code() const;
  void set_code(::duo::StatusCode value);
  private:
  ::duo::StatusCode _internal_code() const;
  void _internal_set_code(::duo::StatusCode value);
  public:

  // @@protoc_insertion_point(class_scope:duo.GetJobResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr request_id_;
    ::duo::Job* job_;
    int code_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_duo_2fduo_2eproto;
};
// -------------------------------------------------------------------

class GetJobsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:duo.GetJobsResponse) */ {
 public:
  inline GetJobsResponse() : GetJobsResponse(nullptr) {}
  ~GetJobsResponse() override;
  explicit PROTOBUF_CONSTEXPR GetJobsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetJobsResponse(const GetJobsResponse& from);
  GetJobsResponse(GetJobsResponse&& from) noexcept
    : GetJobsResponse() {
    *this = ::std::move(from);
  }

  inline GetJobsResponse& operator=(const GetJobsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetJobsResponse& operator=(GetJobsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetJobsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetJobsResponse* internal_default_instance() {
    return reinterpret_cast<const GetJobsResponse*>(
               &_GetJobsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(GetJobsResponse& a, GetJobsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetJobsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetJobsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetJobsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetJobsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetJobsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetJobsResponse& from) {
    GetJobsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetJobsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "duo.GetJobsResponse";
  }
  protected:
  explicit GetJobsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJobsFieldNumber = 3,
    kRequestIdFieldNumber = 2,
    kCodeFieldNumber = 1,
  };
  // repeated .duo.Job jobs = 3;
  int jobs_size() const;
  private:
  int _internal_jobs_size() const;
  public:
  void clear_jobs();
  ::duo::Job* mutable_jobs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::duo::Job >*
      mutable_jobs();
  private:
  const ::duo::Job& _internal_jobs(int index) const;
  ::duo::Job* _internal_add_jobs();
  public:
  const ::duo::Job& jobs(int index) const;
  ::duo::Job* add_jobs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::duo::Job >&
      jobs() const;

  // string request_id = 2;
  void clear_request_id();
  const std::string& request_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_request_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_request_id();
  PROTOBUF_NODISCARD std::string* release_request_id();
  void set_allocated_request_id(std::string* request_id);
  private:
  const std::string& _internal_request_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_request_id(const std::string& value);
  std::string* _internal_mutable_request_id();
  public:

  // .duo.StatusCode code = 1;
  void clear_code();
  ::duo::StatusCode code() const;
  void set_code(::duo::StatusCode value);
  private:
  ::duo::StatusCode _internal_code() const;
  void _internal_set_code(::duo::StatusCode value);
  public:

  // @@protoc_insertion_point(class_scope:duo.GetJobsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::duo::Job > jobs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr request_id_;
    int code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_duo_2fduo_2eproto;
};
// -------------------------------------------------------------------

class CreateJobResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:duo.CreateJobResponse) */ {
 public:
  inline CreateJobResponse() : CreateJobResponse(nullptr) {}
  ~CreateJobResponse() override;
  explicit PROTOBUF_CONSTEXPR CreateJobResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateJobResponse(const CreateJobResponse& from);
  CreateJobResponse(CreateJobResponse&& from) noexcept
    : CreateJobResponse() {
    *this = ::std::move(from);
  }

  inline CreateJobResponse& operator=(const CreateJobResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateJobResponse& operator=(CreateJobResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateJobResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateJobResponse* internal_default_instance() {
    return reinterpret_cast<const CreateJobResponse*>(
               &_CreateJobResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(CreateJobResponse& a, CreateJobResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateJobResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateJobResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateJobResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateJobResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateJobResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateJobResponse& from) {
    CreateJobResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateJobResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "duo.CreateJobResponse";
  }
  protected:
  explicit CreateJobResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestIdFieldNumber = 2,
    kMessageFieldNumber = 3,
    kJobIdFieldNumber = 4,
    kCodeFieldNumber = 1,
  };
  // string request_id = 2;
  void clear_request_id();
  const std::string& request_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_request_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_request_id();
  PROTOBUF_NODISCARD std::string* release_request_id();
  void set_allocated_request_id(std::string* request_id);
  private:
  const std::string& _internal_request_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_request_id(const std::string& value);
  std::string* _internal_mutable_request_id();
  public:

  // string message = 3;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // string job_id = 4;
  void clear_job_id();
  const std::string& job_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_job_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_job_id();
  PROTOBUF_NODISCARD std::string* release_job_id();
  void set_allocated_job_id(std::string* job_id);
  private:
  const std::string& _internal_job_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_job_id(const std::string& value);
  std::string* _internal_mutable_job_id();
  public:

  // .duo.StatusCode code = 1;
  void clear_code();
  ::duo::StatusCode code() const;
  void set_code(::duo::StatusCode value);
  private:
  ::duo::StatusCode _internal_code() const;
  void _internal_set_code(::duo::StatusCode value);
  public:

  // @@protoc_insertion_point(class_scope:duo.CreateJobResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr request_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr job_id_;
    int code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_duo_2fduo_2eproto;
};
// -------------------------------------------------------------------

class UpdateJobResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:duo.UpdateJobResponse) */ {
 public:
  inline UpdateJobResponse() : UpdateJobResponse(nullptr) {}
  ~UpdateJobResponse() override;
  explicit PROTOBUF_CONSTEXPR UpdateJobResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateJobResponse(const UpdateJobResponse& from);
  UpdateJobResponse(UpdateJobResponse&& from) noexcept
    : UpdateJobResponse() {
    *this = ::std::move(from);
  }

  inline UpdateJobResponse& operator=(const UpdateJobResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateJobResponse& operator=(UpdateJobResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateJobResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateJobResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateJobResponse*>(
               &_UpdateJobResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(UpdateJobResponse& a, UpdateJobResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateJobResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateJobResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateJobResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateJobResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateJobResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateJobResponse& from) {
    UpdateJobResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateJobResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "duo.UpdateJobResponse";
  }
  protected:
  explicit UpdateJobResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestIdFieldNumber = 2,
    kMessageFieldNumber = 3,
    kCodeFieldNumber = 1,
  };
  // string request_id = 2;
  void clear_request_id();
  const std::string& request_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_request_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_request_id();
  PROTOBUF_NODISCARD std::string* release_request_id();
  void set_allocated_request_id(std::string* request_id);
  private:
  const std::string& _internal_request_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_request_id(const std::string& value);
  std::string* _internal_mutable_request_id();
  public:

  // string message = 3;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .duo.StatusCode code = 1;
  void clear_code();
  ::duo::StatusCode code() const;
  void set_code(::duo::StatusCode value);
  private:
  ::duo::StatusCode _internal_code() const;
  void _internal_set_code(::duo::StatusCode value);
  public:

  // @@protoc_insertion_point(class_scope:duo.UpdateJobResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr request_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    int code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_duo_2fduo_2eproto;
};
// -------------------------------------------------------------------

class JobDeleteResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:duo.JobDeleteResponse) */ {
 public:
  inline JobDeleteResponse() : JobDeleteResponse(nullptr) {}
  ~JobDeleteResponse() override;
  explicit PROTOBUF_CONSTEXPR JobDeleteResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JobDeleteResponse(const JobDeleteResponse& from);
  JobDeleteResponse(JobDeleteResponse&& from) noexcept
    : JobDeleteResponse() {
    *this = ::std::move(from);
  }

  inline JobDeleteResponse& operator=(const JobDeleteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline JobDeleteResponse& operator=(JobDeleteResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JobDeleteResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const JobDeleteResponse* internal_default_instance() {
    return reinterpret_cast<const JobDeleteResponse*>(
               &_JobDeleteResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(JobDeleteResponse& a, JobDeleteResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(JobDeleteResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JobDeleteResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JobDeleteResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JobDeleteResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JobDeleteResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const JobDeleteResponse& from) {
    JobDeleteResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JobDeleteResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "duo.JobDeleteResponse";
  }
  protected:
  explicit JobDeleteResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestIdFieldNumber = 2,
    kMessageFieldNumber = 3,
    kCodeFieldNumber = 1,
  };
  // string request_id = 2;
  void clear_request_id();
  const std::string& request_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_request_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_request_id();
  PROTOBUF_NODISCARD std::string* release_request_id();
  void set_allocated_request_id(std::string* request_id);
  private:
  const std::string& _internal_request_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_request_id(const std::string& value);
  std::string* _internal_mutable_request_id();
  public:

  // string message = 3;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .duo.StatusCode code = 1;
  void clear_code();
  ::duo::StatusCode code() const;
  void set_code(::duo::StatusCode value);
  private:
  ::duo::StatusCode _internal_code() const;
  void _internal_set_code(::duo::StatusCode value);
  public:

  // @@protoc_insertion_point(class_scope:duo.JobDeleteResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr request_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    int code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_duo_2fduo_2eproto;
};
// -------------------------------------------------------------------

class ListenNextJobArrivedResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:duo.ListenNextJobArrivedResponse) */ {
 public:
  inline ListenNextJobArrivedResponse() : ListenNextJobArrivedResponse(nullptr) {}
  ~ListenNextJobArrivedResponse() override;
  explicit PROTOBUF_CONSTEXPR ListenNextJobArrivedResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListenNextJobArrivedResponse(const ListenNextJobArrivedResponse& from);
  ListenNextJobArrivedResponse(ListenNextJobArrivedResponse&& from) noexcept
    : ListenNextJobArrivedResponse() {
    *this = ::std::move(from);
  }

  inline ListenNextJobArrivedResponse& operator=(const ListenNextJobArrivedResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListenNextJobArrivedResponse& operator=(ListenNextJobArrivedResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListenNextJobArrivedResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListenNextJobArrivedResponse* internal_default_instance() {
    return reinterpret_cast<const ListenNextJobArrivedResponse*>(
               &_ListenNextJobArrivedResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(ListenNextJobArrivedResponse& a, ListenNextJobArrivedResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListenNextJobArrivedResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListenNextJobArrivedResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListenNextJobArrivedResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListenNextJobArrivedResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListenNextJobArrivedResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListenNextJobArrivedResponse& from) {
    ListenNextJobArrivedResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListenNextJobArrivedResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "duo.ListenNextJobArrivedResponse";
  }
  protected:
  explicit ListenNextJobArrivedResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJobFieldNumber = 1,
  };
  // optional .duo.Job job = 1;
  bool has_job() const;
  private:
  bool _internal_has_job() const;
  public:
  void clear_job();
  const ::duo::Job& job() const;
  PROTOBUF_NODISCARD ::duo::Job* release_job();
  ::duo::Job* mutable_job();
  void set_allocated_job(::duo::Job* job);
  private:
  const ::duo::Job& _internal_job() const;
  ::duo::Job* _internal_mutable_job();
  public:
  void unsafe_arena_set_allocated_job(
      ::duo::Job* job);
  ::duo::Job* unsafe_arena_release_job();

  // @@protoc_insertion_point(class_scope:duo.ListenNextJobArrivedResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::duo::Job* job_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_duo_2fduo_2eproto;
};
// -------------------------------------------------------------------

class JobCreateion final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:duo.JobCreateion) */ {
 public:
  inline JobCreateion() : JobCreateion(nullptr) {}
  ~JobCreateion() override;
  explicit PROTOBUF_CONSTEXPR JobCreateion(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JobCreateion(const JobCreateion& from);
  JobCreateion(JobCreateion&& from) noexcept
    : JobCreateion() {
    *this = ::std::move(from);
  }

  inline JobCreateion& operator=(const JobCreateion& from) {
    CopyFrom(from);
    return *this;
  }
  inline JobCreateion& operator=(JobCreateion&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JobCreateion& default_instance() {
    return *internal_default_instance();
  }
  static inline const JobCreateion* internal_default_instance() {
    return reinterpret_cast<const JobCreateion*>(
               &_JobCreateion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(JobCreateion& a, JobCreateion& b) {
    a.Swap(&b);
  }
  inline void Swap(JobCreateion* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JobCreateion* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JobCreateion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JobCreateion>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JobCreateion& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const JobCreateion& from) {
    JobCreateion::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JobCreateion* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "duo.JobCreateion";
  }
  protected:
  explicit JobCreateion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJobIdFieldNumber = 1,
    kDocumentFieldNumber = 2,
  };
  // string job_id = 1;
  void clear_job_id();
  const std::string& job_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_job_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_job_id();
  PROTOBUF_NODISCARD std::string* release_job_id();
  void set_allocated_job_id(std::string* job_id);
  private:
  const std::string& _internal_job_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_job_id(const std::string& value);
  std::string* _internal_mutable_job_id();
  public:

  // .google.protobuf.Struct document = 2;
  bool has_document() const;
  private:
  bool _internal_has_document() const;
  public:
  void clear_document();
  const ::PROTOBUF_NAMESPACE_ID::Struct& document() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_document();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_document();
  void set_allocated_document(::PROTOBUF_NAMESPACE_ID::Struct* document);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_document() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_document();
  public:
  void unsafe_arena_set_allocated_document(
      ::PROTOBUF_NAMESPACE_ID::Struct* document);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_document();

  // @@protoc_insertion_point(class_scope:duo.JobCreateion)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr job_id_;
    ::PROTOBUF_NAMESPACE_ID::Struct* document_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_duo_2fduo_2eproto;
};
// -------------------------------------------------------------------

class JobModification final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:duo.JobModification) */ {
 public:
  inline JobModification() : JobModification(nullptr) {}
  ~JobModification() override;
  explicit PROTOBUF_CONSTEXPR JobModification(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JobModification(const JobModification& from);
  JobModification(JobModification&& from) noexcept
    : JobModification() {
    *this = ::std::move(from);
  }

  inline JobModification& operator=(const JobModification& from) {
    CopyFrom(from);
    return *this;
  }
  inline JobModification& operator=(JobModification&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JobModification& default_instance() {
    return *internal_default_instance();
  }
  static inline const JobModification* internal_default_instance() {
    return reinterpret_cast<const JobModification*>(
               &_JobModification_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(JobModification& a, JobModification& b) {
    a.Swap(&b);
  }
  inline void Swap(JobModification* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JobModification* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JobModification* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JobModification>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JobModification& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const JobModification& from) {
    JobModification::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JobModification* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "duo.JobModification";
  }
  protected:
  explicit JobModification(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJobIdFieldNumber = 1,
    kResponseFieldNumber = 4,
    kStatusFieldNumber = 2,
    kProgressFieldNumber = 3,
  };
  // string job_id = 1;
  void clear_job_id();
  const std::string& job_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_job_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_job_id();
  PROTOBUF_NODISCARD std::string* release_job_id();
  void set_allocated_job_id(std::string* job_id);
  private:
  const std::string& _internal_job_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_job_id(const std::string& value);
  std::string* _internal_mutable_job_id();
  public:

  // optional string response = 4;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const std::string& response() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_response(ArgT0&& arg0, ArgT... args);
  std::string* mutable_response();
  PROTOBUF_NODISCARD std::string* release_response();
  void set_allocated_response(std::string* response);
  private:
  const std::string& _internal_response() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_response(const std::string& value);
  std::string* _internal_mutable_response();
  public:

  // optional .duo.JobStatus status = 2;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::duo::JobStatus status() const;
  void set_status(::duo::JobStatus value);
  private:
  ::duo::JobStatus _internal_status() const;
  void _internal_set_status(::duo::JobStatus value);
  public:

  // optional uint32 progress = 3;
  bool has_progress() const;
  private:
  bool _internal_has_progress() const;
  public:
  void clear_progress();
  uint32_t progress() const;
  void set_progress(uint32_t value);
  private:
  uint32_t _internal_progress() const;
  void _internal_set_progress(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:duo.JobModification)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr job_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr response_;
    int status_;
    uint32_t progress_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_duo_2fduo_2eproto;
};
// -------------------------------------------------------------------

class JobListenEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:duo.JobListenEvent) */ {
 public:
  inline JobListenEvent() : JobListenEvent(nullptr) {}
  ~JobListenEvent() override;
  explicit PROTOBUF_CONSTEXPR JobListenEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JobListenEvent(const JobListenEvent& from);
  JobListenEvent(JobListenEvent&& from) noexcept
    : JobListenEvent() {
    *this = ::std::move(from);
  }

  inline JobListenEvent& operator=(const JobListenEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline JobListenEvent& operator=(JobListenEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JobListenEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const JobListenEvent* internal_default_instance() {
    return reinterpret_cast<const JobListenEvent*>(
               &_JobListenEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(JobListenEvent& a, JobListenEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(JobListenEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JobListenEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JobListenEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JobListenEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JobListenEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const JobListenEvent& from) {
    JobListenEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JobListenEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "duo.JobListenEvent";
  }
  protected:
  explicit JobListenEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConnectedFieldNumber = 1,
  };
  // bool connected = 1;
  void clear_connected();
  bool connected() const;
  void set_connected(bool value);
  private:
  bool _internal_connected() const;
  void _internal_set_connected(bool value);
  public:

  // @@protoc_insertion_point(class_scope:duo.JobListenEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool connected_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_duo_2fduo_2eproto;
};
// -------------------------------------------------------------------

class ListenJobChangedResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:duo.ListenJobChangedResponse) */ {
 public:
  inline ListenJobChangedResponse() : ListenJobChangedResponse(nullptr) {}
  ~ListenJobChangedResponse() override;
  explicit PROTOBUF_CONSTEXPR ListenJobChangedResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListenJobChangedResponse(const ListenJobChangedResponse& from);
  ListenJobChangedResponse(ListenJobChangedResponse&& from) noexcept
    : ListenJobChangedResponse() {
    *this = ::std::move(from);
  }

  inline ListenJobChangedResponse& operator=(const ListenJobChangedResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListenJobChangedResponse& operator=(ListenJobChangedResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListenJobChangedResponse& default_instance() {
    return *internal_default_instance();
  }
  enum ChangeCase {
    kJobCreation = 1,
    kJobModification = 2,
    kJobEvent = 3,
    CHANGE_NOT_SET = 0,
  };

  static inline const ListenJobChangedResponse* internal_default_instance() {
    return reinterpret_cast<const ListenJobChangedResponse*>(
               &_ListenJobChangedResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(ListenJobChangedResponse& a, ListenJobChangedResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListenJobChangedResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListenJobChangedResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListenJobChangedResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListenJobChangedResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListenJobChangedResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListenJobChangedResponse& from) {
    ListenJobChangedResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListenJobChangedResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "duo.ListenJobChangedResponse";
  }
  protected:
  explicit ListenJobChangedResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJobCreationFieldNumber = 1,
    kJobModificationFieldNumber = 2,
    kJobEventFieldNumber = 3,
  };
  // .duo.JobCreateion job_creation = 1;
  bool has_job_creation() const;
  private:
  bool _internal_has_job_creation() const;
  public:
  void clear_job_creation();
  const ::duo::JobCreateion& job_creation() const;
  PROTOBUF_NODISCARD ::duo::JobCreateion* release_job_creation();
  ::duo::JobCreateion* mutable_job_creation();
  void set_allocated_job_creation(::duo::JobCreateion* job_creation);
  private:
  const ::duo::JobCreateion& _internal_job_creation() const;
  ::duo::JobCreateion* _internal_mutable_job_creation();
  public:
  void unsafe_arena_set_allocated_job_creation(
      ::duo::JobCreateion* job_creation);
  ::duo::JobCreateion* unsafe_arena_release_job_creation();

  // .duo.JobModification job_modification = 2;
  bool has_job_modification() const;
  private:
  bool _internal_has_job_modification() const;
  public:
  void clear_job_modification();
  const ::duo::JobModification& job_modification() const;
  PROTOBUF_NODISCARD ::duo::JobModification* release_job_modification();
  ::duo::JobModification* mutable_job_modification();
  void set_allocated_job_modification(::duo::JobModification* job_modification);
  private:
  const ::duo::JobModification& _internal_job_modification() const;
  ::duo::JobModification* _internal_mutable_job_modification();
  public:
  void unsafe_arena_set_allocated_job_modification(
      ::duo::JobModification* job_modification);
  ::duo::JobModification* unsafe_arena_release_job_modification();

  // .duo.JobListenEvent job_event = 3;
  bool has_job_event() const;
  private:
  bool _internal_has_job_event() const;
  public:
  void clear_job_event();
  const ::duo::JobListenEvent& job_event() const;
  PROTOBUF_NODISCARD ::duo::JobListenEvent* release_job_event();
  ::duo::JobListenEvent* mutable_job_event();
  void set_allocated_job_event(::duo::JobListenEvent* job_event);
  private:
  const ::duo::JobListenEvent& _internal_job_event() const;
  ::duo::JobListenEvent* _internal_mutable_job_event();
  public:
  void unsafe_arena_set_allocated_job_event(
      ::duo::JobListenEvent* job_event);
  ::duo::JobListenEvent* unsafe_arena_release_job_event();

  void clear_change();
  ChangeCase change_case() const;
  // @@protoc_insertion_point(class_scope:duo.ListenJobChangedResponse)
 private:
  class _Internal;
  void set_has_job_creation();
  void set_has_job_modification();
  void set_has_job_event();

  inline bool has_change() const;
  inline void clear_has_change();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ChangeUnion {
      constexpr ChangeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::duo::JobCreateion* job_creation_;
      ::duo::JobModification* job_modification_;
      ::duo::JobListenEvent* job_event_;
    } change_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_duo_2fduo_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// GetReportRequest

// string thing = 1;
inline void GetReportRequest::clear_thing() {
  _impl_.thing_.ClearToEmpty();
}
inline const std::string& GetReportRequest::thing() const {
  // @@protoc_insertion_point(field_get:duo.GetReportRequest.thing)
  return _internal_thing();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetReportRequest::set_thing(ArgT0&& arg0, ArgT... args) {
 
 _impl_.thing_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:duo.GetReportRequest.thing)
}
inline std::string* GetReportRequest::mutable_thing() {
  std::string* _s = _internal_mutable_thing();
  // @@protoc_insertion_point(field_mutable:duo.GetReportRequest.thing)
  return _s;
}
inline const std::string& GetReportRequest::_internal_thing() const {
  return _impl_.thing_.Get();
}
inline void GetReportRequest::_internal_set_thing(const std::string& value) {
  
  _impl_.thing_.Set(value, GetArenaForAllocation());
}
inline std::string* GetReportRequest::_internal_mutable_thing() {
  
  return _impl_.thing_.Mutable(GetArenaForAllocation());
}
inline std::string* GetReportRequest::release_thing() {
  // @@protoc_insertion_point(field_release:duo.GetReportRequest.thing)
  return _impl_.thing_.Release();
}
inline void GetReportRequest::set_allocated_thing(std::string* thing) {
  if (thing != nullptr) {
    
  } else {
    
  }
  _impl_.thing_.SetAllocated(thing, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.thing_.IsDefault()) {
    _impl_.thing_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:duo.GetReportRequest.thing)
}

// optional string path = 2;
inline bool GetReportRequest::_internal_has_path() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GetReportRequest::has_path() const {
  return _internal_has_path();
}
inline void GetReportRequest::clear_path() {
  _impl_.path_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GetReportRequest::path() const {
  // @@protoc_insertion_point(field_get:duo.GetReportRequest.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetReportRequest::set_path(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:duo.GetReportRequest.path)
}
inline std::string* GetReportRequest::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:duo.GetReportRequest.path)
  return _s;
}
inline const std::string& GetReportRequest::_internal_path() const {
  return _impl_.path_.Get();
}
inline void GetReportRequest::_internal_set_path(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* GetReportRequest::_internal_mutable_path() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.path_.Mutable(GetArenaForAllocation());
}
inline std::string* GetReportRequest::release_path() {
  // @@protoc_insertion_point(field_release:duo.GetReportRequest.path)
  if (!_internal_has_path()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.path_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GetReportRequest::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:duo.GetReportRequest.path)
}

// repeated string filters = 3;
inline int GetReportRequest::_internal_filters_size() const {
  return _impl_.filters_.size();
}
inline int GetReportRequest::filters_size() const {
  return _internal_filters_size();
}
inline void GetReportRequest::clear_filters() {
  _impl_.filters_.Clear();
}
inline std::string* GetReportRequest::add_filters() {
  std::string* _s = _internal_add_filters();
  // @@protoc_insertion_point(field_add_mutable:duo.GetReportRequest.filters)
  return _s;
}
inline const std::string& GetReportRequest::_internal_filters(int index) const {
  return _impl_.filters_.Get(index);
}
inline const std::string& GetReportRequest::filters(int index) const {
  // @@protoc_insertion_point(field_get:duo.GetReportRequest.filters)
  return _internal_filters(index);
}
inline std::string* GetReportRequest::mutable_filters(int index) {
  // @@protoc_insertion_point(field_mutable:duo.GetReportRequest.filters)
  return _impl_.filters_.Mutable(index);
}
inline void GetReportRequest::set_filters(int index, const std::string& value) {
  _impl_.filters_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:duo.GetReportRequest.filters)
}
inline void GetReportRequest::set_filters(int index, std::string&& value) {
  _impl_.filters_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:duo.GetReportRequest.filters)
}
inline void GetReportRequest::set_filters(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.filters_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:duo.GetReportRequest.filters)
}
inline void GetReportRequest::set_filters(int index, const char* value, size_t size) {
  _impl_.filters_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:duo.GetReportRequest.filters)
}
inline std::string* GetReportRequest::_internal_add_filters() {
  return _impl_.filters_.Add();
}
inline void GetReportRequest::add_filters(const std::string& value) {
  _impl_.filters_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:duo.GetReportRequest.filters)
}
inline void GetReportRequest::add_filters(std::string&& value) {
  _impl_.filters_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:duo.GetReportRequest.filters)
}
inline void GetReportRequest::add_filters(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.filters_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:duo.GetReportRequest.filters)
}
inline void GetReportRequest::add_filters(const char* value, size_t size) {
  _impl_.filters_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:duo.GetReportRequest.filters)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetReportRequest::filters() const {
  // @@protoc_insertion_point(field_list:duo.GetReportRequest.filters)
  return _impl_.filters_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetReportRequest::mutable_filters() {
  // @@protoc_insertion_point(field_mutable_list:duo.GetReportRequest.filters)
  return &_impl_.filters_;
}

// -------------------------------------------------------------------

// GetDesireRequest

// string thing = 1;
inline void GetDesireRequest::clear_thing() {
  _impl_.thing_.ClearToEmpty();
}
inline const std::string& GetDesireRequest::thing() const {
  // @@protoc_insertion_point(field_get:duo.GetDesireRequest.thing)
  return _internal_thing();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetDesireRequest::set_thing(ArgT0&& arg0, ArgT... args) {
 
 _impl_.thing_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:duo.GetDesireRequest.thing)
}
inline std::string* GetDesireRequest::mutable_thing() {
  std::string* _s = _internal_mutable_thing();
  // @@protoc_insertion_point(field_mutable:duo.GetDesireRequest.thing)
  return _s;
}
inline const std::string& GetDesireRequest::_internal_thing() const {
  return _impl_.thing_.Get();
}
inline void GetDesireRequest::_internal_set_thing(const std::string& value) {
  
  _impl_.thing_.Set(value, GetArenaForAllocation());
}
inline std::string* GetDesireRequest::_internal_mutable_thing() {
  
  return _impl_.thing_.Mutable(GetArenaForAllocation());
}
inline std::string* GetDesireRequest::release_thing() {
  // @@protoc_insertion_point(field_release:duo.GetDesireRequest.thing)
  return _impl_.thing_.Release();
}
inline void GetDesireRequest::set_allocated_thing(std::string* thing) {
  if (thing != nullptr) {
    
  } else {
    
  }
  _impl_.thing_.SetAllocated(thing, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.thing_.IsDefault()) {
    _impl_.thing_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:duo.GetDesireRequest.thing)
}

// optional string path = 2;
inline bool GetDesireRequest::_internal_has_path() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GetDesireRequest::has_path() const {
  return _internal_has_path();
}
inline void GetDesireRequest::clear_path() {
  _impl_.path_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GetDesireRequest::path() const {
  // @@protoc_insertion_point(field_get:duo.GetDesireRequest.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetDesireRequest::set_path(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:duo.GetDesireRequest.path)
}
inline std::string* GetDesireRequest::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:duo.GetDesireRequest.path)
  return _s;
}
inline const std::string& GetDesireRequest::_internal_path() const {
  return _impl_.path_.Get();
}
inline void GetDesireRequest::_internal_set_path(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* GetDesireRequest::_internal_mutable_path() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.path_.Mutable(GetArenaForAllocation());
}
inline std::string* GetDesireRequest::release_path() {
  // @@protoc_insertion_point(field_release:duo.GetDesireRequest.path)
  if (!_internal_has_path()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.path_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GetDesireRequest::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:duo.GetDesireRequest.path)
}

// repeated string filters = 3;
inline int GetDesireRequest::_internal_filters_size() const {
  return _impl_.filters_.size();
}
inline int GetDesireRequest::filters_size() const {
  return _internal_filters_size();
}
inline void GetDesireRequest::clear_filters() {
  _impl_.filters_.Clear();
}
inline std::string* GetDesireRequest::add_filters() {
  std::string* _s = _internal_add_filters();
  // @@protoc_insertion_point(field_add_mutable:duo.GetDesireRequest.filters)
  return _s;
}
inline const std::string& GetDesireRequest::_internal_filters(int index) const {
  return _impl_.filters_.Get(index);
}
inline const std::string& GetDesireRequest::filters(int index) const {
  // @@protoc_insertion_point(field_get:duo.GetDesireRequest.filters)
  return _internal_filters(index);
}
inline std::string* GetDesireRequest::mutable_filters(int index) {
  // @@protoc_insertion_point(field_mutable:duo.GetDesireRequest.filters)
  return _impl_.filters_.Mutable(index);
}
inline void GetDesireRequest::set_filters(int index, const std::string& value) {
  _impl_.filters_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:duo.GetDesireRequest.filters)
}
inline void GetDesireRequest::set_filters(int index, std::string&& value) {
  _impl_.filters_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:duo.GetDesireRequest.filters)
}
inline void GetDesireRequest::set_filters(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.filters_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:duo.GetDesireRequest.filters)
}
inline void GetDesireRequest::set_filters(int index, const char* value, size_t size) {
  _impl_.filters_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:duo.GetDesireRequest.filters)
}
inline std::string* GetDesireRequest::_internal_add_filters() {
  return _impl_.filters_.Add();
}
inline void GetDesireRequest::add_filters(const std::string& value) {
  _impl_.filters_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:duo.GetDesireRequest.filters)
}
inline void GetDesireRequest::add_filters(std::string&& value) {
  _impl_.filters_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:duo.GetDesireRequest.filters)
}
inline void GetDesireRequest::add_filters(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.filters_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:duo.GetDesireRequest.filters)
}
inline void GetDesireRequest::add_filters(const char* value, size_t size) {
  _impl_.filters_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:duo.GetDesireRequest.filters)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetDesireRequest::filters() const {
  // @@protoc_insertion_point(field_list:duo.GetDesireRequest.filters)
  return _impl_.filters_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetDesireRequest::mutable_filters() {
  // @@protoc_insertion_point(field_mutable_list:duo.GetDesireRequest.filters)
  return &_impl_.filters_;
}

// -------------------------------------------------------------------

// GetDeltaRequest

// string thing = 1;
inline void GetDeltaRequest::clear_thing() {
  _impl_.thing_.ClearToEmpty();
}
inline const std::string& GetDeltaRequest::thing() const {
  // @@protoc_insertion_point(field_get:duo.GetDeltaRequest.thing)
  return _internal_thing();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetDeltaRequest::set_thing(ArgT0&& arg0, ArgT... args) {
 
 _impl_.thing_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:duo.GetDeltaRequest.thing)
}
inline std::string* GetDeltaRequest::mutable_thing() {
  std::string* _s = _internal_mutable_thing();
  // @@protoc_insertion_point(field_mutable:duo.GetDeltaRequest.thing)
  return _s;
}
inline const std::string& GetDeltaRequest::_internal_thing() const {
  return _impl_.thing_.Get();
}
inline void GetDeltaRequest::_internal_set_thing(const std::string& value) {
  
  _impl_.thing_.Set(value, GetArenaForAllocation());
}
inline std::string* GetDeltaRequest::_internal_mutable_thing() {
  
  return _impl_.thing_.Mutable(GetArenaForAllocation());
}
inline std::string* GetDeltaRequest::release_thing() {
  // @@protoc_insertion_point(field_release:duo.GetDeltaRequest.thing)
  return _impl_.thing_.Release();
}
inline void GetDeltaRequest::set_allocated_thing(std::string* thing) {
  if (thing != nullptr) {
    
  } else {
    
  }
  _impl_.thing_.SetAllocated(thing, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.thing_.IsDefault()) {
    _impl_.thing_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:duo.GetDeltaRequest.thing)
}

// optional string path = 2;
inline bool GetDeltaRequest::_internal_has_path() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GetDeltaRequest::has_path() const {
  return _internal_has_path();
}
inline void GetDeltaRequest::clear_path() {
  _impl_.path_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GetDeltaRequest::path() const {
  // @@protoc_insertion_point(field_get:duo.GetDeltaRequest.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetDeltaRequest::set_path(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:duo.GetDeltaRequest.path)
}
inline std::string* GetDeltaRequest::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:duo.GetDeltaRequest.path)
  return _s;
}
inline const std::string& GetDeltaRequest::_internal_path() const {
  return _impl_.path_.Get();
}
inline void GetDeltaRequest::_internal_set_path(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* GetDeltaRequest::_internal_mutable_path() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.path_.Mutable(GetArenaForAllocation());
}
inline std::string* GetDeltaRequest::release_path() {
  // @@protoc_insertion_point(field_release:duo.GetDeltaRequest.path)
  if (!_internal_has_path()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.path_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GetDeltaRequest::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:duo.GetDeltaRequest.path)
}

// repeated string filters = 3;
inline int GetDeltaRequest::_internal_filters_size() const {
  return _impl_.filters_.size();
}
inline int GetDeltaRequest::filters_size() const {
  return _internal_filters_size();
}
inline void GetDeltaRequest::clear_filters() {
  _impl_.filters_.Clear();
}
inline std::string* GetDeltaRequest::add_filters() {
  std::string* _s = _internal_add_filters();
  // @@protoc_insertion_point(field_add_mutable:duo.GetDeltaRequest.filters)
  return _s;
}
inline const std::string& GetDeltaRequest::_internal_filters(int index) const {
  return _impl_.filters_.Get(index);
}
inline const std::string& GetDeltaRequest::filters(int index) const {
  // @@protoc_insertion_point(field_get:duo.GetDeltaRequest.filters)
  return _internal_filters(index);
}
inline std::string* GetDeltaRequest::mutable_filters(int index) {
  // @@protoc_insertion_point(field_mutable:duo.GetDeltaRequest.filters)
  return _impl_.filters_.Mutable(index);
}
inline void GetDeltaRequest::set_filters(int index, const std::string& value) {
  _impl_.filters_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:duo.GetDeltaRequest.filters)
}
inline void GetDeltaRequest::set_filters(int index, std::string&& value) {
  _impl_.filters_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:duo.GetDeltaRequest.filters)
}
inline void GetDeltaRequest::set_filters(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.filters_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:duo.GetDeltaRequest.filters)
}
inline void GetDeltaRequest::set_filters(int index, const char* value, size_t size) {
  _impl_.filters_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:duo.GetDeltaRequest.filters)
}
inline std::string* GetDeltaRequest::_internal_add_filters() {
  return _impl_.filters_.Add();
}
inline void GetDeltaRequest::add_filters(const std::string& value) {
  _impl_.filters_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:duo.GetDeltaRequest.filters)
}
inline void GetDeltaRequest::add_filters(std::string&& value) {
  _impl_.filters_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:duo.GetDeltaRequest.filters)
}
inline void GetDeltaRequest::add_filters(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.filters_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:duo.GetDeltaRequest.filters)
}
inline void GetDeltaRequest::add_filters(const char* value, size_t size) {
  _impl_.filters_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:duo.GetDeltaRequest.filters)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetDeltaRequest::filters() const {
  // @@protoc_insertion_point(field_list:duo.GetDeltaRequest.filters)
  return _impl_.filters_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetDeltaRequest::mutable_filters() {
  // @@protoc_insertion_point(field_mutable_list:duo.GetDeltaRequest.filters)
  return &_impl_.filters_;
}

// -------------------------------------------------------------------

// PatchReportRequest

// string thing = 1;
inline void PatchReportRequest::clear_thing() {
  _impl_.thing_.ClearToEmpty();
}
inline const std::string& PatchReportRequest::thing() const {
  // @@protoc_insertion_point(field_get:duo.PatchReportRequest.thing)
  return _internal_thing();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PatchReportRequest::set_thing(ArgT0&& arg0, ArgT... args) {
 
 _impl_.thing_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:duo.PatchReportRequest.thing)
}
inline std::string* PatchReportRequest::mutable_thing() {
  std::string* _s = _internal_mutable_thing();
  // @@protoc_insertion_point(field_mutable:duo.PatchReportRequest.thing)
  return _s;
}
inline const std::string& PatchReportRequest::_internal_thing() const {
  return _impl_.thing_.Get();
}
inline void PatchReportRequest::_internal_set_thing(const std::string& value) {
  
  _impl_.thing_.Set(value, GetArenaForAllocation());
}
inline std::string* PatchReportRequest::_internal_mutable_thing() {
  
  return _impl_.thing_.Mutable(GetArenaForAllocation());
}
inline std::string* PatchReportRequest::release_thing() {
  // @@protoc_insertion_point(field_release:duo.PatchReportRequest.thing)
  return _impl_.thing_.Release();
}
inline void PatchReportRequest::set_allocated_thing(std::string* thing) {
  if (thing != nullptr) {
    
  } else {
    
  }
  _impl_.thing_.SetAllocated(thing, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.thing_.IsDefault()) {
    _impl_.thing_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:duo.PatchReportRequest.thing)
}

// optional string path = 2;
inline bool PatchReportRequest::_internal_has_path() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PatchReportRequest::has_path() const {
  return _internal_has_path();
}
inline void PatchReportRequest::clear_path() {
  _impl_.path_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PatchReportRequest::path() const {
  // @@protoc_insertion_point(field_get:duo.PatchReportRequest.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PatchReportRequest::set_path(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:duo.PatchReportRequest.path)
}
inline std::string* PatchReportRequest::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:duo.PatchReportRequest.path)
  return _s;
}
inline const std::string& PatchReportRequest::_internal_path() const {
  return _impl_.path_.Get();
}
inline void PatchReportRequest::_internal_set_path(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* PatchReportRequest::_internal_mutable_path() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.path_.Mutable(GetArenaForAllocation());
}
inline std::string* PatchReportRequest::release_path() {
  // @@protoc_insertion_point(field_release:duo.PatchReportRequest.path)
  if (!_internal_has_path()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.path_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PatchReportRequest::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:duo.PatchReportRequest.path)
}

// optional .google.protobuf.Value item = 3;
inline bool PatchReportRequest::_internal_has_item() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.item_ != nullptr);
  return value;
}
inline bool PatchReportRequest::has_item() const {
  return _internal_has_item();
}
inline const ::PROTOBUF_NAMESPACE_ID::Value& PatchReportRequest::_internal_item() const {
  const ::PROTOBUF_NAMESPACE_ID::Value* p = _impl_.item_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Value&>(
      ::PROTOBUF_NAMESPACE_ID::_Value_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Value& PatchReportRequest::item() const {
  // @@protoc_insertion_point(field_get:duo.PatchReportRequest.item)
  return _internal_item();
}
inline void PatchReportRequest::unsafe_arena_set_allocated_item(
    ::PROTOBUF_NAMESPACE_ID::Value* item) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.item_);
  }
  _impl_.item_ = item;
  if (item) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:duo.PatchReportRequest.item)
}
inline ::PROTOBUF_NAMESPACE_ID::Value* PatchReportRequest::release_item() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::PROTOBUF_NAMESPACE_ID::Value* temp = _impl_.item_;
  _impl_.item_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Value* PatchReportRequest::unsafe_arena_release_item() {
  // @@protoc_insertion_point(field_release:duo.PatchReportRequest.item)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::PROTOBUF_NAMESPACE_ID::Value* temp = _impl_.item_;
  _impl_.item_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Value* PatchReportRequest::_internal_mutable_item() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.item_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Value>(GetArenaForAllocation());
    _impl_.item_ = p;
  }
  return _impl_.item_;
}
inline ::PROTOBUF_NAMESPACE_ID::Value* PatchReportRequest::mutable_item() {
  ::PROTOBUF_NAMESPACE_ID::Value* _msg = _internal_mutable_item();
  // @@protoc_insertion_point(field_mutable:duo.PatchReportRequest.item)
  return _msg;
}
inline void PatchReportRequest::set_allocated_item(::PROTOBUF_NAMESPACE_ID::Value* item) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.item_);
  }
  if (item) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(item));
    if (message_arena != submessage_arena) {
      item = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, item, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.item_ = item;
  // @@protoc_insertion_point(field_set_allocated:duo.PatchReportRequest.item)
}

// optional .google.protobuf.Value condition = 4;
inline bool PatchReportRequest::_internal_has_condition() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.condition_ != nullptr);
  return value;
}
inline bool PatchReportRequest::has_condition() const {
  return _internal_has_condition();
}
inline const ::PROTOBUF_NAMESPACE_ID::Value& PatchReportRequest::_internal_condition() const {
  const ::PROTOBUF_NAMESPACE_ID::Value* p = _impl_.condition_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Value&>(
      ::PROTOBUF_NAMESPACE_ID::_Value_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Value& PatchReportRequest::condition() const {
  // @@protoc_insertion_point(field_get:duo.PatchReportRequest.condition)
  return _internal_condition();
}
inline void PatchReportRequest::unsafe_arena_set_allocated_condition(
    ::PROTOBUF_NAMESPACE_ID::Value* condition) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.condition_);
  }
  _impl_.condition_ = condition;
  if (condition) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:duo.PatchReportRequest.condition)
}
inline ::PROTOBUF_NAMESPACE_ID::Value* PatchReportRequest::release_condition() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::PROTOBUF_NAMESPACE_ID::Value* temp = _impl_.condition_;
  _impl_.condition_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Value* PatchReportRequest::unsafe_arena_release_condition() {
  // @@protoc_insertion_point(field_release:duo.PatchReportRequest.condition)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::PROTOBUF_NAMESPACE_ID::Value* temp = _impl_.condition_;
  _impl_.condition_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Value* PatchReportRequest::_internal_mutable_condition() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.condition_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Value>(GetArenaForAllocation());
    _impl_.condition_ = p;
  }
  return _impl_.condition_;
}
inline ::PROTOBUF_NAMESPACE_ID::Value* PatchReportRequest::mutable_condition() {
  ::PROTOBUF_NAMESPACE_ID::Value* _msg = _internal_mutable_condition();
  // @@protoc_insertion_point(field_mutable:duo.PatchReportRequest.condition)
  return _msg;
}
inline void PatchReportRequest::set_allocated_condition(::PROTOBUF_NAMESPACE_ID::Value* condition) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.condition_);
  }
  if (condition) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(condition));
    if (message_arena != submessage_arena) {
      condition = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, condition, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.condition_ = condition;
  // @@protoc_insertion_point(field_set_allocated:duo.PatchReportRequest.condition)
}

// optional .google.protobuf.Struct meta = 5;
inline bool PatchReportRequest::_internal_has_meta() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.meta_ != nullptr);
  return value;
}
inline bool PatchReportRequest::has_meta() const {
  return _internal_has_meta();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& PatchReportRequest::_internal_meta() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.meta_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& PatchReportRequest::meta() const {
  // @@protoc_insertion_point(field_get:duo.PatchReportRequest.meta)
  return _internal_meta();
}
inline void PatchReportRequest::unsafe_arena_set_allocated_meta(
    ::PROTOBUF_NAMESPACE_ID::Struct* meta) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.meta_);
  }
  _impl_.meta_ = meta;
  if (meta) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:duo.PatchReportRequest.meta)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* PatchReportRequest::release_meta() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.meta_;
  _impl_.meta_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* PatchReportRequest::unsafe_arena_release_meta() {
  // @@protoc_insertion_point(field_release:duo.PatchReportRequest.meta)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.meta_;
  _impl_.meta_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* PatchReportRequest::_internal_mutable_meta() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.meta_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.meta_ = p;
  }
  return _impl_.meta_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* PatchReportRequest::mutable_meta() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_meta();
  // @@protoc_insertion_point(field_mutable:duo.PatchReportRequest.meta)
  return _msg;
}
inline void PatchReportRequest::set_allocated_meta(::PROTOBUF_NAMESPACE_ID::Struct* meta) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.meta_);
  }
  if (meta) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(meta));
    if (message_arena != submessage_arena) {
      meta = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, meta, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.meta_ = meta;
  // @@protoc_insertion_point(field_set_allocated:duo.PatchReportRequest.meta)
}

// optional string ignore_listener_id = 6;
inline bool PatchReportRequest::_internal_has_ignore_listener_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PatchReportRequest::has_ignore_listener_id() const {
  return _internal_has_ignore_listener_id();
}
inline void PatchReportRequest::clear_ignore_listener_id() {
  _impl_.ignore_listener_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PatchReportRequest::ignore_listener_id() const {
  // @@protoc_insertion_point(field_get:duo.PatchReportRequest.ignore_listener_id)
  return _internal_ignore_listener_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PatchReportRequest::set_ignore_listener_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.ignore_listener_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:duo.PatchReportRequest.ignore_listener_id)
}
inline std::string* PatchReportRequest::mutable_ignore_listener_id() {
  std::string* _s = _internal_mutable_ignore_listener_id();
  // @@protoc_insertion_point(field_mutable:duo.PatchReportRequest.ignore_listener_id)
  return _s;
}
inline const std::string& PatchReportRequest::_internal_ignore_listener_id() const {
  return _impl_.ignore_listener_id_.Get();
}
inline void PatchReportRequest::_internal_set_ignore_listener_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.ignore_listener_id_.Set(value, GetArenaForAllocation());
}
inline std::string* PatchReportRequest::_internal_mutable_ignore_listener_id() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.ignore_listener_id_.Mutable(GetArenaForAllocation());
}
inline std::string* PatchReportRequest::release_ignore_listener_id() {
  // @@protoc_insertion_point(field_release:duo.PatchReportRequest.ignore_listener_id)
  if (!_internal_has_ignore_listener_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.ignore_listener_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ignore_listener_id_.IsDefault()) {
    _impl_.ignore_listener_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PatchReportRequest::set_allocated_ignore_listener_id(std::string* ignore_listener_id) {
  if (ignore_listener_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.ignore_listener_id_.SetAllocated(ignore_listener_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ignore_listener_id_.IsDefault()) {
    _impl_.ignore_listener_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:duo.PatchReportRequest.ignore_listener_id)
}

// optional .google.protobuf.ListValue items = 7;
inline bool PatchReportRequest::_internal_has_items() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.items_ != nullptr);
  return value;
}
inline bool PatchReportRequest::has_items() const {
  return _internal_has_items();
}
inline const ::PROTOBUF_NAMESPACE_ID::ListValue& PatchReportRequest::_internal_items() const {
  const ::PROTOBUF_NAMESPACE_ID::ListValue* p = _impl_.items_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::ListValue&>(
      ::PROTOBUF_NAMESPACE_ID::_ListValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::ListValue& PatchReportRequest::items() const {
  // @@protoc_insertion_point(field_get:duo.PatchReportRequest.items)
  return _internal_items();
}
inline void PatchReportRequest::unsafe_arena_set_allocated_items(
    ::PROTOBUF_NAMESPACE_ID::ListValue* items) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.items_);
  }
  _impl_.items_ = items;
  if (items) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:duo.PatchReportRequest.items)
}
inline ::PROTOBUF_NAMESPACE_ID::ListValue* PatchReportRequest::release_items() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::PROTOBUF_NAMESPACE_ID::ListValue* temp = _impl_.items_;
  _impl_.items_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::ListValue* PatchReportRequest::unsafe_arena_release_items() {
  // @@protoc_insertion_point(field_release:duo.PatchReportRequest.items)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::PROTOBUF_NAMESPACE_ID::ListValue* temp = _impl_.items_;
  _impl_.items_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::ListValue* PatchReportRequest::_internal_mutable_items() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.items_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::ListValue>(GetArenaForAllocation());
    _impl_.items_ = p;
  }
  return _impl_.items_;
}
inline ::PROTOBUF_NAMESPACE_ID::ListValue* PatchReportRequest::mutable_items() {
  ::PROTOBUF_NAMESPACE_ID::ListValue* _msg = _internal_mutable_items();
  // @@protoc_insertion_point(field_mutable:duo.PatchReportRequest.items)
  return _msg;
}
inline void PatchReportRequest::set_allocated_items(::PROTOBUF_NAMESPACE_ID::ListValue* items) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.items_);
  }
  if (items) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(items));
    if (message_arena != submessage_arena) {
      items = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, items, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.items_ = items;
  // @@protoc_insertion_point(field_set_allocated:duo.PatchReportRequest.items)
}

// -------------------------------------------------------------------

// PatchDesireRequest

// string thing = 1;
inline void PatchDesireRequest::clear_thing() {
  _impl_.thing_.ClearToEmpty();
}
inline const std::string& PatchDesireRequest::thing() const {
  // @@protoc_insertion_point(field_get:duo.PatchDesireRequest.thing)
  return _internal_thing();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PatchDesireRequest::set_thing(ArgT0&& arg0, ArgT... args) {
 
 _impl_.thing_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:duo.PatchDesireRequest.thing)
}
inline std::string* PatchDesireRequest::mutable_thing() {
  std::string* _s = _internal_mutable_thing();
  // @@protoc_insertion_point(field_mutable:duo.PatchDesireRequest.thing)
  return _s;
}
inline const std::string& PatchDesireRequest::_internal_thing() const {
  return _impl_.thing_.Get();
}
inline void PatchDesireRequest::_internal_set_thing(const std::string& value) {
  
  _impl_.thing_.Set(value, GetArenaForAllocation());
}
inline std::string* PatchDesireRequest::_internal_mutable_thing() {
  
  return _impl_.thing_.Mutable(GetArenaForAllocation());
}
inline std::string* PatchDesireRequest::release_thing() {
  // @@protoc_insertion_point(field_release:duo.PatchDesireRequest.thing)
  return _impl_.thing_.Release();
}
inline void PatchDesireRequest::set_allocated_thing(std::string* thing) {
  if (thing != nullptr) {
    
  } else {
    
  }
  _impl_.thing_.SetAllocated(thing, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.thing_.IsDefault()) {
    _impl_.thing_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:duo.PatchDesireRequest.thing)
}

// optional string path = 2;
inline bool PatchDesireRequest::_internal_has_path() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PatchDesireRequest::has_path() const {
  return _internal_has_path();
}
inline void PatchDesireRequest::clear_path() {
  _impl_.path_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PatchDesireRequest::path() const {
  // @@protoc_insertion_point(field_get:duo.PatchDesireRequest.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PatchDesireRequest::set_path(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:duo.PatchDesireRequest.path)
}
inline std::string* PatchDesireRequest::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:duo.PatchDesireRequest.path)
  return _s;
}
inline const std::string& PatchDesireRequest::_internal_path() const {
  return _impl_.path_.Get();
}
inline void PatchDesireRequest::_internal_set_path(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* PatchDesireRequest::_internal_mutable_path() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.path_.Mutable(GetArenaForAllocation());
}
inline std::string* PatchDesireRequest::release_path() {
  // @@protoc_insertion_point(field_release:duo.PatchDesireRequest.path)
  if (!_internal_has_path()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.path_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PatchDesireRequest::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:duo.PatchDesireRequest.path)
}

// .google.protobuf.Value item = 3;
inline bool PatchDesireRequest::_internal_has_item() const {
  return this != internal_default_instance() && _impl_.item_ != nullptr;
}
inline bool PatchDesireRequest::has_item() const {
  return _internal_has_item();
}
inline const ::PROTOBUF_NAMESPACE_ID::Value& PatchDesireRequest::_internal_item() const {
  const ::PROTOBUF_NAMESPACE_ID::Value* p = _impl_.item_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Value&>(
      ::PROTOBUF_NAMESPACE_ID::_Value_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Value& PatchDesireRequest::item() const {
  // @@protoc_insertion_point(field_get:duo.PatchDesireRequest.item)
  return _internal_item();
}
inline void PatchDesireRequest::unsafe_arena_set_allocated_item(
    ::PROTOBUF_NAMESPACE_ID::Value* item) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.item_);
  }
  _impl_.item_ = item;
  if (item) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:duo.PatchDesireRequest.item)
}
inline ::PROTOBUF_NAMESPACE_ID::Value* PatchDesireRequest::release_item() {
  
  ::PROTOBUF_NAMESPACE_ID::Value* temp = _impl_.item_;
  _impl_.item_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Value* PatchDesireRequest::unsafe_arena_release_item() {
  // @@protoc_insertion_point(field_release:duo.PatchDesireRequest.item)
  
  ::PROTOBUF_NAMESPACE_ID::Value* temp = _impl_.item_;
  _impl_.item_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Value* PatchDesireRequest::_internal_mutable_item() {
  
  if (_impl_.item_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Value>(GetArenaForAllocation());
    _impl_.item_ = p;
  }
  return _impl_.item_;
}
inline ::PROTOBUF_NAMESPACE_ID::Value* PatchDesireRequest::mutable_item() {
  ::PROTOBUF_NAMESPACE_ID::Value* _msg = _internal_mutable_item();
  // @@protoc_insertion_point(field_mutable:duo.PatchDesireRequest.item)
  return _msg;
}
inline void PatchDesireRequest::set_allocated_item(::PROTOBUF_NAMESPACE_ID::Value* item) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.item_);
  }
  if (item) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(item));
    if (message_arena != submessage_arena) {
      item = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, item, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.item_ = item;
  // @@protoc_insertion_point(field_set_allocated:duo.PatchDesireRequest.item)
}

// optional .google.protobuf.Value condition = 4;
inline bool PatchDesireRequest::_internal_has_condition() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.condition_ != nullptr);
  return value;
}
inline bool PatchDesireRequest::has_condition() const {
  return _internal_has_condition();
}
inline const ::PROTOBUF_NAMESPACE_ID::Value& PatchDesireRequest::_internal_condition() const {
  const ::PROTOBUF_NAMESPACE_ID::Value* p = _impl_.condition_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Value&>(
      ::PROTOBUF_NAMESPACE_ID::_Value_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Value& PatchDesireRequest::condition() const {
  // @@protoc_insertion_point(field_get:duo.PatchDesireRequest.condition)
  return _internal_condition();
}
inline void PatchDesireRequest::unsafe_arena_set_allocated_condition(
    ::PROTOBUF_NAMESPACE_ID::Value* condition) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.condition_);
  }
  _impl_.condition_ = condition;
  if (condition) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:duo.PatchDesireRequest.condition)
}
inline ::PROTOBUF_NAMESPACE_ID::Value* PatchDesireRequest::release_condition() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::PROTOBUF_NAMESPACE_ID::Value* temp = _impl_.condition_;
  _impl_.condition_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Value* PatchDesireRequest::unsafe_arena_release_condition() {
  // @@protoc_insertion_point(field_release:duo.PatchDesireRequest.condition)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::PROTOBUF_NAMESPACE_ID::Value* temp = _impl_.condition_;
  _impl_.condition_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Value* PatchDesireRequest::_internal_mutable_condition() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.condition_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Value>(GetArenaForAllocation());
    _impl_.condition_ = p;
  }
  return _impl_.condition_;
}
inline ::PROTOBUF_NAMESPACE_ID::Value* PatchDesireRequest::mutable_condition() {
  ::PROTOBUF_NAMESPACE_ID::Value* _msg = _internal_mutable_condition();
  // @@protoc_insertion_point(field_mutable:duo.PatchDesireRequest.condition)
  return _msg;
}
inline void PatchDesireRequest::set_allocated_condition(::PROTOBUF_NAMESPACE_ID::Value* condition) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.condition_);
  }
  if (condition) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(condition));
    if (message_arena != submessage_arena) {
      condition = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, condition, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.condition_ = condition;
  // @@protoc_insertion_point(field_set_allocated:duo.PatchDesireRequest.condition)
}

// optional .google.protobuf.Struct meta = 5;
inline bool PatchDesireRequest::_internal_has_meta() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.meta_ != nullptr);
  return value;
}
inline bool PatchDesireRequest::has_meta() const {
  return _internal_has_meta();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& PatchDesireRequest::_internal_meta() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.meta_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& PatchDesireRequest::meta() const {
  // @@protoc_insertion_point(field_get:duo.PatchDesireRequest.meta)
  return _internal_meta();
}
inline void PatchDesireRequest::unsafe_arena_set_allocated_meta(
    ::PROTOBUF_NAMESPACE_ID::Struct* meta) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.meta_);
  }
  _impl_.meta_ = meta;
  if (meta) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:duo.PatchDesireRequest.meta)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* PatchDesireRequest::release_meta() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.meta_;
  _impl_.meta_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* PatchDesireRequest::unsafe_arena_release_meta() {
  // @@protoc_insertion_point(field_release:duo.PatchDesireRequest.meta)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.meta_;
  _impl_.meta_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* PatchDesireRequest::_internal_mutable_meta() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.meta_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.meta_ = p;
  }
  return _impl_.meta_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* PatchDesireRequest::mutable_meta() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_meta();
  // @@protoc_insertion_point(field_mutable:duo.PatchDesireRequest.meta)
  return _msg;
}
inline void PatchDesireRequest::set_allocated_meta(::PROTOBUF_NAMESPACE_ID::Struct* meta) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.meta_);
  }
  if (meta) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(meta));
    if (message_arena != submessage_arena) {
      meta = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, meta, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.meta_ = meta;
  // @@protoc_insertion_point(field_set_allocated:duo.PatchDesireRequest.meta)
}

// optional string ignore_listener_id = 6;
inline bool PatchDesireRequest::_internal_has_ignore_listener_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PatchDesireRequest::has_ignore_listener_id() const {
  return _internal_has_ignore_listener_id();
}
inline void PatchDesireRequest::clear_ignore_listener_id() {
  _impl_.ignore_listener_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PatchDesireRequest::ignore_listener_id() const {
  // @@protoc_insertion_point(field_get:duo.PatchDesireRequest.ignore_listener_id)
  return _internal_ignore_listener_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PatchDesireRequest::set_ignore_listener_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.ignore_listener_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:duo.PatchDesireRequest.ignore_listener_id)
}
inline std::string* PatchDesireRequest::mutable_ignore_listener_id() {
  std::string* _s = _internal_mutable_ignore_listener_id();
  // @@protoc_insertion_point(field_mutable:duo.PatchDesireRequest.ignore_listener_id)
  return _s;
}
inline const std::string& PatchDesireRequest::_internal_ignore_listener_id() const {
  return _impl_.ignore_listener_id_.Get();
}
inline void PatchDesireRequest::_internal_set_ignore_listener_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.ignore_listener_id_.Set(value, GetArenaForAllocation());
}
inline std::string* PatchDesireRequest::_internal_mutable_ignore_listener_id() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.ignore_listener_id_.Mutable(GetArenaForAllocation());
}
inline std::string* PatchDesireRequest::release_ignore_listener_id() {
  // @@protoc_insertion_point(field_release:duo.PatchDesireRequest.ignore_listener_id)
  if (!_internal_has_ignore_listener_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.ignore_listener_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ignore_listener_id_.IsDefault()) {
    _impl_.ignore_listener_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PatchDesireRequest::set_allocated_ignore_listener_id(std::string* ignore_listener_id) {
  if (ignore_listener_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.ignore_listener_id_.SetAllocated(ignore_listener_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ignore_listener_id_.IsDefault()) {
    _impl_.ignore_listener_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:duo.PatchDesireRequest.ignore_listener_id)
}

// -------------------------------------------------------------------

// DeleteRequest

// string thing = 1;
inline void DeleteRequest::clear_thing() {
  _impl_.thing_.ClearToEmpty();
}
inline const std::string& DeleteRequest::thing() const {
  // @@protoc_insertion_point(field_get:duo.DeleteRequest.thing)
  return _internal_thing();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteRequest::set_thing(ArgT0&& arg0, ArgT... args) {
 
 _impl_.thing_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:duo.DeleteRequest.thing)
}
inline std::string* DeleteRequest::mutable_thing() {
  std::string* _s = _internal_mutable_thing();
  // @@protoc_insertion_point(field_mutable:duo.DeleteRequest.thing)
  return _s;
}
inline const std::string& DeleteRequest::_internal_thing() const {
  return _impl_.thing_.Get();
}
inline void DeleteRequest::_internal_set_thing(const std::string& value) {
  
  _impl_.thing_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteRequest::_internal_mutable_thing() {
  
  return _impl_.thing_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteRequest::release_thing() {
  // @@protoc_insertion_point(field_release:duo.DeleteRequest.thing)
  return _impl_.thing_.Release();
}
inline void DeleteRequest::set_allocated_thing(std::string* thing) {
  if (thing != nullptr) {
    
  } else {
    
  }
  _impl_.thing_.SetAllocated(thing, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.thing_.IsDefault()) {
    _impl_.thing_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:duo.DeleteRequest.thing)
}

// -------------------------------------------------------------------

// UploadMetadata

// string thing = 1;
inline void UploadMetadata::clear_thing() {
  _impl_.thing_.ClearToEmpty();
}
inline const std::string& UploadMetadata::thing() const {
  // @@protoc_insertion_point(field_get:duo.UploadMetadata.thing)
  return _internal_thing();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UploadMetadata::set_thing(ArgT0&& arg0, ArgT... args) {
 
 _impl_.thing_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:duo.UploadMetadata.thing)
}
inline std::string* UploadMetadata::mutable_thing() {
  std::string* _s = _internal_mutable_thing();
  // @@protoc_insertion_point(field_mutable:duo.UploadMetadata.thing)
  return _s;
}
inline const std::string& UploadMetadata::_internal_thing() const {
  return _impl_.thing_.Get();
}
inline void UploadMetadata::_internal_set_thing(const std::string& value) {
  
  _impl_.thing_.Set(value, GetArenaForAllocation());
}
inline std::string* UploadMetadata::_internal_mutable_thing() {
  
  return _impl_.thing_.Mutable(GetArenaForAllocation());
}
inline std::string* UploadMetadata::release_thing() {
  // @@protoc_insertion_point(field_release:duo.UploadMetadata.thing)
  return _impl_.thing_.Release();
}
inline void UploadMetadata::set_allocated_thing(std::string* thing) {
  if (thing != nullptr) {
    
  } else {
    
  }
  _impl_.thing_.SetAllocated(thing, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.thing_.IsDefault()) {
    _impl_.thing_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:duo.UploadMetadata.thing)
}

// string path = 2;
inline void UploadMetadata::clear_path() {
  _impl_.path_.ClearToEmpty();
}
inline const std::string& UploadMetadata::path() const {
  // @@protoc_insertion_point(field_get:duo.UploadMetadata.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UploadMetadata::set_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:duo.UploadMetadata.path)
}
inline std::string* UploadMetadata::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:duo.UploadMetadata.path)
  return _s;
}
inline const std::string& UploadMetadata::_internal_path() const {
  return _impl_.path_.Get();
}
inline void UploadMetadata::_internal_set_path(const std::string& value) {
  
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* UploadMetadata::_internal_mutable_path() {
  
  return _impl_.path_.Mutable(GetArenaForAllocation());
}
inline std::string* UploadMetadata::release_path() {
  // @@protoc_insertion_point(field_release:duo.UploadMetadata.path)
  return _impl_.path_.Release();
}
inline void UploadMetadata::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  _impl_.path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:duo.UploadMetadata.path)
}

// -------------------------------------------------------------------

// UploadRequest

// .duo.UploadMetadata meta = 1;
inline bool UploadRequest::_internal_has_meta() const {
  return data_case() == kMeta;
}
inline bool UploadRequest::has_meta() const {
  return _internal_has_meta();
}
inline void UploadRequest::set_has_meta() {
  _impl_._oneof_case_[0] = kMeta;
}
inline void UploadRequest::clear_meta() {
  if (_internal_has_meta()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.data_.meta_;
    }
    clear_has_data();
  }
}
inline ::duo::UploadMetadata* UploadRequest::release_meta() {
  // @@protoc_insertion_point(field_release:duo.UploadRequest.meta)
  if (_internal_has_meta()) {
    clear_has_data();
    ::duo::UploadMetadata* temp = _impl_.data_.meta_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.meta_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::duo::UploadMetadata& UploadRequest::_internal_meta() const {
  return _internal_has_meta()
      ? *_impl_.data_.meta_
      : reinterpret_cast< ::duo::UploadMetadata&>(::duo::_UploadMetadata_default_instance_);
}
inline const ::duo::UploadMetadata& UploadRequest::meta() const {
  // @@protoc_insertion_point(field_get:duo.UploadRequest.meta)
  return _internal_meta();
}
inline ::duo::UploadMetadata* UploadRequest::unsafe_arena_release_meta() {
  // @@protoc_insertion_point(field_unsafe_arena_release:duo.UploadRequest.meta)
  if (_internal_has_meta()) {
    clear_has_data();
    ::duo::UploadMetadata* temp = _impl_.data_.meta_;
    _impl_.data_.meta_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UploadRequest::unsafe_arena_set_allocated_meta(::duo::UploadMetadata* meta) {
  clear_data();
  if (meta) {
    set_has_meta();
    _impl_.data_.meta_ = meta;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:duo.UploadRequest.meta)
}
inline ::duo::UploadMetadata* UploadRequest::_internal_mutable_meta() {
  if (!_internal_has_meta()) {
    clear_data();
    set_has_meta();
    _impl_.data_.meta_ = CreateMaybeMessage< ::duo::UploadMetadata >(GetArenaForAllocation());
  }
  return _impl_.data_.meta_;
}
inline ::duo::UploadMetadata* UploadRequest::mutable_meta() {
  ::duo::UploadMetadata* _msg = _internal_mutable_meta();
  // @@protoc_insertion_point(field_mutable:duo.UploadRequest.meta)
  return _msg;
}

// bytes chunk = 2;
inline bool UploadRequest::_internal_has_chunk() const {
  return data_case() == kChunk;
}
inline bool UploadRequest::has_chunk() const {
  return _internal_has_chunk();
}
inline void UploadRequest::set_has_chunk() {
  _impl_._oneof_case_[0] = kChunk;
}
inline void UploadRequest::clear_chunk() {
  if (_internal_has_chunk()) {
    _impl_.data_.chunk_.Destroy();
    clear_has_data();
  }
}
inline const std::string& UploadRequest::chunk() const {
  // @@protoc_insertion_point(field_get:duo.UploadRequest.chunk)
  return _internal_chunk();
}
template <typename ArgT0, typename... ArgT>
inline void UploadRequest::set_chunk(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_chunk()) {
    clear_data();
    set_has_chunk();
    _impl_.data_.chunk_.InitDefault();
  }
  _impl_.data_.chunk_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:duo.UploadRequest.chunk)
}
inline std::string* UploadRequest::mutable_chunk() {
  std::string* _s = _internal_mutable_chunk();
  // @@protoc_insertion_point(field_mutable:duo.UploadRequest.chunk)
  return _s;
}
inline const std::string& UploadRequest::_internal_chunk() const {
  if (_internal_has_chunk()) {
    return _impl_.data_.chunk_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void UploadRequest::_internal_set_chunk(const std::string& value) {
  if (!_internal_has_chunk()) {
    clear_data();
    set_has_chunk();
    _impl_.data_.chunk_.InitDefault();
  }
  _impl_.data_.chunk_.Set(value, GetArenaForAllocation());
}
inline std::string* UploadRequest::_internal_mutable_chunk() {
  if (!_internal_has_chunk()) {
    clear_data();
    set_has_chunk();
    _impl_.data_.chunk_.InitDefault();
  }
  return _impl_.data_.chunk_.Mutable(      GetArenaForAllocation());
}
inline std::string* UploadRequest::release_chunk() {
  // @@protoc_insertion_point(field_release:duo.UploadRequest.chunk)
  if (_internal_has_chunk()) {
    clear_has_data();
    return _impl_.data_.chunk_.Release();
  } else {
    return nullptr;
  }
}
inline void UploadRequest::set_allocated_chunk(std::string* chunk) {
  if (has_data()) {
    clear_data();
  }
  if (chunk != nullptr) {
    set_has_chunk();
    _impl_.data_.chunk_.InitAllocated(chunk, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:duo.UploadRequest.chunk)
}

inline bool UploadRequest::has_data() const {
  return data_case() != DATA_NOT_SET;
}
inline void UploadRequest::clear_has_data() {
  _impl_._oneof_case_[0] = DATA_NOT_SET;
}
inline UploadRequest::DataCase UploadRequest::data_case() const {
  return UploadRequest::DataCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// GetThingListRequest

// optional string from = 1;
inline bool GetThingListRequest::_internal_has_from() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GetThingListRequest::has_from() const {
  return _internal_has_from();
}
inline void GetThingListRequest::clear_from() {
  _impl_.from_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GetThingListRequest::from() const {
  // @@protoc_insertion_point(field_get:duo.GetThingListRequest.from)
  return _internal_from();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetThingListRequest::set_from(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.from_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:duo.GetThingListRequest.from)
}
inline std::string* GetThingListRequest::mutable_from() {
  std::string* _s = _internal_mutable_from();
  // @@protoc_insertion_point(field_mutable:duo.GetThingListRequest.from)
  return _s;
}
inline const std::string& GetThingListRequest::_internal_from() const {
  return _impl_.from_.Get();
}
inline void GetThingListRequest::_internal_set_from(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.from_.Set(value, GetArenaForAllocation());
}
inline std::string* GetThingListRequest::_internal_mutable_from() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.from_.Mutable(GetArenaForAllocation());
}
inline std::string* GetThingListRequest::release_from() {
  // @@protoc_insertion_point(field_release:duo.GetThingListRequest.from)
  if (!_internal_has_from()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.from_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.from_.IsDefault()) {
    _impl_.from_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GetThingListRequest::set_allocated_from(std::string* from) {
  if (from != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.from_.SetAllocated(from, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.from_.IsDefault()) {
    _impl_.from_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:duo.GetThingListRequest.from)
}

// optional int32 page_size = 2;
inline bool GetThingListRequest::_internal_has_page_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GetThingListRequest::has_page_size() const {
  return _internal_has_page_size();
}
inline void GetThingListRequest::clear_page_size() {
  _impl_.page_size_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t GetThingListRequest::_internal_page_size() const {
  return _impl_.page_size_;
}
inline int32_t GetThingListRequest::page_size() const {
  // @@protoc_insertion_point(field_get:duo.GetThingListRequest.page_size)
  return _internal_page_size();
}
inline void GetThingListRequest::_internal_set_page_size(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.page_size_ = value;
}
inline void GetThingListRequest::set_page_size(int32_t value) {
  _internal_set_page_size(value);
  // @@protoc_insertion_point(field_set:duo.GetThingListRequest.page_size)
}

// optional string filter = 3;
inline bool GetThingListRequest::_internal_has_filter() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GetThingListRequest::has_filter() const {
  return _internal_has_filter();
}
inline void GetThingListRequest::clear_filter() {
  _impl_.filter_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& GetThingListRequest::filter() const {
  // @@protoc_insertion_point(field_get:duo.GetThingListRequest.filter)
  return _internal_filter();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetThingListRequest::set_filter(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.filter_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:duo.GetThingListRequest.filter)
}
inline std::string* GetThingListRequest::mutable_filter() {
  std::string* _s = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:duo.GetThingListRequest.filter)
  return _s;
}
inline const std::string& GetThingListRequest::_internal_filter() const {
  return _impl_.filter_.Get();
}
inline void GetThingListRequest::_internal_set_filter(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.filter_.Set(value, GetArenaForAllocation());
}
inline std::string* GetThingListRequest::_internal_mutable_filter() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.filter_.Mutable(GetArenaForAllocation());
}
inline std::string* GetThingListRequest::release_filter() {
  // @@protoc_insertion_point(field_release:duo.GetThingListRequest.filter)
  if (!_internal_has_filter()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.filter_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filter_.IsDefault()) {
    _impl_.filter_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GetThingListRequest::set_allocated_filter(std::string* filter) {
  if (filter != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.filter_.SetAllocated(filter, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filter_.IsDefault()) {
    _impl_.filter_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:duo.GetThingListRequest.filter)
}

// -------------------------------------------------------------------

// ListenReportRequest

// string thing = 1;
inline void ListenReportRequest::clear_thing() {
  _impl_.thing_.ClearToEmpty();
}
inline const std::string& ListenReportRequest::thing() const {
  // @@protoc_insertion_point(field_get:duo.ListenReportRequest.thing)
  return _internal_thing();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListenReportRequest::set_thing(ArgT0&& arg0, ArgT... args) {
 
 _impl_.thing_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:duo.ListenReportRequest.thing)
}
inline std::string* ListenReportRequest::mutable_thing() {
  std::string* _s = _internal_mutable_thing();
  // @@protoc_insertion_point(field_mutable:duo.ListenReportRequest.thing)
  return _s;
}
inline const std::string& ListenReportRequest::_internal_thing() const {
  return _impl_.thing_.Get();
}
inline void ListenReportRequest::_internal_set_thing(const std::string& value) {
  
  _impl_.thing_.Set(value, GetArenaForAllocation());
}
inline std::string* ListenReportRequest::_internal_mutable_thing() {
  
  return _impl_.thing_.Mutable(GetArenaForAllocation());
}
inline std::string* ListenReportRequest::release_thing() {
  // @@protoc_insertion_point(field_release:duo.ListenReportRequest.thing)
  return _impl_.thing_.Release();
}
inline void ListenReportRequest::set_allocated_thing(std::string* thing) {
  if (thing != nullptr) {
    
  } else {
    
  }
  _impl_.thing_.SetAllocated(thing, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.thing_.IsDefault()) {
    _impl_.thing_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:duo.ListenReportRequest.thing)
}

// optional bool no_merge = 2;
inline bool ListenReportRequest::_internal_has_no_merge() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ListenReportRequest::has_no_merge() const {
  return _internal_has_no_merge();
}
inline void ListenReportRequest::clear_no_merge() {
  _impl_.no_merge_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool ListenReportRequest::_internal_no_merge() const {
  return _impl_.no_merge_;
}
inline bool ListenReportRequest::no_merge() const {
  // @@protoc_insertion_point(field_get:duo.ListenReportRequest.no_merge)
  return _internal_no_merge();
}
inline void ListenReportRequest::_internal_set_no_merge(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.no_merge_ = value;
}
inline void ListenReportRequest::set_no_merge(bool value) {
  _internal_set_no_merge(value);
  // @@protoc_insertion_point(field_set:duo.ListenReportRequest.no_merge)
}

// repeated string filters = 3;
inline int ListenReportRequest::_internal_filters_size() const {
  return _impl_.filters_.size();
}
inline int ListenReportRequest::filters_size() const {
  return _internal_filters_size();
}
inline void ListenReportRequest::clear_filters() {
  _impl_.filters_.Clear();
}
inline std::string* ListenReportRequest::add_filters() {
  std::string* _s = _internal_add_filters();
  // @@protoc_insertion_point(field_add_mutable:duo.ListenReportRequest.filters)
  return _s;
}
inline const std::string& ListenReportRequest::_internal_filters(int index) const {
  return _impl_.filters_.Get(index);
}
inline const std::string& ListenReportRequest::filters(int index) const {
  // @@protoc_insertion_point(field_get:duo.ListenReportRequest.filters)
  return _internal_filters(index);
}
inline std::string* ListenReportRequest::mutable_filters(int index) {
  // @@protoc_insertion_point(field_mutable:duo.ListenReportRequest.filters)
  return _impl_.filters_.Mutable(index);
}
inline void ListenReportRequest::set_filters(int index, const std::string& value) {
  _impl_.filters_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:duo.ListenReportRequest.filters)
}
inline void ListenReportRequest::set_filters(int index, std::string&& value) {
  _impl_.filters_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:duo.ListenReportRequest.filters)
}
inline void ListenReportRequest::set_filters(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.filters_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:duo.ListenReportRequest.filters)
}
inline void ListenReportRequest::set_filters(int index, const char* value, size_t size) {
  _impl_.filters_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:duo.ListenReportRequest.filters)
}
inline std::string* ListenReportRequest::_internal_add_filters() {
  return _impl_.filters_.Add();
}
inline void ListenReportRequest::add_filters(const std::string& value) {
  _impl_.filters_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:duo.ListenReportRequest.filters)
}
inline void ListenReportRequest::add_filters(std::string&& value) {
  _impl_.filters_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:duo.ListenReportRequest.filters)
}
inline void ListenReportRequest::add_filters(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.filters_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:duo.ListenReportRequest.filters)
}
inline void ListenReportRequest::add_filters(const char* value, size_t size) {
  _impl_.filters_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:duo.ListenReportRequest.filters)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ListenReportRequest::filters() const {
  // @@protoc_insertion_point(field_list:duo.ListenReportRequest.filters)
  return _impl_.filters_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ListenReportRequest::mutable_filters() {
  // @@protoc_insertion_point(field_mutable_list:duo.ListenReportRequest.filters)
  return &_impl_.filters_;
}

// optional string id = 4;
inline bool ListenReportRequest::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ListenReportRequest::has_id() const {
  return _internal_has_id();
}
inline void ListenReportRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ListenReportRequest::id() const {
  // @@protoc_insertion_point(field_get:duo.ListenReportRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListenReportRequest::set_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:duo.ListenReportRequest.id)
}
inline std::string* ListenReportRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:duo.ListenReportRequest.id)
  return _s;
}
inline const std::string& ListenReportRequest::_internal_id() const {
  return _impl_.id_.Get();
}
inline void ListenReportRequest::_internal_set_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* ListenReportRequest::_internal_mutable_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* ListenReportRequest::release_id() {
  // @@protoc_insertion_point(field_release:duo.ListenReportRequest.id)
  if (!_internal_has_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ListenReportRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:duo.ListenReportRequest.id)
}

// optional bool needs_initial_value = 5;
inline bool ListenReportRequest::_internal_has_needs_initial_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ListenReportRequest::has_needs_initial_value() const {
  return _internal_has_needs_initial_value();
}
inline void ListenReportRequest::clear_needs_initial_value() {
  _impl_.needs_initial_value_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool ListenReportRequest::_internal_needs_initial_value() const {
  return _impl_.needs_initial_value_;
}
inline bool ListenReportRequest::needs_initial_value() const {
  // @@protoc_insertion_point(field_get:duo.ListenReportRequest.needs_initial_value)
  return _internal_needs_initial_value();
}
inline void ListenReportRequest::_internal_set_needs_initial_value(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.needs_initial_value_ = value;
}
inline void ListenReportRequest::set_needs_initial_value(bool value) {
  _internal_set_needs_initial_value(value);
  // @@protoc_insertion_point(field_set:duo.ListenReportRequest.needs_initial_value)
}

// -------------------------------------------------------------------

// ListenDesireRequest

// string thing = 1;
inline void ListenDesireRequest::clear_thing() {
  _impl_.thing_.ClearToEmpty();
}
inline const std::string& ListenDesireRequest::thing() const {
  // @@protoc_insertion_point(field_get:duo.ListenDesireRequest.thing)
  return _internal_thing();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListenDesireRequest::set_thing(ArgT0&& arg0, ArgT... args) {
 
 _impl_.thing_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:duo.ListenDesireRequest.thing)
}
inline std::string* ListenDesireRequest::mutable_thing() {
  std::string* _s = _internal_mutable_thing();
  // @@protoc_insertion_point(field_mutable:duo.ListenDesireRequest.thing)
  return _s;
}
inline const std::string& ListenDesireRequest::_internal_thing() const {
  return _impl_.thing_.Get();
}
inline void ListenDesireRequest::_internal_set_thing(const std::string& value) {
  
  _impl_.thing_.Set(value, GetArenaForAllocation());
}
inline std::string* ListenDesireRequest::_internal_mutable_thing() {
  
  return _impl_.thing_.Mutable(GetArenaForAllocation());
}
inline std::string* ListenDesireRequest::release_thing() {
  // @@protoc_insertion_point(field_release:duo.ListenDesireRequest.thing)
  return _impl_.thing_.Release();
}
inline void ListenDesireRequest::set_allocated_thing(std::string* thing) {
  if (thing != nullptr) {
    
  } else {
    
  }
  _impl_.thing_.SetAllocated(thing, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.thing_.IsDefault()) {
    _impl_.thing_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:duo.ListenDesireRequest.thing)
}

// repeated string filters = 2;
inline int ListenDesireRequest::_internal_filters_size() const {
  return _impl_.filters_.size();
}
inline int ListenDesireRequest::filters_size() const {
  return _internal_filters_size();
}
inline void ListenDesireRequest::clear_filters() {
  _impl_.filters_.Clear();
}
inline std::string* ListenDesireRequest::add_filters() {
  std::string* _s = _internal_add_filters();
  // @@protoc_insertion_point(field_add_mutable:duo.ListenDesireRequest.filters)
  return _s;
}
inline const std::string& ListenDesireRequest::_internal_filters(int index) const {
  return _impl_.filters_.Get(index);
}
inline const std::string& ListenDesireRequest::filters(int index) const {
  // @@protoc_insertion_point(field_get:duo.ListenDesireRequest.filters)
  return _internal_filters(index);
}
inline std::string* ListenDesireRequest::mutable_filters(int index) {
  // @@protoc_insertion_point(field_mutable:duo.ListenDesireRequest.filters)
  return _impl_.filters_.Mutable(index);
}
inline void ListenDesireRequest::set_filters(int index, const std::string& value) {
  _impl_.filters_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:duo.ListenDesireRequest.filters)
}
inline void ListenDesireRequest::set_filters(int index, std::string&& value) {
  _impl_.filters_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:duo.ListenDesireRequest.filters)
}
inline void ListenDesireRequest::set_filters(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.filters_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:duo.ListenDesireRequest.filters)
}
inline void ListenDesireRequest::set_filters(int index, const char* value, size_t size) {
  _impl_.filters_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:duo.ListenDesireRequest.filters)
}
inline std::string* ListenDesireRequest::_internal_add_filters() {
  return _impl_.filters_.Add();
}
inline void ListenDesireRequest::add_filters(const std::string& value) {
  _impl_.filters_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:duo.ListenDesireRequest.filters)
}
inline void ListenDesireRequest::add_filters(std::string&& value) {
  _impl_.filters_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:duo.ListenDesireRequest.filters)
}
inline void ListenDesireRequest::add_filters(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.filters_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:duo.ListenDesireRequest.filters)
}
inline void ListenDesireRequest::add_filters(const char* value, size_t size) {
  _impl_.filters_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:duo.ListenDesireRequest.filters)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ListenDesireRequest::filters() const {
  // @@protoc_insertion_point(field_list:duo.ListenDesireRequest.filters)
  return _impl_.filters_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ListenDesireRequest::mutable_filters() {
  // @@protoc_insertion_point(field_mutable_list:duo.ListenDesireRequest.filters)
  return &_impl_.filters_;
}

// optional string id = 3;
inline bool ListenDesireRequest::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ListenDesireRequest::has_id() const {
  return _internal_has_id();
}
inline void ListenDesireRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ListenDesireRequest::id() const {
  // @@protoc_insertion_point(field_get:duo.ListenDesireRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListenDesireRequest::set_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:duo.ListenDesireRequest.id)
}
inline std::string* ListenDesireRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:duo.ListenDesireRequest.id)
  return _s;
}
inline const std::string& ListenDesireRequest::_internal_id() const {
  return _impl_.id_.Get();
}
inline void ListenDesireRequest::_internal_set_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* ListenDesireRequest::_internal_mutable_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* ListenDesireRequest::release_id() {
  // @@protoc_insertion_point(field_release:duo.ListenDesireRequest.id)
  if (!_internal_has_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ListenDesireRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:duo.ListenDesireRequest.id)
}

// optional bool needs_initial_value = 4;
inline bool ListenDesireRequest::_internal_has_needs_initial_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ListenDesireRequest::has_needs_initial_value() const {
  return _internal_has_needs_initial_value();
}
inline void ListenDesireRequest::clear_needs_initial_value() {
  _impl_.needs_initial_value_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool ListenDesireRequest::_internal_needs_initial_value() const {
  return _impl_.needs_initial_value_;
}
inline bool ListenDesireRequest::needs_initial_value() const {
  // @@protoc_insertion_point(field_get:duo.ListenDesireRequest.needs_initial_value)
  return _internal_needs_initial_value();
}
inline void ListenDesireRequest::_internal_set_needs_initial_value(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.needs_initial_value_ = value;
}
inline void ListenDesireRequest::set_needs_initial_value(bool value) {
  _internal_set_needs_initial_value(value);
  // @@protoc_insertion_point(field_set:duo.ListenDesireRequest.needs_initial_value)
}

// -------------------------------------------------------------------

// ListenDeltaRequest

// string thing = 1;
inline void ListenDeltaRequest::clear_thing() {
  _impl_.thing_.ClearToEmpty();
}
inline const std::string& ListenDeltaRequest::thing() const {
  // @@protoc_insertion_point(field_get:duo.ListenDeltaRequest.thing)
  return _internal_thing();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListenDeltaRequest::set_thing(ArgT0&& arg0, ArgT... args) {
 
 _impl_.thing_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:duo.ListenDeltaRequest.thing)
}
inline std::string* ListenDeltaRequest::mutable_thing() {
  std::string* _s = _internal_mutable_thing();
  // @@protoc_insertion_point(field_mutable:duo.ListenDeltaRequest.thing)
  return _s;
}
inline const std::string& ListenDeltaRequest::_internal_thing() const {
  return _impl_.thing_.Get();
}
inline void ListenDeltaRequest::_internal_set_thing(const std::string& value) {
  
  _impl_.thing_.Set(value, GetArenaForAllocation());
}
inline std::string* ListenDeltaRequest::_internal_mutable_thing() {
  
  return _impl_.thing_.Mutable(GetArenaForAllocation());
}
inline std::string* ListenDeltaRequest::release_thing() {
  // @@protoc_insertion_point(field_release:duo.ListenDeltaRequest.thing)
  return _impl_.thing_.Release();
}
inline void ListenDeltaRequest::set_allocated_thing(std::string* thing) {
  if (thing != nullptr) {
    
  } else {
    
  }
  _impl_.thing_.SetAllocated(thing, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.thing_.IsDefault()) {
    _impl_.thing_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:duo.ListenDeltaRequest.thing)
}

// repeated string filters = 2;
inline int ListenDeltaRequest::_internal_filters_size() const {
  return _impl_.filters_.size();
}
inline int ListenDeltaRequest::filters_size() const {
  return _internal_filters_size();
}
inline void ListenDeltaRequest::clear_filters() {
  _impl_.filters_.Clear();
}
inline std::string* ListenDeltaRequest::add_filters() {
  std::string* _s = _internal_add_filters();
  // @@protoc_insertion_point(field_add_mutable:duo.ListenDeltaRequest.filters)
  return _s;
}
inline const std::string& ListenDeltaRequest::_internal_filters(int index) const {
  return _impl_.filters_.Get(index);
}
inline const std::string& ListenDeltaRequest::filters(int index) const {
  // @@protoc_insertion_point(field_get:duo.ListenDeltaRequest.filters)
  return _internal_filters(index);
}
inline std::string* ListenDeltaRequest::mutable_filters(int index) {
  // @@protoc_insertion_point(field_mutable:duo.ListenDeltaRequest.filters)
  return _impl_.filters_.Mutable(index);
}
inline void ListenDeltaRequest::set_filters(int index, const std::string& value) {
  _impl_.filters_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:duo.ListenDeltaRequest.filters)
}
inline void ListenDeltaRequest::set_filters(int index, std::string&& value) {
  _impl_.filters_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:duo.ListenDeltaRequest.filters)
}
inline void ListenDeltaRequest::set_filters(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.filters_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:duo.ListenDeltaRequest.filters)
}
inline void ListenDeltaRequest::set_filters(int index, const char* value, size_t size) {
  _impl_.filters_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:duo.ListenDeltaRequest.filters)
}
inline std::string* ListenDeltaRequest::_internal_add_filters() {
  return _impl_.filters_.Add();
}
inline void ListenDeltaRequest::add_filters(const std::string& value) {
  _impl_.filters_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:duo.ListenDeltaRequest.filters)
}
inline void ListenDeltaRequest::add_filters(std::string&& value) {
  _impl_.filters_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:duo.ListenDeltaRequest.filters)
}
inline void ListenDeltaRequest::add_filters(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.filters_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:duo.ListenDeltaRequest.filters)
}
inline void ListenDeltaRequest::add_filters(const char* value, size_t size) {
  _impl_.filters_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:duo.ListenDeltaRequest.filters)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ListenDeltaRequest::filters() const {
  // @@protoc_insertion_point(field_list:duo.ListenDeltaRequest.filters)
  return _impl_.filters_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ListenDeltaRequest::mutable_filters() {
  // @@protoc_insertion_point(field_mutable_list:duo.ListenDeltaRequest.filters)
  return &_impl_.filters_;
}

// optional string id = 3;
inline bool ListenDeltaRequest::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ListenDeltaRequest::has_id() const {
  return _internal_has_id();
}
inline void ListenDeltaRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ListenDeltaRequest::id() const {
  // @@protoc_insertion_point(field_get:duo.ListenDeltaRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListenDeltaRequest::set_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:duo.ListenDeltaRequest.id)
}
inline std::string* ListenDeltaRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:duo.ListenDeltaRequest.id)
  return _s;
}
inline const std::string& ListenDeltaRequest::_internal_id() const {
  return _impl_.id_.Get();
}
inline void ListenDeltaRequest::_internal_set_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* ListenDeltaRequest::_internal_mutable_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* ListenDeltaRequest::release_id() {
  // @@protoc_insertion_point(field_release:duo.ListenDeltaRequest.id)
  if (!_internal_has_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ListenDeltaRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:duo.ListenDeltaRequest.id)
}

// optional bool needs_initial_value = 4;
inline bool ListenDeltaRequest::_internal_has_needs_initial_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ListenDeltaRequest::has_needs_initial_value() const {
  return _internal_has_needs_initial_value();
}
inline void ListenDeltaRequest::clear_needs_initial_value() {
  _impl_.needs_initial_value_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool ListenDeltaRequest::_internal_needs_initial_value() const {
  return _impl_.needs_initial_value_;
}
inline bool ListenDeltaRequest::needs_initial_value() const {
  // @@protoc_insertion_point(field_get:duo.ListenDeltaRequest.needs_initial_value)
  return _internal_needs_initial_value();
}
inline void ListenDeltaRequest::_internal_set_needs_initial_value(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.needs_initial_value_ = value;
}
inline void ListenDeltaRequest::set_needs_initial_value(bool value) {
  _internal_set_needs_initial_value(value);
  // @@protoc_insertion_point(field_set:duo.ListenDeltaRequest.needs_initial_value)
}

// -------------------------------------------------------------------

// GetResponse

// .duo.StatusCode code = 1;
inline void GetResponse::clear_code() {
  _impl_.code_ = 0;
}
inline ::duo::StatusCode GetResponse::_internal_code() const {
  return static_cast< ::duo::StatusCode >(_impl_.code_);
}
inline ::duo::StatusCode GetResponse::code() const {
  // @@protoc_insertion_point(field_get:duo.GetResponse.code)
  return _internal_code();
}
inline void GetResponse::_internal_set_code(::duo::StatusCode value) {
  
  _impl_.code_ = value;
}
inline void GetResponse::set_code(::duo::StatusCode value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:duo.GetResponse.code)
}

// string request_id = 2;
inline void GetResponse::clear_request_id() {
  _impl_.request_id_.ClearToEmpty();
}
inline const std::string& GetResponse::request_id() const {
  // @@protoc_insertion_point(field_get:duo.GetResponse.request_id)
  return _internal_request_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetResponse::set_request_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.request_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:duo.GetResponse.request_id)
}
inline std::string* GetResponse::mutable_request_id() {
  std::string* _s = _internal_mutable_request_id();
  // @@protoc_insertion_point(field_mutable:duo.GetResponse.request_id)
  return _s;
}
inline const std::string& GetResponse::_internal_request_id() const {
  return _impl_.request_id_.Get();
}
inline void GetResponse::_internal_set_request_id(const std::string& value) {
  
  _impl_.request_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetResponse::_internal_mutable_request_id() {
  
  return _impl_.request_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetResponse::release_request_id() {
  // @@protoc_insertion_point(field_release:duo.GetResponse.request_id)
  return _impl_.request_id_.Release();
}
inline void GetResponse::set_allocated_request_id(std::string* request_id) {
  if (request_id != nullptr) {
    
  } else {
    
  }
  _impl_.request_id_.SetAllocated(request_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.request_id_.IsDefault()) {
    _impl_.request_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:duo.GetResponse.request_id)
}

// .google.protobuf.Value item = 3;
inline bool GetResponse::_internal_has_item() const {
  return this != internal_default_instance() && _impl_.item_ != nullptr;
}
inline bool GetResponse::has_item() const {
  return _internal_has_item();
}
inline const ::PROTOBUF_NAMESPACE_ID::Value& GetResponse::_internal_item() const {
  const ::PROTOBUF_NAMESPACE_ID::Value* p = _impl_.item_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Value&>(
      ::PROTOBUF_NAMESPACE_ID::_Value_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Value& GetResponse::item() const {
  // @@protoc_insertion_point(field_get:duo.GetResponse.item)
  return _internal_item();
}
inline void GetResponse::unsafe_arena_set_allocated_item(
    ::PROTOBUF_NAMESPACE_ID::Value* item) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.item_);
  }
  _impl_.item_ = item;
  if (item) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:duo.GetResponse.item)
}
inline ::PROTOBUF_NAMESPACE_ID::Value* GetResponse::release_item() {
  
  ::PROTOBUF_NAMESPACE_ID::Value* temp = _impl_.item_;
  _impl_.item_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Value* GetResponse::unsafe_arena_release_item() {
  // @@protoc_insertion_point(field_release:duo.GetResponse.item)
  
  ::PROTOBUF_NAMESPACE_ID::Value* temp = _impl_.item_;
  _impl_.item_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Value* GetResponse::_internal_mutable_item() {
  
  if (_impl_.item_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Value>(GetArenaForAllocation());
    _impl_.item_ = p;
  }
  return _impl_.item_;
}
inline ::PROTOBUF_NAMESPACE_ID::Value* GetResponse::mutable_item() {
  ::PROTOBUF_NAMESPACE_ID::Value* _msg = _internal_mutable_item();
  // @@protoc_insertion_point(field_mutable:duo.GetResponse.item)
  return _msg;
}
inline void GetResponse::set_allocated_item(::PROTOBUF_NAMESPACE_ID::Value* item) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.item_);
  }
  if (item) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(item));
    if (message_arena != submessage_arena) {
      item = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, item, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.item_ = item;
  // @@protoc_insertion_point(field_set_allocated:duo.GetResponse.item)
}

// -------------------------------------------------------------------

// PatchResponse

// .duo.StatusCode code = 1;
inline void PatchResponse::clear_code() {
  _impl_.code_ = 0;
}
inline ::duo::StatusCode PatchResponse::_internal_code() const {
  return static_cast< ::duo::StatusCode >(_impl_.code_);
}
inline ::duo::StatusCode PatchResponse::code() const {
  // @@protoc_insertion_point(field_get:duo.PatchResponse.code)
  return _internal_code();
}
inline void PatchResponse::_internal_set_code(::duo::StatusCode value) {
  
  _impl_.code_ = value;
}
inline void PatchResponse::set_code(::duo::StatusCode value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:duo.PatchResponse.code)
}

// string request_id = 2;
inline void PatchResponse::clear_request_id() {
  _impl_.request_id_.ClearToEmpty();
}
inline const std::string& PatchResponse::request_id() const {
  // @@protoc_insertion_point(field_get:duo.PatchResponse.request_id)
  return _internal_request_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PatchResponse::set_request_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.request_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:duo.PatchResponse.request_id)
}
inline std::string* PatchResponse::mutable_request_id() {
  std::string* _s = _internal_mutable_request_id();
  // @@protoc_insertion_point(field_mutable:duo.PatchResponse.request_id)
  return _s;
}
inline const std::string& PatchResponse::_internal_request_id() const {
  return _impl_.request_id_.Get();
}
inline void PatchResponse::_internal_set_request_id(const std::string& value) {
  
  _impl_.request_id_.Set(value, GetArenaForAllocation());
}
inline std::string* PatchResponse::_internal_mutable_request_id() {
  
  return _impl_.request_id_.Mutable(GetArenaForAllocation());
}
inline std::string* PatchResponse::release_request_id() {
  // @@protoc_insertion_point(field_release:duo.PatchResponse.request_id)
  return _impl_.request_id_.Release();
}
inline void PatchResponse::set_allocated_request_id(std::string* request_id) {
  if (request_id != nullptr) {
    
  } else {
    
  }
  _impl_.request_id_.SetAllocated(request_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.request_id_.IsDefault()) {
    _impl_.request_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:duo.PatchResponse.request_id)
}

// string message = 3;
inline void PatchResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& PatchResponse::message() const {
  // @@protoc_insertion_point(field_get:duo.PatchResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PatchResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:duo.PatchResponse.message)
}
inline std::string* PatchResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:duo.PatchResponse.message)
  return _s;
}
inline const std::string& PatchResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void PatchResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* PatchResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* PatchResponse::release_message() {
  // @@protoc_insertion_point(field_release:duo.PatchResponse.message)
  return _impl_.message_.Release();
}
inline void PatchResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:duo.PatchResponse.message)
}

// -------------------------------------------------------------------

// PatchAndWaitResponse

// bool completed = 1;
inline void PatchAndWaitResponse::clear_completed() {
  _impl_.completed_ = false;
}
inline bool PatchAndWaitResponse::_internal_completed() const {
  return _impl_.completed_;
}
inline bool PatchAndWaitResponse::completed() const {
  // @@protoc_insertion_point(field_get:duo.PatchAndWaitResponse.completed)
  return _internal_completed();
}
inline void PatchAndWaitResponse::_internal_set_completed(bool value) {
  
  _impl_.completed_ = value;
}
inline void PatchAndWaitResponse::set_completed(bool value) {
  _internal_set_completed(value);
  // @@protoc_insertion_point(field_set:duo.PatchAndWaitResponse.completed)
}

// .google.protobuf.Value delta = 2;
inline bool PatchAndWaitResponse::_internal_has_delta() const {
  return this != internal_default_instance() && _impl_.delta_ != nullptr;
}
inline bool PatchAndWaitResponse::has_delta() const {
  return _internal_has_delta();
}
inline const ::PROTOBUF_NAMESPACE_ID::Value& PatchAndWaitResponse::_internal_delta() const {
  const ::PROTOBUF_NAMESPACE_ID::Value* p = _impl_.delta_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Value&>(
      ::PROTOBUF_NAMESPACE_ID::_Value_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Value& PatchAndWaitResponse::delta() const {
  // @@protoc_insertion_point(field_get:duo.PatchAndWaitResponse.delta)
  return _internal_delta();
}
inline void PatchAndWaitResponse::unsafe_arena_set_allocated_delta(
    ::PROTOBUF_NAMESPACE_ID::Value* delta) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.delta_);
  }
  _impl_.delta_ = delta;
  if (delta) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:duo.PatchAndWaitResponse.delta)
}
inline ::PROTOBUF_NAMESPACE_ID::Value* PatchAndWaitResponse::release_delta() {
  
  ::PROTOBUF_NAMESPACE_ID::Value* temp = _impl_.delta_;
  _impl_.delta_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Value* PatchAndWaitResponse::unsafe_arena_release_delta() {
  // @@protoc_insertion_point(field_release:duo.PatchAndWaitResponse.delta)
  
  ::PROTOBUF_NAMESPACE_ID::Value* temp = _impl_.delta_;
  _impl_.delta_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Value* PatchAndWaitResponse::_internal_mutable_delta() {
  
  if (_impl_.delta_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Value>(GetArenaForAllocation());
    _impl_.delta_ = p;
  }
  return _impl_.delta_;
}
inline ::PROTOBUF_NAMESPACE_ID::Value* PatchAndWaitResponse::mutable_delta() {
  ::PROTOBUF_NAMESPACE_ID::Value* _msg = _internal_mutable_delta();
  // @@protoc_insertion_point(field_mutable:duo.PatchAndWaitResponse.delta)
  return _msg;
}
inline void PatchAndWaitResponse::set_allocated_delta(::PROTOBUF_NAMESPACE_ID::Value* delta) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.delta_);
  }
  if (delta) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(delta));
    if (message_arena != submessage_arena) {
      delta = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, delta, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.delta_ = delta;
  // @@protoc_insertion_point(field_set_allocated:duo.PatchAndWaitResponse.delta)
}

// -------------------------------------------------------------------

// DeleteResponse

// .duo.StatusCode code = 1;
inline void DeleteResponse::clear_code() {
  _impl_.code_ = 0;
}
inline ::duo::StatusCode DeleteResponse::_internal_code() const {
  return static_cast< ::duo::StatusCode >(_impl_.code_);
}
inline ::duo::StatusCode DeleteResponse::code() const {
  // @@protoc_insertion_point(field_get:duo.DeleteResponse.code)
  return _internal_code();
}
inline void DeleteResponse::_internal_set_code(::duo::StatusCode value) {
  
  _impl_.code_ = value;
}
inline void DeleteResponse::set_code(::duo::StatusCode value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:duo.DeleteResponse.code)
}

// string request_id = 2;
inline void DeleteResponse::clear_request_id() {
  _impl_.request_id_.ClearToEmpty();
}
inline const std::string& DeleteResponse::request_id() const {
  // @@protoc_insertion_point(field_get:duo.DeleteResponse.request_id)
  return _internal_request_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteResponse::set_request_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.request_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:duo.DeleteResponse.request_id)
}
inline std::string* DeleteResponse::mutable_request_id() {
  std::string* _s = _internal_mutable_request_id();
  // @@protoc_insertion_point(field_mutable:duo.DeleteResponse.request_id)
  return _s;
}
inline const std::string& DeleteResponse::_internal_request_id() const {
  return _impl_.request_id_.Get();
}
inline void DeleteResponse::_internal_set_request_id(const std::string& value) {
  
  _impl_.request_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteResponse::_internal_mutable_request_id() {
  
  return _impl_.request_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteResponse::release_request_id() {
  // @@protoc_insertion_point(field_release:duo.DeleteResponse.request_id)
  return _impl_.request_id_.Release();
}
inline void DeleteResponse::set_allocated_request_id(std::string* request_id) {
  if (request_id != nullptr) {
    
  } else {
    
  }
  _impl_.request_id_.SetAllocated(request_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.request_id_.IsDefault()) {
    _impl_.request_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:duo.DeleteResponse.request_id)
}

// string message = 3;
inline void DeleteResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& DeleteResponse::message() const {
  // @@protoc_insertion_point(field_get:duo.DeleteResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:duo.DeleteResponse.message)
}
inline std::string* DeleteResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:duo.DeleteResponse.message)
  return _s;
}
inline const std::string& DeleteResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void DeleteResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteResponse::release_message() {
  // @@protoc_insertion_point(field_release:duo.DeleteResponse.message)
  return _impl_.message_.Release();
}
inline void DeleteResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:duo.DeleteResponse.message)
}

// -------------------------------------------------------------------

// UploadResponse

// .duo.StatusCode code = 1;
inline void UploadResponse::clear_code() {
  _impl_.code_ = 0;
}
inline ::duo::StatusCode UploadResponse::_internal_code() const {
  return static_cast< ::duo::StatusCode >(_impl_.code_);
}
inline ::duo::StatusCode UploadResponse::code() const {
  // @@protoc_insertion_point(field_get:duo.UploadResponse.code)
  return _internal_code();
}
inline void UploadResponse::_internal_set_code(::duo::StatusCode value) {
  
  _impl_.code_ = value;
}
inline void UploadResponse::set_code(::duo::StatusCode value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:duo.UploadResponse.code)
}

// string request_id = 2;
inline void UploadResponse::clear_request_id() {
  _impl_.request_id_.ClearToEmpty();
}
inline const std::string& UploadResponse::request_id() const {
  // @@protoc_insertion_point(field_get:duo.UploadResponse.request_id)
  return _internal_request_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UploadResponse::set_request_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.request_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:duo.UploadResponse.request_id)
}
inline std::string* UploadResponse::mutable_request_id() {
  std::string* _s = _internal_mutable_request_id();
  // @@protoc_insertion_point(field_mutable:duo.UploadResponse.request_id)
  return _s;
}
inline const std::string& UploadResponse::_internal_request_id() const {
  return _impl_.request_id_.Get();
}
inline void UploadResponse::_internal_set_request_id(const std::string& value) {
  
  _impl_.request_id_.Set(value, GetArenaForAllocation());
}
inline std::string* UploadResponse::_internal_mutable_request_id() {
  
  return _impl_.request_id_.Mutable(GetArenaForAllocation());
}
inline std::string* UploadResponse::release_request_id() {
  // @@protoc_insertion_point(field_release:duo.UploadResponse.request_id)
  return _impl_.request_id_.Release();
}
inline void UploadResponse::set_allocated_request_id(std::string* request_id) {
  if (request_id != nullptr) {
    
  } else {
    
  }
  _impl_.request_id_.SetAllocated(request_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.request_id_.IsDefault()) {
    _impl_.request_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:duo.UploadResponse.request_id)
}

// string message = 3;
inline void UploadResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& UploadResponse::message() const {
  // @@protoc_insertion_point(field_get:duo.UploadResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UploadResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:duo.UploadResponse.message)
}
inline std::string* UploadResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:duo.UploadResponse.message)
  return _s;
}
inline const std::string& UploadResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void UploadResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* UploadResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* UploadResponse::release_message() {
  // @@protoc_insertion_point(field_release:duo.UploadResponse.message)
  return _impl_.message_.Release();
}
inline void UploadResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:duo.UploadResponse.message)
}

// -------------------------------------------------------------------

// GetThingListResponse

// .duo.StatusCode code = 1;
inline void GetThingListResponse::clear_code() {
  _impl_.code_ = 0;
}
inline ::duo::StatusCode GetThingListResponse::_internal_code() const {
  return static_cast< ::duo::StatusCode >(_impl_.code_);
}
inline ::duo::StatusCode GetThingListResponse::code() const {
  // @@protoc_insertion_point(field_get:duo.GetThingListResponse.code)
  return _internal_code();
}
inline void GetThingListResponse::_internal_set_code(::duo::StatusCode value) {
  
  _impl_.code_ = value;
}
inline void GetThingListResponse::set_code(::duo::StatusCode value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:duo.GetThingListResponse.code)
}

// string request_id = 2;
inline void GetThingListResponse::clear_request_id() {
  _impl_.request_id_.ClearToEmpty();
}
inline const std::string& GetThingListResponse::request_id() const {
  // @@protoc_insertion_point(field_get:duo.GetThingListResponse.request_id)
  return _internal_request_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetThingListResponse::set_request_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.request_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:duo.GetThingListResponse.request_id)
}
inline std::string* GetThingListResponse::mutable_request_id() {
  std::string* _s = _internal_mutable_request_id();
  // @@protoc_insertion_point(field_mutable:duo.GetThingListResponse.request_id)
  return _s;
}
inline const std::string& GetThingListResponse::_internal_request_id() const {
  return _impl_.request_id_.Get();
}
inline void GetThingListResponse::_internal_set_request_id(const std::string& value) {
  
  _impl_.request_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetThingListResponse::_internal_mutable_request_id() {
  
  return _impl_.request_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetThingListResponse::release_request_id() {
  // @@protoc_insertion_point(field_release:duo.GetThingListResponse.request_id)
  return _impl_.request_id_.Release();
}
inline void GetThingListResponse::set_allocated_request_id(std::string* request_id) {
  if (request_id != nullptr) {
    
  } else {
    
  }
  _impl_.request_id_.SetAllocated(request_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.request_id_.IsDefault()) {
    _impl_.request_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:duo.GetThingListResponse.request_id)
}

// repeated string thing_names = 3;
inline int GetThingListResponse::_internal_thing_names_size() const {
  return _impl_.thing_names_.size();
}
inline int GetThingListResponse::thing_names_size() const {
  return _internal_thing_names_size();
}
inline void GetThingListResponse::clear_thing_names() {
  _impl_.thing_names_.Clear();
}
inline std::string* GetThingListResponse::add_thing_names() {
  std::string* _s = _internal_add_thing_names();
  // @@protoc_insertion_point(field_add_mutable:duo.GetThingListResponse.thing_names)
  return _s;
}
inline const std::string& GetThingListResponse::_internal_thing_names(int index) const {
  return _impl_.thing_names_.Get(index);
}
inline const std::string& GetThingListResponse::thing_names(int index) const {
  // @@protoc_insertion_point(field_get:duo.GetThingListResponse.thing_names)
  return _internal_thing_names(index);
}
inline std::string* GetThingListResponse::mutable_thing_names(int index) {
  // @@protoc_insertion_point(field_mutable:duo.GetThingListResponse.thing_names)
  return _impl_.thing_names_.Mutable(index);
}
inline void GetThingListResponse::set_thing_names(int index, const std::string& value) {
  _impl_.thing_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:duo.GetThingListResponse.thing_names)
}
inline void GetThingListResponse::set_thing_names(int index, std::string&& value) {
  _impl_.thing_names_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:duo.GetThingListResponse.thing_names)
}
inline void GetThingListResponse::set_thing_names(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.thing_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:duo.GetThingListResponse.thing_names)
}
inline void GetThingListResponse::set_thing_names(int index, const char* value, size_t size) {
  _impl_.thing_names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:duo.GetThingListResponse.thing_names)
}
inline std::string* GetThingListResponse::_internal_add_thing_names() {
  return _impl_.thing_names_.Add();
}
inline void GetThingListResponse::add_thing_names(const std::string& value) {
  _impl_.thing_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:duo.GetThingListResponse.thing_names)
}
inline void GetThingListResponse::add_thing_names(std::string&& value) {
  _impl_.thing_names_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:duo.GetThingListResponse.thing_names)
}
inline void GetThingListResponse::add_thing_names(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.thing_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:duo.GetThingListResponse.thing_names)
}
inline void GetThingListResponse::add_thing_names(const char* value, size_t size) {
  _impl_.thing_names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:duo.GetThingListResponse.thing_names)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetThingListResponse::thing_names() const {
  // @@protoc_insertion_point(field_list:duo.GetThingListResponse.thing_names)
  return _impl_.thing_names_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetThingListResponse::mutable_thing_names() {
  // @@protoc_insertion_point(field_mutable_list:duo.GetThingListResponse.thing_names)
  return &_impl_.thing_names_;
}

// uint64 total_count = 4;
inline void GetThingListResponse::clear_total_count() {
  _impl_.total_count_ = uint64_t{0u};
}
inline uint64_t GetThingListResponse::_internal_total_count() const {
  return _impl_.total_count_;
}
inline uint64_t GetThingListResponse::total_count() const {
  // @@protoc_insertion_point(field_get:duo.GetThingListResponse.total_count)
  return _internal_total_count();
}
inline void GetThingListResponse::_internal_set_total_count(uint64_t value) {
  
  _impl_.total_count_ = value;
}
inline void GetThingListResponse::set_total_count(uint64_t value) {
  _internal_set_total_count(value);
  // @@protoc_insertion_point(field_set:duo.GetThingListResponse.total_count)
}

// optional string next_token = 5;
inline bool GetThingListResponse::_internal_has_next_token() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GetThingListResponse::has_next_token() const {
  return _internal_has_next_token();
}
inline void GetThingListResponse::clear_next_token() {
  _impl_.next_token_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GetThingListResponse::next_token() const {
  // @@protoc_insertion_point(field_get:duo.GetThingListResponse.next_token)
  return _internal_next_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetThingListResponse::set_next_token(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.next_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:duo.GetThingListResponse.next_token)
}
inline std::string* GetThingListResponse::mutable_next_token() {
  std::string* _s = _internal_mutable_next_token();
  // @@protoc_insertion_point(field_mutable:duo.GetThingListResponse.next_token)
  return _s;
}
inline const std::string& GetThingListResponse::_internal_next_token() const {
  return _impl_.next_token_.Get();
}
inline void GetThingListResponse::_internal_set_next_token(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.next_token_.Set(value, GetArenaForAllocation());
}
inline std::string* GetThingListResponse::_internal_mutable_next_token() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.next_token_.Mutable(GetArenaForAllocation());
}
inline std::string* GetThingListResponse::release_next_token() {
  // @@protoc_insertion_point(field_release:duo.GetThingListResponse.next_token)
  if (!_internal_has_next_token()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.next_token_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.next_token_.IsDefault()) {
    _impl_.next_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GetThingListResponse::set_allocated_next_token(std::string* next_token) {
  if (next_token != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.next_token_.SetAllocated(next_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.next_token_.IsDefault()) {
    _impl_.next_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:duo.GetThingListResponse.next_token)
}

// -------------------------------------------------------------------

// ListenResponse

// .google.protobuf.ListValue items = 1;
inline bool ListenResponse::_internal_has_items() const {
  return this != internal_default_instance() && _impl_.items_ != nullptr;
}
inline bool ListenResponse::has_items() const {
  return _internal_has_items();
}
inline const ::PROTOBUF_NAMESPACE_ID::ListValue& ListenResponse::_internal_items() const {
  const ::PROTOBUF_NAMESPACE_ID::ListValue* p = _impl_.items_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::ListValue&>(
      ::PROTOBUF_NAMESPACE_ID::_ListValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::ListValue& ListenResponse::items() const {
  // @@protoc_insertion_point(field_get:duo.ListenResponse.items)
  return _internal_items();
}
inline void ListenResponse::unsafe_arena_set_allocated_items(
    ::PROTOBUF_NAMESPACE_ID::ListValue* items) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.items_);
  }
  _impl_.items_ = items;
  if (items) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:duo.ListenResponse.items)
}
inline ::PROTOBUF_NAMESPACE_ID::ListValue* ListenResponse::release_items() {
  
  ::PROTOBUF_NAMESPACE_ID::ListValue* temp = _impl_.items_;
  _impl_.items_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::ListValue* ListenResponse::unsafe_arena_release_items() {
  // @@protoc_insertion_point(field_release:duo.ListenResponse.items)
  
  ::PROTOBUF_NAMESPACE_ID::ListValue* temp = _impl_.items_;
  _impl_.items_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::ListValue* ListenResponse::_internal_mutable_items() {
  
  if (_impl_.items_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::ListValue>(GetArenaForAllocation());
    _impl_.items_ = p;
  }
  return _impl_.items_;
}
inline ::PROTOBUF_NAMESPACE_ID::ListValue* ListenResponse::mutable_items() {
  ::PROTOBUF_NAMESPACE_ID::ListValue* _msg = _internal_mutable_items();
  // @@protoc_insertion_point(field_mutable:duo.ListenResponse.items)
  return _msg;
}
inline void ListenResponse::set_allocated_items(::PROTOBUF_NAMESPACE_ID::ListValue* items) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.items_);
  }
  if (items) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(items));
    if (message_arena != submessage_arena) {
      items = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, items, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.items_ = items;
  // @@protoc_insertion_point(field_set_allocated:duo.ListenResponse.items)
}

// optional .google.protobuf.Struct meta = 2;
inline bool ListenResponse::_internal_has_meta() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.meta_ != nullptr);
  return value;
}
inline bool ListenResponse::has_meta() const {
  return _internal_has_meta();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& ListenResponse::_internal_meta() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.meta_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& ListenResponse::meta() const {
  // @@protoc_insertion_point(field_get:duo.ListenResponse.meta)
  return _internal_meta();
}
inline void ListenResponse::unsafe_arena_set_allocated_meta(
    ::PROTOBUF_NAMESPACE_ID::Struct* meta) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.meta_);
  }
  _impl_.meta_ = meta;
  if (meta) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:duo.ListenResponse.meta)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ListenResponse::release_meta() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.meta_;
  _impl_.meta_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ListenResponse::unsafe_arena_release_meta() {
  // @@protoc_insertion_point(field_release:duo.ListenResponse.meta)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.meta_;
  _impl_.meta_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ListenResponse::_internal_mutable_meta() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.meta_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.meta_ = p;
  }
  return _impl_.meta_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ListenResponse::mutable_meta() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_meta();
  // @@protoc_insertion_point(field_mutable:duo.ListenResponse.meta)
  return _msg;
}
inline void ListenResponse::set_allocated_meta(::PROTOBUF_NAMESPACE_ID::Struct* meta) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.meta_);
  }
  if (meta) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(meta));
    if (message_arena != submessage_arena) {
      meta = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, meta, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.meta_ = meta;
  // @@protoc_insertion_point(field_set_allocated:duo.ListenResponse.meta)
}

// -------------------------------------------------------------------

// PingRequest

// int32 seed = 1;
inline void PingRequest::clear_seed() {
  _impl_.seed_ = 0;
}
inline int32_t PingRequest::_internal_seed() const {
  return _impl_.seed_;
}
inline int32_t PingRequest::seed() const {
  // @@protoc_insertion_point(field_get:duo.PingRequest.seed)
  return _internal_seed();
}
inline void PingRequest::_internal_set_seed(int32_t value) {
  
  _impl_.seed_ = value;
}
inline void PingRequest::set_seed(int32_t value) {
  _internal_set_seed(value);
  // @@protoc_insertion_point(field_set:duo.PingRequest.seed)
}

// -------------------------------------------------------------------

// PingResponse

// int32 seed = 1;
inline void PingResponse::clear_seed() {
  _impl_.seed_ = 0;
}
inline int32_t PingResponse::_internal_seed() const {
  return _impl_.seed_;
}
inline int32_t PingResponse::seed() const {
  // @@protoc_insertion_point(field_get:duo.PingResponse.seed)
  return _internal_seed();
}
inline void PingResponse::_internal_set_seed(int32_t value) {
  
  _impl_.seed_ = value;
}
inline void PingResponse::set_seed(int32_t value) {
  _internal_set_seed(value);
  // @@protoc_insertion_point(field_set:duo.PingResponse.seed)
}

// -------------------------------------------------------------------

// GetNextJobRequest

// string thing = 1;
inline void GetNextJobRequest::clear_thing() {
  _impl_.thing_.ClearToEmpty();
}
inline const std::string& GetNextJobRequest::thing() const {
  // @@protoc_insertion_point(field_get:duo.GetNextJobRequest.thing)
  return _internal_thing();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetNextJobRequest::set_thing(ArgT0&& arg0, ArgT... args) {
 
 _impl_.thing_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:duo.GetNextJobRequest.thing)
}
inline std::string* GetNextJobRequest::mutable_thing() {
  std::string* _s = _internal_mutable_thing();
  // @@protoc_insertion_point(field_mutable:duo.GetNextJobRequest.thing)
  return _s;
}
inline const std::string& GetNextJobRequest::_internal_thing() const {
  return _impl_.thing_.Get();
}
inline void GetNextJobRequest::_internal_set_thing(const std::string& value) {
  
  _impl_.thing_.Set(value, GetArenaForAllocation());
}
inline std::string* GetNextJobRequest::_internal_mutable_thing() {
  
  return _impl_.thing_.Mutable(GetArenaForAllocation());
}
inline std::string* GetNextJobRequest::release_thing() {
  // @@protoc_insertion_point(field_release:duo.GetNextJobRequest.thing)
  return _impl_.thing_.Release();
}
inline void GetNextJobRequest::set_allocated_thing(std::string* thing) {
  if (thing != nullptr) {
    
  } else {
    
  }
  _impl_.thing_.SetAllocated(thing, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.thing_.IsDefault()) {
    _impl_.thing_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:duo.GetNextJobRequest.thing)
}

// -------------------------------------------------------------------

// GetJobRequest

// string thing = 1;
inline void GetJobRequest::clear_thing() {
  _impl_.thing_.ClearToEmpty();
}
inline const std::string& GetJobRequest::thing() const {
  // @@protoc_insertion_point(field_get:duo.GetJobRequest.thing)
  return _internal_thing();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetJobRequest::set_thing(ArgT0&& arg0, ArgT... args) {
 
 _impl_.thing_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:duo.GetJobRequest.thing)
}
inline std::string* GetJobRequest::mutable_thing() {
  std::string* _s = _internal_mutable_thing();
  // @@protoc_insertion_point(field_mutable:duo.GetJobRequest.thing)
  return _s;
}
inline const std::string& GetJobRequest::_internal_thing() const {
  return _impl_.thing_.Get();
}
inline void GetJobRequest::_internal_set_thing(const std::string& value) {
  
  _impl_.thing_.Set(value, GetArenaForAllocation());
}
inline std::string* GetJobRequest::_internal_mutable_thing() {
  
  return _impl_.thing_.Mutable(GetArenaForAllocation());
}
inline std::string* GetJobRequest::release_thing() {
  // @@protoc_insertion_point(field_release:duo.GetJobRequest.thing)
  return _impl_.thing_.Release();
}
inline void GetJobRequest::set_allocated_thing(std::string* thing) {
  if (thing != nullptr) {
    
  } else {
    
  }
  _impl_.thing_.SetAllocated(thing, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.thing_.IsDefault()) {
    _impl_.thing_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:duo.GetJobRequest.thing)
}

// string job_id = 2;
inline void GetJobRequest::clear_job_id() {
  _impl_.job_id_.ClearToEmpty();
}
inline const std::string& GetJobRequest::job_id() const {
  // @@protoc_insertion_point(field_get:duo.GetJobRequest.job_id)
  return _internal_job_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetJobRequest::set_job_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.job_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:duo.GetJobRequest.job_id)
}
inline std::string* GetJobRequest::mutable_job_id() {
  std::string* _s = _internal_mutable_job_id();
  // @@protoc_insertion_point(field_mutable:duo.GetJobRequest.job_id)
  return _s;
}
inline const std::string& GetJobRequest::_internal_job_id() const {
  return _impl_.job_id_.Get();
}
inline void GetJobRequest::_internal_set_job_id(const std::string& value) {
  
  _impl_.job_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetJobRequest::_internal_mutable_job_id() {
  
  return _impl_.job_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetJobRequest::release_job_id() {
  // @@protoc_insertion_point(field_release:duo.GetJobRequest.job_id)
  return _impl_.job_id_.Release();
}
inline void GetJobRequest::set_allocated_job_id(std::string* job_id) {
  if (job_id != nullptr) {
    
  } else {
    
  }
  _impl_.job_id_.SetAllocated(job_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.job_id_.IsDefault()) {
    _impl_.job_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:duo.GetJobRequest.job_id)
}

// -------------------------------------------------------------------

// GetUnfinishedJobsRequest

// string thing = 1;
inline void GetUnfinishedJobsRequest::clear_thing() {
  _impl_.thing_.ClearToEmpty();
}
inline const std::string& GetUnfinishedJobsRequest::thing() const {
  // @@protoc_insertion_point(field_get:duo.GetUnfinishedJobsRequest.thing)
  return _internal_thing();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetUnfinishedJobsRequest::set_thing(ArgT0&& arg0, ArgT... args) {
 
 _impl_.thing_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:duo.GetUnfinishedJobsRequest.thing)
}
inline std::string* GetUnfinishedJobsRequest::mutable_thing() {
  std::string* _s = _internal_mutable_thing();
  // @@protoc_insertion_point(field_mutable:duo.GetUnfinishedJobsRequest.thing)
  return _s;
}
inline const std::string& GetUnfinishedJobsRequest::_internal_thing() const {
  return _impl_.thing_.Get();
}
inline void GetUnfinishedJobsRequest::_internal_set_thing(const std::string& value) {
  
  _impl_.thing_.Set(value, GetArenaForAllocation());
}
inline std::string* GetUnfinishedJobsRequest::_internal_mutable_thing() {
  
  return _impl_.thing_.Mutable(GetArenaForAllocation());
}
inline std::string* GetUnfinishedJobsRequest::release_thing() {
  // @@protoc_insertion_point(field_release:duo.GetUnfinishedJobsRequest.thing)
  return _impl_.thing_.Release();
}
inline void GetUnfinishedJobsRequest::set_allocated_thing(std::string* thing) {
  if (thing != nullptr) {
    
  } else {
    
  }
  _impl_.thing_.SetAllocated(thing, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.thing_.IsDefault()) {
    _impl_.thing_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:duo.GetUnfinishedJobsRequest.thing)
}

// -------------------------------------------------------------------

// GetFinishedJobsRequest

// string thing = 1;
inline void GetFinishedJobsRequest::clear_thing() {
  _impl_.thing_.ClearToEmpty();
}
inline const std::string& GetFinishedJobsRequest::thing() const {
  // @@protoc_insertion_point(field_get:duo.GetFinishedJobsRequest.thing)
  return _internal_thing();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetFinishedJobsRequest::set_thing(ArgT0&& arg0, ArgT... args) {
 
 _impl_.thing_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:duo.GetFinishedJobsRequest.thing)
}
inline std::string* GetFinishedJobsRequest::mutable_thing() {
  std::string* _s = _internal_mutable_thing();
  // @@protoc_insertion_point(field_mutable:duo.GetFinishedJobsRequest.thing)
  return _s;
}
inline const std::string& GetFinishedJobsRequest::_internal_thing() const {
  return _impl_.thing_.Get();
}
inline void GetFinishedJobsRequest::_internal_set_thing(const std::string& value) {
  
  _impl_.thing_.Set(value, GetArenaForAllocation());
}
inline std::string* GetFinishedJobsRequest::_internal_mutable_thing() {
  
  return _impl_.thing_.Mutable(GetArenaForAllocation());
}
inline std::string* GetFinishedJobsRequest::release_thing() {
  // @@protoc_insertion_point(field_release:duo.GetFinishedJobsRequest.thing)
  return _impl_.thing_.Release();
}
inline void GetFinishedJobsRequest::set_allocated_thing(std::string* thing) {
  if (thing != nullptr) {
    
  } else {
    
  }
  _impl_.thing_.SetAllocated(thing, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.thing_.IsDefault()) {
    _impl_.thing_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:duo.GetFinishedJobsRequest.thing)
}

// -------------------------------------------------------------------

// CreateJobRequest

// string thing = 1;
inline void CreateJobRequest::clear_thing() {
  _impl_.thing_.ClearToEmpty();
}
inline const std::string& CreateJobRequest::thing() const {
  // @@protoc_insertion_point(field_get:duo.CreateJobRequest.thing)
  return _internal_thing();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateJobRequest::set_thing(ArgT0&& arg0, ArgT... args) {
 
 _impl_.thing_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:duo.CreateJobRequest.thing)
}
inline std::string* CreateJobRequest::mutable_thing() {
  std::string* _s = _internal_mutable_thing();
  // @@protoc_insertion_point(field_mutable:duo.CreateJobRequest.thing)
  return _s;
}
inline const std::string& CreateJobRequest::_internal_thing() const {
  return _impl_.thing_.Get();
}
inline void CreateJobRequest::_internal_set_thing(const std::string& value) {
  
  _impl_.thing_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateJobRequest::_internal_mutable_thing() {
  
  return _impl_.thing_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateJobRequest::release_thing() {
  // @@protoc_insertion_point(field_release:duo.CreateJobRequest.thing)
  return _impl_.thing_.Release();
}
inline void CreateJobRequest::set_allocated_thing(std::string* thing) {
  if (thing != nullptr) {
    
  } else {
    
  }
  _impl_.thing_.SetAllocated(thing, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.thing_.IsDefault()) {
    _impl_.thing_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:duo.CreateJobRequest.thing)
}

// .google.protobuf.Struct document = 2;
inline bool CreateJobRequest::_internal_has_document() const {
  return this != internal_default_instance() && _impl_.document_ != nullptr;
}
inline bool CreateJobRequest::has_document() const {
  return _internal_has_document();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& CreateJobRequest::_internal_document() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.document_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& CreateJobRequest::document() const {
  // @@protoc_insertion_point(field_get:duo.CreateJobRequest.document)
  return _internal_document();
}
inline void CreateJobRequest::unsafe_arena_set_allocated_document(
    ::PROTOBUF_NAMESPACE_ID::Struct* document) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.document_);
  }
  _impl_.document_ = document;
  if (document) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:duo.CreateJobRequest.document)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* CreateJobRequest::release_document() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.document_;
  _impl_.document_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* CreateJobRequest::unsafe_arena_release_document() {
  // @@protoc_insertion_point(field_release:duo.CreateJobRequest.document)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.document_;
  _impl_.document_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* CreateJobRequest::_internal_mutable_document() {
  
  if (_impl_.document_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.document_ = p;
  }
  return _impl_.document_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* CreateJobRequest::mutable_document() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_document();
  // @@protoc_insertion_point(field_mutable:duo.CreateJobRequest.document)
  return _msg;
}
inline void CreateJobRequest::set_allocated_document(::PROTOBUF_NAMESPACE_ID::Struct* document) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.document_);
  }
  if (document) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(document));
    if (message_arena != submessage_arena) {
      document = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, document, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.document_ = document;
  // @@protoc_insertion_point(field_set_allocated:duo.CreateJobRequest.document)
}

// -------------------------------------------------------------------

// UpdateJobRequest

// string thing = 1;
inline void UpdateJobRequest::clear_thing() {
  _impl_.thing_.ClearToEmpty();
}
inline const std::string& UpdateJobRequest::thing() const {
  // @@protoc_insertion_point(field_get:duo.UpdateJobRequest.thing)
  return _internal_thing();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateJobRequest::set_thing(ArgT0&& arg0, ArgT... args) {
 
 _impl_.thing_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:duo.UpdateJobRequest.thing)
}
inline std::string* UpdateJobRequest::mutable_thing() {
  std::string* _s = _internal_mutable_thing();
  // @@protoc_insertion_point(field_mutable:duo.UpdateJobRequest.thing)
  return _s;
}
inline const std::string& UpdateJobRequest::_internal_thing() const {
  return _impl_.thing_.Get();
}
inline void UpdateJobRequest::_internal_set_thing(const std::string& value) {
  
  _impl_.thing_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateJobRequest::_internal_mutable_thing() {
  
  return _impl_.thing_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateJobRequest::release_thing() {
  // @@protoc_insertion_point(field_release:duo.UpdateJobRequest.thing)
  return _impl_.thing_.Release();
}
inline void UpdateJobRequest::set_allocated_thing(std::string* thing) {
  if (thing != nullptr) {
    
  } else {
    
  }
  _impl_.thing_.SetAllocated(thing, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.thing_.IsDefault()) {
    _impl_.thing_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:duo.UpdateJobRequest.thing)
}

// string job_id = 2;
inline void UpdateJobRequest::clear_job_id() {
  _impl_.job_id_.ClearToEmpty();
}
inline const std::string& UpdateJobRequest::job_id() const {
  // @@protoc_insertion_point(field_get:duo.UpdateJobRequest.job_id)
  return _internal_job_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateJobRequest::set_job_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.job_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:duo.UpdateJobRequest.job_id)
}
inline std::string* UpdateJobRequest::mutable_job_id() {
  std::string* _s = _internal_mutable_job_id();
  // @@protoc_insertion_point(field_mutable:duo.UpdateJobRequest.job_id)
  return _s;
}
inline const std::string& UpdateJobRequest::_internal_job_id() const {
  return _impl_.job_id_.Get();
}
inline void UpdateJobRequest::_internal_set_job_id(const std::string& value) {
  
  _impl_.job_id_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateJobRequest::_internal_mutable_job_id() {
  
  return _impl_.job_id_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateJobRequest::release_job_id() {
  // @@protoc_insertion_point(field_release:duo.UpdateJobRequest.job_id)
  return _impl_.job_id_.Release();
}
inline void UpdateJobRequest::set_allocated_job_id(std::string* job_id) {
  if (job_id != nullptr) {
    
  } else {
    
  }
  _impl_.job_id_.SetAllocated(job_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.job_id_.IsDefault()) {
    _impl_.job_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:duo.UpdateJobRequest.job_id)
}

// optional .duo.JobStatus status = 3;
inline bool UpdateJobRequest::_internal_has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UpdateJobRequest::has_status() const {
  return _internal_has_status();
}
inline void UpdateJobRequest::clear_status() {
  _impl_.status_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::duo::JobStatus UpdateJobRequest::_internal_status() const {
  return static_cast< ::duo::JobStatus >(_impl_.status_);
}
inline ::duo::JobStatus UpdateJobRequest::status() const {
  // @@protoc_insertion_point(field_get:duo.UpdateJobRequest.status)
  return _internal_status();
}
inline void UpdateJobRequest::_internal_set_status(::duo::JobStatus value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.status_ = value;
}
inline void UpdateJobRequest::set_status(::duo::JobStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:duo.UpdateJobRequest.status)
}

// optional uint32 progress = 4;
inline bool UpdateJobRequest::_internal_has_progress() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool UpdateJobRequest::has_progress() const {
  return _internal_has_progress();
}
inline void UpdateJobRequest::clear_progress() {
  _impl_.progress_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t UpdateJobRequest::_internal_progress() const {
  return _impl_.progress_;
}
inline uint32_t UpdateJobRequest::progress() const {
  // @@protoc_insertion_point(field_get:duo.UpdateJobRequest.progress)
  return _internal_progress();
}
inline void UpdateJobRequest::_internal_set_progress(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.progress_ = value;
}
inline void UpdateJobRequest::set_progress(uint32_t value) {
  _internal_set_progress(value);
  // @@protoc_insertion_point(field_set:duo.UpdateJobRequest.progress)
}

// optional string response = 5;
inline bool UpdateJobRequest::_internal_has_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UpdateJobRequest::has_response() const {
  return _internal_has_response();
}
inline void UpdateJobRequest::clear_response() {
  _impl_.response_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UpdateJobRequest::response() const {
  // @@protoc_insertion_point(field_get:duo.UpdateJobRequest.response)
  return _internal_response();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateJobRequest::set_response(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.response_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:duo.UpdateJobRequest.response)
}
inline std::string* UpdateJobRequest::mutable_response() {
  std::string* _s = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:duo.UpdateJobRequest.response)
  return _s;
}
inline const std::string& UpdateJobRequest::_internal_response() const {
  return _impl_.response_.Get();
}
inline void UpdateJobRequest::_internal_set_response(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.response_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateJobRequest::_internal_mutable_response() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.response_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateJobRequest::release_response() {
  // @@protoc_insertion_point(field_release:duo.UpdateJobRequest.response)
  if (!_internal_has_response()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.response_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.response_.IsDefault()) {
    _impl_.response_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UpdateJobRequest::set_allocated_response(std::string* response) {
  if (response != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.response_.SetAllocated(response, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.response_.IsDefault()) {
    _impl_.response_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:duo.UpdateJobRequest.response)
}

// -------------------------------------------------------------------

// DeleteFinishedJobsRequest

// string thing = 1;
inline void DeleteFinishedJobsRequest::clear_thing() {
  _impl_.thing_.ClearToEmpty();
}
inline const std::string& DeleteFinishedJobsRequest::thing() const {
  // @@protoc_insertion_point(field_get:duo.DeleteFinishedJobsRequest.thing)
  return _internal_thing();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteFinishedJobsRequest::set_thing(ArgT0&& arg0, ArgT... args) {
 
 _impl_.thing_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:duo.DeleteFinishedJobsRequest.thing)
}
inline std::string* DeleteFinishedJobsRequest::mutable_thing() {
  std::string* _s = _internal_mutable_thing();
  // @@protoc_insertion_point(field_mutable:duo.DeleteFinishedJobsRequest.thing)
  return _s;
}
inline const std::string& DeleteFinishedJobsRequest::_internal_thing() const {
  return _impl_.thing_.Get();
}
inline void DeleteFinishedJobsRequest::_internal_set_thing(const std::string& value) {
  
  _impl_.thing_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteFinishedJobsRequest::_internal_mutable_thing() {
  
  return _impl_.thing_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteFinishedJobsRequest::release_thing() {
  // @@protoc_insertion_point(field_release:duo.DeleteFinishedJobsRequest.thing)
  return _impl_.thing_.Release();
}
inline void DeleteFinishedJobsRequest::set_allocated_thing(std::string* thing) {
  if (thing != nullptr) {
    
  } else {
    
  }
  _impl_.thing_.SetAllocated(thing, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.thing_.IsDefault()) {
    _impl_.thing_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:duo.DeleteFinishedJobsRequest.thing)
}

// -------------------------------------------------------------------

// ListenNextJobArrivedRequest

// string thing = 1;
inline void ListenNextJobArrivedRequest::clear_thing() {
  _impl_.thing_.ClearToEmpty();
}
inline const std::string& ListenNextJobArrivedRequest::thing() const {
  // @@protoc_insertion_point(field_get:duo.ListenNextJobArrivedRequest.thing)
  return _internal_thing();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListenNextJobArrivedRequest::set_thing(ArgT0&& arg0, ArgT... args) {
 
 _impl_.thing_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:duo.ListenNextJobArrivedRequest.thing)
}
inline std::string* ListenNextJobArrivedRequest::mutable_thing() {
  std::string* _s = _internal_mutable_thing();
  // @@protoc_insertion_point(field_mutable:duo.ListenNextJobArrivedRequest.thing)
  return _s;
}
inline const std::string& ListenNextJobArrivedRequest::_internal_thing() const {
  return _impl_.thing_.Get();
}
inline void ListenNextJobArrivedRequest::_internal_set_thing(const std::string& value) {
  
  _impl_.thing_.Set(value, GetArenaForAllocation());
}
inline std::string* ListenNextJobArrivedRequest::_internal_mutable_thing() {
  
  return _impl_.thing_.Mutable(GetArenaForAllocation());
}
inline std::string* ListenNextJobArrivedRequest::release_thing() {
  // @@protoc_insertion_point(field_release:duo.ListenNextJobArrivedRequest.thing)
  return _impl_.thing_.Release();
}
inline void ListenNextJobArrivedRequest::set_allocated_thing(std::string* thing) {
  if (thing != nullptr) {
    
  } else {
    
  }
  _impl_.thing_.SetAllocated(thing, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.thing_.IsDefault()) {
    _impl_.thing_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:duo.ListenNextJobArrivedRequest.thing)
}

// -------------------------------------------------------------------

// ListenJobChangedRequest

// string thing = 1;
inline void ListenJobChangedRequest::clear_thing() {
  _impl_.thing_.ClearToEmpty();
}
inline const std::string& ListenJobChangedRequest::thing() const {
  // @@protoc_insertion_point(field_get:duo.ListenJobChangedRequest.thing)
  return _internal_thing();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListenJobChangedRequest::set_thing(ArgT0&& arg0, ArgT... args) {
 
 _impl_.thing_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:duo.ListenJobChangedRequest.thing)
}
inline std::string* ListenJobChangedRequest::mutable_thing() {
  std::string* _s = _internal_mutable_thing();
  // @@protoc_insertion_point(field_mutable:duo.ListenJobChangedRequest.thing)
  return _s;
}
inline const std::string& ListenJobChangedRequest::_internal_thing() const {
  return _impl_.thing_.Get();
}
inline void ListenJobChangedRequest::_internal_set_thing(const std::string& value) {
  
  _impl_.thing_.Set(value, GetArenaForAllocation());
}
inline std::string* ListenJobChangedRequest::_internal_mutable_thing() {
  
  return _impl_.thing_.Mutable(GetArenaForAllocation());
}
inline std::string* ListenJobChangedRequest::release_thing() {
  // @@protoc_insertion_point(field_release:duo.ListenJobChangedRequest.thing)
  return _impl_.thing_.Release();
}
inline void ListenJobChangedRequest::set_allocated_thing(std::string* thing) {
  if (thing != nullptr) {
    
  } else {
    
  }
  _impl_.thing_.SetAllocated(thing, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.thing_.IsDefault()) {
    _impl_.thing_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:duo.ListenJobChangedRequest.thing)
}

// -------------------------------------------------------------------

// Job

// string job_id = 1;
inline void Job::clear_job_id() {
  _impl_.job_id_.ClearToEmpty();
}
inline const std::string& Job::job_id() const {
  // @@protoc_insertion_point(field_get:duo.Job.job_id)
  return _internal_job_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Job::set_job_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.job_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:duo.Job.job_id)
}
inline std::string* Job::mutable_job_id() {
  std::string* _s = _internal_mutable_job_id();
  // @@protoc_insertion_point(field_mutable:duo.Job.job_id)
  return _s;
}
inline const std::string& Job::_internal_job_id() const {
  return _impl_.job_id_.Get();
}
inline void Job::_internal_set_job_id(const std::string& value) {
  
  _impl_.job_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Job::_internal_mutable_job_id() {
  
  return _impl_.job_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Job::release_job_id() {
  // @@protoc_insertion_point(field_release:duo.Job.job_id)
  return _impl_.job_id_.Release();
}
inline void Job::set_allocated_job_id(std::string* job_id) {
  if (job_id != nullptr) {
    
  } else {
    
  }
  _impl_.job_id_.SetAllocated(job_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.job_id_.IsDefault()) {
    _impl_.job_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:duo.Job.job_id)
}

// .duo.JobStatus status = 2;
inline void Job::clear_status() {
  _impl_.status_ = 0;
}
inline ::duo::JobStatus Job::_internal_status() const {
  return static_cast< ::duo::JobStatus >(_impl_.status_);
}
inline ::duo::JobStatus Job::status() const {
  // @@protoc_insertion_point(field_get:duo.Job.status)
  return _internal_status();
}
inline void Job::_internal_set_status(::duo::JobStatus value) {
  
  _impl_.status_ = value;
}
inline void Job::set_status(::duo::JobStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:duo.Job.status)
}

// uint32 progress = 3;
inline void Job::clear_progress() {
  _impl_.progress_ = 0u;
}
inline uint32_t Job::_internal_progress() const {
  return _impl_.progress_;
}
inline uint32_t Job::progress() const {
  // @@protoc_insertion_point(field_get:duo.Job.progress)
  return _internal_progress();
}
inline void Job::_internal_set_progress(uint32_t value) {
  
  _impl_.progress_ = value;
}
inline void Job::set_progress(uint32_t value) {
  _internal_set_progress(value);
  // @@protoc_insertion_point(field_set:duo.Job.progress)
}

// uint64 queuedAt = 4;
inline void Job::clear_queuedat() {
  _impl_.queuedat_ = uint64_t{0u};
}
inline uint64_t Job::_internal_queuedat() const {
  return _impl_.queuedat_;
}
inline uint64_t Job::queuedat() const {
  // @@protoc_insertion_point(field_get:duo.Job.queuedAt)
  return _internal_queuedat();
}
inline void Job::_internal_set_queuedat(uint64_t value) {
  
  _impl_.queuedat_ = value;
}
inline void Job::set_queuedat(uint64_t value) {
  _internal_set_queuedat(value);
  // @@protoc_insertion_point(field_set:duo.Job.queuedAt)
}

// uint64 lastUpdatedAt = 5;
inline void Job::clear_lastupdatedat() {
  _impl_.lastupdatedat_ = uint64_t{0u};
}
inline uint64_t Job::_internal_lastupdatedat() const {
  return _impl_.lastupdatedat_;
}
inline uint64_t Job::lastupdatedat() const {
  // @@protoc_insertion_point(field_get:duo.Job.lastUpdatedAt)
  return _internal_lastupdatedat();
}
inline void Job::_internal_set_lastupdatedat(uint64_t value) {
  
  _impl_.lastupdatedat_ = value;
}
inline void Job::set_lastupdatedat(uint64_t value) {
  _internal_set_lastupdatedat(value);
  // @@protoc_insertion_point(field_set:duo.Job.lastUpdatedAt)
}

// string response = 6;
inline void Job::clear_response() {
  _impl_.response_.ClearToEmpty();
}
inline const std::string& Job::response() const {
  // @@protoc_insertion_point(field_get:duo.Job.response)
  return _internal_response();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Job::set_response(ArgT0&& arg0, ArgT... args) {
 
 _impl_.response_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:duo.Job.response)
}
inline std::string* Job::mutable_response() {
  std::string* _s = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:duo.Job.response)
  return _s;
}
inline const std::string& Job::_internal_response() const {
  return _impl_.response_.Get();
}
inline void Job::_internal_set_response(const std::string& value) {
  
  _impl_.response_.Set(value, GetArenaForAllocation());
}
inline std::string* Job::_internal_mutable_response() {
  
  return _impl_.response_.Mutable(GetArenaForAllocation());
}
inline std::string* Job::release_response() {
  // @@protoc_insertion_point(field_release:duo.Job.response)
  return _impl_.response_.Release();
}
inline void Job::set_allocated_response(std::string* response) {
  if (response != nullptr) {
    
  } else {
    
  }
  _impl_.response_.SetAllocated(response, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.response_.IsDefault()) {
    _impl_.response_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:duo.Job.response)
}

// .google.protobuf.Struct document = 7;
inline bool Job::_internal_has_document() const {
  return this != internal_default_instance() && _impl_.document_ != nullptr;
}
inline bool Job::has_document() const {
  return _internal_has_document();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& Job::_internal_document() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.document_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& Job::document() const {
  // @@protoc_insertion_point(field_get:duo.Job.document)
  return _internal_document();
}
inline void Job::unsafe_arena_set_allocated_document(
    ::PROTOBUF_NAMESPACE_ID::Struct* document) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.document_);
  }
  _impl_.document_ = document;
  if (document) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:duo.Job.document)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Job::release_document() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.document_;
  _impl_.document_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Job::unsafe_arena_release_document() {
  // @@protoc_insertion_point(field_release:duo.Job.document)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.document_;
  _impl_.document_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Job::_internal_mutable_document() {
  
  if (_impl_.document_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.document_ = p;
  }
  return _impl_.document_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Job::mutable_document() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_document();
  // @@protoc_insertion_point(field_mutable:duo.Job.document)
  return _msg;
}
inline void Job::set_allocated_document(::PROTOBUF_NAMESPACE_ID::Struct* document) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.document_);
  }
  if (document) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(document));
    if (message_arena != submessage_arena) {
      document = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, document, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.document_ = document;
  // @@protoc_insertion_point(field_set_allocated:duo.Job.document)
}

// -------------------------------------------------------------------

// GetJobResponse

// .duo.StatusCode code = 1;
inline void GetJobResponse::clear_code() {
  _impl_.code_ = 0;
}
inline ::duo::StatusCode GetJobResponse::_internal_code() const {
  return static_cast< ::duo::StatusCode >(_impl_.code_);
}
inline ::duo::StatusCode GetJobResponse::code() const {
  // @@protoc_insertion_point(field_get:duo.GetJobResponse.code)
  return _internal_code();
}
inline void GetJobResponse::_internal_set_code(::duo::StatusCode value) {
  
  _impl_.code_ = value;
}
inline void GetJobResponse::set_code(::duo::StatusCode value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:duo.GetJobResponse.code)
}

// string request_id = 2;
inline void GetJobResponse::clear_request_id() {
  _impl_.request_id_.ClearToEmpty();
}
inline const std::string& GetJobResponse::request_id() const {
  // @@protoc_insertion_point(field_get:duo.GetJobResponse.request_id)
  return _internal_request_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetJobResponse::set_request_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.request_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:duo.GetJobResponse.request_id)
}
inline std::string* GetJobResponse::mutable_request_id() {
  std::string* _s = _internal_mutable_request_id();
  // @@protoc_insertion_point(field_mutable:duo.GetJobResponse.request_id)
  return _s;
}
inline const std::string& GetJobResponse::_internal_request_id() const {
  return _impl_.request_id_.Get();
}
inline void GetJobResponse::_internal_set_request_id(const std::string& value) {
  
  _impl_.request_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetJobResponse::_internal_mutable_request_id() {
  
  return _impl_.request_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetJobResponse::release_request_id() {
  // @@protoc_insertion_point(field_release:duo.GetJobResponse.request_id)
  return _impl_.request_id_.Release();
}
inline void GetJobResponse::set_allocated_request_id(std::string* request_id) {
  if (request_id != nullptr) {
    
  } else {
    
  }
  _impl_.request_id_.SetAllocated(request_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.request_id_.IsDefault()) {
    _impl_.request_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:duo.GetJobResponse.request_id)
}

// optional .duo.Job job = 3;
inline bool GetJobResponse::_internal_has_job() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.job_ != nullptr);
  return value;
}
inline bool GetJobResponse::has_job() const {
  return _internal_has_job();
}
inline void GetJobResponse::clear_job() {
  if (_impl_.job_ != nullptr) _impl_.job_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::duo::Job& GetJobResponse::_internal_job() const {
  const ::duo::Job* p = _impl_.job_;
  return p != nullptr ? *p : reinterpret_cast<const ::duo::Job&>(
      ::duo::_Job_default_instance_);
}
inline const ::duo::Job& GetJobResponse::job() const {
  // @@protoc_insertion_point(field_get:duo.GetJobResponse.job)
  return _internal_job();
}
inline void GetJobResponse::unsafe_arena_set_allocated_job(
    ::duo::Job* job) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.job_);
  }
  _impl_.job_ = job;
  if (job) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:duo.GetJobResponse.job)
}
inline ::duo::Job* GetJobResponse::release_job() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::duo::Job* temp = _impl_.job_;
  _impl_.job_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::duo::Job* GetJobResponse::unsafe_arena_release_job() {
  // @@protoc_insertion_point(field_release:duo.GetJobResponse.job)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::duo::Job* temp = _impl_.job_;
  _impl_.job_ = nullptr;
  return temp;
}
inline ::duo::Job* GetJobResponse::_internal_mutable_job() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.job_ == nullptr) {
    auto* p = CreateMaybeMessage<::duo::Job>(GetArenaForAllocation());
    _impl_.job_ = p;
  }
  return _impl_.job_;
}
inline ::duo::Job* GetJobResponse::mutable_job() {
  ::duo::Job* _msg = _internal_mutable_job();
  // @@protoc_insertion_point(field_mutable:duo.GetJobResponse.job)
  return _msg;
}
inline void GetJobResponse::set_allocated_job(::duo::Job* job) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.job_;
  }
  if (job) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(job);
    if (message_arena != submessage_arena) {
      job = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, job, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.job_ = job;
  // @@protoc_insertion_point(field_set_allocated:duo.GetJobResponse.job)
}

// -------------------------------------------------------------------

// GetJobsResponse

// .duo.StatusCode code = 1;
inline void GetJobsResponse::clear_code() {
  _impl_.code_ = 0;
}
inline ::duo::StatusCode GetJobsResponse::_internal_code() const {
  return static_cast< ::duo::StatusCode >(_impl_.code_);
}
inline ::duo::StatusCode GetJobsResponse::code() const {
  // @@protoc_insertion_point(field_get:duo.GetJobsResponse.code)
  return _internal_code();
}
inline void GetJobsResponse::_internal_set_code(::duo::StatusCode value) {
  
  _impl_.code_ = value;
}
inline void GetJobsResponse::set_code(::duo::StatusCode value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:duo.GetJobsResponse.code)
}

// string request_id = 2;
inline void GetJobsResponse::clear_request_id() {
  _impl_.request_id_.ClearToEmpty();
}
inline const std::string& GetJobsResponse::request_id() const {
  // @@protoc_insertion_point(field_get:duo.GetJobsResponse.request_id)
  return _internal_request_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetJobsResponse::set_request_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.request_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:duo.GetJobsResponse.request_id)
}
inline std::string* GetJobsResponse::mutable_request_id() {
  std::string* _s = _internal_mutable_request_id();
  // @@protoc_insertion_point(field_mutable:duo.GetJobsResponse.request_id)
  return _s;
}
inline const std::string& GetJobsResponse::_internal_request_id() const {
  return _impl_.request_id_.Get();
}
inline void GetJobsResponse::_internal_set_request_id(const std::string& value) {
  
  _impl_.request_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetJobsResponse::_internal_mutable_request_id() {
  
  return _impl_.request_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetJobsResponse::release_request_id() {
  // @@protoc_insertion_point(field_release:duo.GetJobsResponse.request_id)
  return _impl_.request_id_.Release();
}
inline void GetJobsResponse::set_allocated_request_id(std::string* request_id) {
  if (request_id != nullptr) {
    
  } else {
    
  }
  _impl_.request_id_.SetAllocated(request_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.request_id_.IsDefault()) {
    _impl_.request_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:duo.GetJobsResponse.request_id)
}

// repeated .duo.Job jobs = 3;
inline int GetJobsResponse::_internal_jobs_size() const {
  return _impl_.jobs_.size();
}
inline int GetJobsResponse::jobs_size() const {
  return _internal_jobs_size();
}
inline void GetJobsResponse::clear_jobs() {
  _impl_.jobs_.Clear();
}
inline ::duo::Job* GetJobsResponse::mutable_jobs(int index) {
  // @@protoc_insertion_point(field_mutable:duo.GetJobsResponse.jobs)
  return _impl_.jobs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::duo::Job >*
GetJobsResponse::mutable_jobs() {
  // @@protoc_insertion_point(field_mutable_list:duo.GetJobsResponse.jobs)
  return &_impl_.jobs_;
}
inline const ::duo::Job& GetJobsResponse::_internal_jobs(int index) const {
  return _impl_.jobs_.Get(index);
}
inline const ::duo::Job& GetJobsResponse::jobs(int index) const {
  // @@protoc_insertion_point(field_get:duo.GetJobsResponse.jobs)
  return _internal_jobs(index);
}
inline ::duo::Job* GetJobsResponse::_internal_add_jobs() {
  return _impl_.jobs_.Add();
}
inline ::duo::Job* GetJobsResponse::add_jobs() {
  ::duo::Job* _add = _internal_add_jobs();
  // @@protoc_insertion_point(field_add:duo.GetJobsResponse.jobs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::duo::Job >&
GetJobsResponse::jobs() const {
  // @@protoc_insertion_point(field_list:duo.GetJobsResponse.jobs)
  return _impl_.jobs_;
}

// -------------------------------------------------------------------

// CreateJobResponse

// .duo.StatusCode code = 1;
inline void CreateJobResponse::clear_code() {
  _impl_.code_ = 0;
}
inline ::duo::StatusCode CreateJobResponse::_internal_code() const {
  return static_cast< ::duo::StatusCode >(_impl_.code_);
}
inline ::duo::StatusCode CreateJobResponse::code() const {
  // @@protoc_insertion_point(field_get:duo.CreateJobResponse.code)
  return _internal_code();
}
inline void CreateJobResponse::_internal_set_code(::duo::StatusCode value) {
  
  _impl_.code_ = value;
}
inline void CreateJobResponse::set_code(::duo::StatusCode value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:duo.CreateJobResponse.code)
}

// string request_id = 2;
inline void CreateJobResponse::clear_request_id() {
  _impl_.request_id_.ClearToEmpty();
}
inline const std::string& CreateJobResponse::request_id() const {
  // @@protoc_insertion_point(field_get:duo.CreateJobResponse.request_id)
  return _internal_request_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateJobResponse::set_request_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.request_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:duo.CreateJobResponse.request_id)
}
inline std::string* CreateJobResponse::mutable_request_id() {
  std::string* _s = _internal_mutable_request_id();
  // @@protoc_insertion_point(field_mutable:duo.CreateJobResponse.request_id)
  return _s;
}
inline const std::string& CreateJobResponse::_internal_request_id() const {
  return _impl_.request_id_.Get();
}
inline void CreateJobResponse::_internal_set_request_id(const std::string& value) {
  
  _impl_.request_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateJobResponse::_internal_mutable_request_id() {
  
  return _impl_.request_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateJobResponse::release_request_id() {
  // @@protoc_insertion_point(field_release:duo.CreateJobResponse.request_id)
  return _impl_.request_id_.Release();
}
inline void CreateJobResponse::set_allocated_request_id(std::string* request_id) {
  if (request_id != nullptr) {
    
  } else {
    
  }
  _impl_.request_id_.SetAllocated(request_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.request_id_.IsDefault()) {
    _impl_.request_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:duo.CreateJobResponse.request_id)
}

// string message = 3;
inline void CreateJobResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& CreateJobResponse::message() const {
  // @@protoc_insertion_point(field_get:duo.CreateJobResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateJobResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:duo.CreateJobResponse.message)
}
inline std::string* CreateJobResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:duo.CreateJobResponse.message)
  return _s;
}
inline const std::string& CreateJobResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void CreateJobResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateJobResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateJobResponse::release_message() {
  // @@protoc_insertion_point(field_release:duo.CreateJobResponse.message)
  return _impl_.message_.Release();
}
inline void CreateJobResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:duo.CreateJobResponse.message)
}

// string job_id = 4;
inline void CreateJobResponse::clear_job_id() {
  _impl_.job_id_.ClearToEmpty();
}
inline const std::string& CreateJobResponse::job_id() const {
  // @@protoc_insertion_point(field_get:duo.CreateJobResponse.job_id)
  return _internal_job_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateJobResponse::set_job_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.job_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:duo.CreateJobResponse.job_id)
}
inline std::string* CreateJobResponse::mutable_job_id() {
  std::string* _s = _internal_mutable_job_id();
  // @@protoc_insertion_point(field_mutable:duo.CreateJobResponse.job_id)
  return _s;
}
inline const std::string& CreateJobResponse::_internal_job_id() const {
  return _impl_.job_id_.Get();
}
inline void CreateJobResponse::_internal_set_job_id(const std::string& value) {
  
  _impl_.job_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateJobResponse::_internal_mutable_job_id() {
  
  return _impl_.job_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateJobResponse::release_job_id() {
  // @@protoc_insertion_point(field_release:duo.CreateJobResponse.job_id)
  return _impl_.job_id_.Release();
}
inline void CreateJobResponse::set_allocated_job_id(std::string* job_id) {
  if (job_id != nullptr) {
    
  } else {
    
  }
  _impl_.job_id_.SetAllocated(job_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.job_id_.IsDefault()) {
    _impl_.job_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:duo.CreateJobResponse.job_id)
}

// -------------------------------------------------------------------

// UpdateJobResponse

// .duo.StatusCode code = 1;
inline void UpdateJobResponse::clear_code() {
  _impl_.code_ = 0;
}
inline ::duo::StatusCode UpdateJobResponse::_internal_code() const {
  return static_cast< ::duo::StatusCode >(_impl_.code_);
}
inline ::duo::StatusCode UpdateJobResponse::code() const {
  // @@protoc_insertion_point(field_get:duo.UpdateJobResponse.code)
  return _internal_code();
}
inline void UpdateJobResponse::_internal_set_code(::duo::StatusCode value) {
  
  _impl_.code_ = value;
}
inline void UpdateJobResponse::set_code(::duo::StatusCode value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:duo.UpdateJobResponse.code)
}

// string request_id = 2;
inline void UpdateJobResponse::clear_request_id() {
  _impl_.request_id_.ClearToEmpty();
}
inline const std::string& UpdateJobResponse::request_id() const {
  // @@protoc_insertion_point(field_get:duo.UpdateJobResponse.request_id)
  return _internal_request_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateJobResponse::set_request_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.request_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:duo.UpdateJobResponse.request_id)
}
inline std::string* UpdateJobResponse::mutable_request_id() {
  std::string* _s = _internal_mutable_request_id();
  // @@protoc_insertion_point(field_mutable:duo.UpdateJobResponse.request_id)
  return _s;
}
inline const std::string& UpdateJobResponse::_internal_request_id() const {
  return _impl_.request_id_.Get();
}
inline void UpdateJobResponse::_internal_set_request_id(const std::string& value) {
  
  _impl_.request_id_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateJobResponse::_internal_mutable_request_id() {
  
  return _impl_.request_id_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateJobResponse::release_request_id() {
  // @@protoc_insertion_point(field_release:duo.UpdateJobResponse.request_id)
  return _impl_.request_id_.Release();
}
inline void UpdateJobResponse::set_allocated_request_id(std::string* request_id) {
  if (request_id != nullptr) {
    
  } else {
    
  }
  _impl_.request_id_.SetAllocated(request_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.request_id_.IsDefault()) {
    _impl_.request_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:duo.UpdateJobResponse.request_id)
}

// string message = 3;
inline void UpdateJobResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& UpdateJobResponse::message() const {
  // @@protoc_insertion_point(field_get:duo.UpdateJobResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateJobResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:duo.UpdateJobResponse.message)
}
inline std::string* UpdateJobResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:duo.UpdateJobResponse.message)
  return _s;
}
inline const std::string& UpdateJobResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void UpdateJobResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateJobResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateJobResponse::release_message() {
  // @@protoc_insertion_point(field_release:duo.UpdateJobResponse.message)
  return _impl_.message_.Release();
}
inline void UpdateJobResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:duo.UpdateJobResponse.message)
}

// -------------------------------------------------------------------

// JobDeleteResponse

// .duo.StatusCode code = 1;
inline void JobDeleteResponse::clear_code() {
  _impl_.code_ = 0;
}
inline ::duo::StatusCode JobDeleteResponse::_internal_code() const {
  return static_cast< ::duo::StatusCode >(_impl_.code_);
}
inline ::duo::StatusCode JobDeleteResponse::code() const {
  // @@protoc_insertion_point(field_get:duo.JobDeleteResponse.code)
  return _internal_code();
}
inline void JobDeleteResponse::_internal_set_code(::duo::StatusCode value) {
  
  _impl_.code_ = value;
}
inline void JobDeleteResponse::set_code(::duo::StatusCode value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:duo.JobDeleteResponse.code)
}

// string request_id = 2;
inline void JobDeleteResponse::clear_request_id() {
  _impl_.request_id_.ClearToEmpty();
}
inline const std::string& JobDeleteResponse::request_id() const {
  // @@protoc_insertion_point(field_get:duo.JobDeleteResponse.request_id)
  return _internal_request_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JobDeleteResponse::set_request_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.request_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:duo.JobDeleteResponse.request_id)
}
inline std::string* JobDeleteResponse::mutable_request_id() {
  std::string* _s = _internal_mutable_request_id();
  // @@protoc_insertion_point(field_mutable:duo.JobDeleteResponse.request_id)
  return _s;
}
inline const std::string& JobDeleteResponse::_internal_request_id() const {
  return _impl_.request_id_.Get();
}
inline void JobDeleteResponse::_internal_set_request_id(const std::string& value) {
  
  _impl_.request_id_.Set(value, GetArenaForAllocation());
}
inline std::string* JobDeleteResponse::_internal_mutable_request_id() {
  
  return _impl_.request_id_.Mutable(GetArenaForAllocation());
}
inline std::string* JobDeleteResponse::release_request_id() {
  // @@protoc_insertion_point(field_release:duo.JobDeleteResponse.request_id)
  return _impl_.request_id_.Release();
}
inline void JobDeleteResponse::set_allocated_request_id(std::string* request_id) {
  if (request_id != nullptr) {
    
  } else {
    
  }
  _impl_.request_id_.SetAllocated(request_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.request_id_.IsDefault()) {
    _impl_.request_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:duo.JobDeleteResponse.request_id)
}

// string message = 3;
inline void JobDeleteResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& JobDeleteResponse::message() const {
  // @@protoc_insertion_point(field_get:duo.JobDeleteResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JobDeleteResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:duo.JobDeleteResponse.message)
}
inline std::string* JobDeleteResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:duo.JobDeleteResponse.message)
  return _s;
}
inline const std::string& JobDeleteResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void JobDeleteResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* JobDeleteResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* JobDeleteResponse::release_message() {
  // @@protoc_insertion_point(field_release:duo.JobDeleteResponse.message)
  return _impl_.message_.Release();
}
inline void JobDeleteResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:duo.JobDeleteResponse.message)
}

// -------------------------------------------------------------------

// ListenNextJobArrivedResponse

// optional .duo.Job job = 1;
inline bool ListenNextJobArrivedResponse::_internal_has_job() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.job_ != nullptr);
  return value;
}
inline bool ListenNextJobArrivedResponse::has_job() const {
  return _internal_has_job();
}
inline void ListenNextJobArrivedResponse::clear_job() {
  if (_impl_.job_ != nullptr) _impl_.job_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::duo::Job& ListenNextJobArrivedResponse::_internal_job() const {
  const ::duo::Job* p = _impl_.job_;
  return p != nullptr ? *p : reinterpret_cast<const ::duo::Job&>(
      ::duo::_Job_default_instance_);
}
inline const ::duo::Job& ListenNextJobArrivedResponse::job() const {
  // @@protoc_insertion_point(field_get:duo.ListenNextJobArrivedResponse.job)
  return _internal_job();
}
inline void ListenNextJobArrivedResponse::unsafe_arena_set_allocated_job(
    ::duo::Job* job) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.job_);
  }
  _impl_.job_ = job;
  if (job) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:duo.ListenNextJobArrivedResponse.job)
}
inline ::duo::Job* ListenNextJobArrivedResponse::release_job() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::duo::Job* temp = _impl_.job_;
  _impl_.job_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::duo::Job* ListenNextJobArrivedResponse::unsafe_arena_release_job() {
  // @@protoc_insertion_point(field_release:duo.ListenNextJobArrivedResponse.job)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::duo::Job* temp = _impl_.job_;
  _impl_.job_ = nullptr;
  return temp;
}
inline ::duo::Job* ListenNextJobArrivedResponse::_internal_mutable_job() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.job_ == nullptr) {
    auto* p = CreateMaybeMessage<::duo::Job>(GetArenaForAllocation());
    _impl_.job_ = p;
  }
  return _impl_.job_;
}
inline ::duo::Job* ListenNextJobArrivedResponse::mutable_job() {
  ::duo::Job* _msg = _internal_mutable_job();
  // @@protoc_insertion_point(field_mutable:duo.ListenNextJobArrivedResponse.job)
  return _msg;
}
inline void ListenNextJobArrivedResponse::set_allocated_job(::duo::Job* job) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.job_;
  }
  if (job) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(job);
    if (message_arena != submessage_arena) {
      job = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, job, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.job_ = job;
  // @@protoc_insertion_point(field_set_allocated:duo.ListenNextJobArrivedResponse.job)
}

// -------------------------------------------------------------------

// JobCreateion

// string job_id = 1;
inline void JobCreateion::clear_job_id() {
  _impl_.job_id_.ClearToEmpty();
}
inline const std::string& JobCreateion::job_id() const {
  // @@protoc_insertion_point(field_get:duo.JobCreateion.job_id)
  return _internal_job_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JobCreateion::set_job_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.job_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:duo.JobCreateion.job_id)
}
inline std::string* JobCreateion::mutable_job_id() {
  std::string* _s = _internal_mutable_job_id();
  // @@protoc_insertion_point(field_mutable:duo.JobCreateion.job_id)
  return _s;
}
inline const std::string& JobCreateion::_internal_job_id() const {
  return _impl_.job_id_.Get();
}
inline void JobCreateion::_internal_set_job_id(const std::string& value) {
  
  _impl_.job_id_.Set(value, GetArenaForAllocation());
}
inline std::string* JobCreateion::_internal_mutable_job_id() {
  
  return _impl_.job_id_.Mutable(GetArenaForAllocation());
}
inline std::string* JobCreateion::release_job_id() {
  // @@protoc_insertion_point(field_release:duo.JobCreateion.job_id)
  return _impl_.job_id_.Release();
}
inline void JobCreateion::set_allocated_job_id(std::string* job_id) {
  if (job_id != nullptr) {
    
  } else {
    
  }
  _impl_.job_id_.SetAllocated(job_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.job_id_.IsDefault()) {
    _impl_.job_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:duo.JobCreateion.job_id)
}

// .google.protobuf.Struct document = 2;
inline bool JobCreateion::_internal_has_document() const {
  return this != internal_default_instance() && _impl_.document_ != nullptr;
}
inline bool JobCreateion::has_document() const {
  return _internal_has_document();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& JobCreateion::_internal_document() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.document_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& JobCreateion::document() const {
  // @@protoc_insertion_point(field_get:duo.JobCreateion.document)
  return _internal_document();
}
inline void JobCreateion::unsafe_arena_set_allocated_document(
    ::PROTOBUF_NAMESPACE_ID::Struct* document) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.document_);
  }
  _impl_.document_ = document;
  if (document) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:duo.JobCreateion.document)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* JobCreateion::release_document() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.document_;
  _impl_.document_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* JobCreateion::unsafe_arena_release_document() {
  // @@protoc_insertion_point(field_release:duo.JobCreateion.document)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.document_;
  _impl_.document_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* JobCreateion::_internal_mutable_document() {
  
  if (_impl_.document_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.document_ = p;
  }
  return _impl_.document_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* JobCreateion::mutable_document() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_document();
  // @@protoc_insertion_point(field_mutable:duo.JobCreateion.document)
  return _msg;
}
inline void JobCreateion::set_allocated_document(::PROTOBUF_NAMESPACE_ID::Struct* document) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.document_);
  }
  if (document) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(document));
    if (message_arena != submessage_arena) {
      document = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, document, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.document_ = document;
  // @@protoc_insertion_point(field_set_allocated:duo.JobCreateion.document)
}

// -------------------------------------------------------------------

// JobModification

// string job_id = 1;
inline void JobModification::clear_job_id() {
  _impl_.job_id_.ClearToEmpty();
}
inline const std::string& JobModification::job_id() const {
  // @@protoc_insertion_point(field_get:duo.JobModification.job_id)
  return _internal_job_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JobModification::set_job_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.job_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:duo.JobModification.job_id)
}
inline std::string* JobModification::mutable_job_id() {
  std::string* _s = _internal_mutable_job_id();
  // @@protoc_insertion_point(field_mutable:duo.JobModification.job_id)
  return _s;
}
inline const std::string& JobModification::_internal_job_id() const {
  return _impl_.job_id_.Get();
}
inline void JobModification::_internal_set_job_id(const std::string& value) {
  
  _impl_.job_id_.Set(value, GetArenaForAllocation());
}
inline std::string* JobModification::_internal_mutable_job_id() {
  
  return _impl_.job_id_.Mutable(GetArenaForAllocation());
}
inline std::string* JobModification::release_job_id() {
  // @@protoc_insertion_point(field_release:duo.JobModification.job_id)
  return _impl_.job_id_.Release();
}
inline void JobModification::set_allocated_job_id(std::string* job_id) {
  if (job_id != nullptr) {
    
  } else {
    
  }
  _impl_.job_id_.SetAllocated(job_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.job_id_.IsDefault()) {
    _impl_.job_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:duo.JobModification.job_id)
}

// optional .duo.JobStatus status = 2;
inline bool JobModification::_internal_has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool JobModification::has_status() const {
  return _internal_has_status();
}
inline void JobModification::clear_status() {
  _impl_.status_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::duo::JobStatus JobModification::_internal_status() const {
  return static_cast< ::duo::JobStatus >(_impl_.status_);
}
inline ::duo::JobStatus JobModification::status() const {
  // @@protoc_insertion_point(field_get:duo.JobModification.status)
  return _internal_status();
}
inline void JobModification::_internal_set_status(::duo::JobStatus value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.status_ = value;
}
inline void JobModification::set_status(::duo::JobStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:duo.JobModification.status)
}

// optional uint32 progress = 3;
inline bool JobModification::_internal_has_progress() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool JobModification::has_progress() const {
  return _internal_has_progress();
}
inline void JobModification::clear_progress() {
  _impl_.progress_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t JobModification::_internal_progress() const {
  return _impl_.progress_;
}
inline uint32_t JobModification::progress() const {
  // @@protoc_insertion_point(field_get:duo.JobModification.progress)
  return _internal_progress();
}
inline void JobModification::_internal_set_progress(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.progress_ = value;
}
inline void JobModification::set_progress(uint32_t value) {
  _internal_set_progress(value);
  // @@protoc_insertion_point(field_set:duo.JobModification.progress)
}

// optional string response = 4;
inline bool JobModification::_internal_has_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool JobModification::has_response() const {
  return _internal_has_response();
}
inline void JobModification::clear_response() {
  _impl_.response_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& JobModification::response() const {
  // @@protoc_insertion_point(field_get:duo.JobModification.response)
  return _internal_response();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JobModification::set_response(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.response_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:duo.JobModification.response)
}
inline std::string* JobModification::mutable_response() {
  std::string* _s = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:duo.JobModification.response)
  return _s;
}
inline const std::string& JobModification::_internal_response() const {
  return _impl_.response_.Get();
}
inline void JobModification::_internal_set_response(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.response_.Set(value, GetArenaForAllocation());
}
inline std::string* JobModification::_internal_mutable_response() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.response_.Mutable(GetArenaForAllocation());
}
inline std::string* JobModification::release_response() {
  // @@protoc_insertion_point(field_release:duo.JobModification.response)
  if (!_internal_has_response()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.response_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.response_.IsDefault()) {
    _impl_.response_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void JobModification::set_allocated_response(std::string* response) {
  if (response != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.response_.SetAllocated(response, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.response_.IsDefault()) {
    _impl_.response_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:duo.JobModification.response)
}

// -------------------------------------------------------------------

// JobListenEvent

// bool connected = 1;
inline void JobListenEvent::clear_connected() {
  _impl_.connected_ = false;
}
inline bool JobListenEvent::_internal_connected() const {
  return _impl_.connected_;
}
inline bool JobListenEvent::connected() const {
  // @@protoc_insertion_point(field_get:duo.JobListenEvent.connected)
  return _internal_connected();
}
inline void JobListenEvent::_internal_set_connected(bool value) {
  
  _impl_.connected_ = value;
}
inline void JobListenEvent::set_connected(bool value) {
  _internal_set_connected(value);
  // @@protoc_insertion_point(field_set:duo.JobListenEvent.connected)
}

// -------------------------------------------------------------------

// ListenJobChangedResponse

// .duo.JobCreateion job_creation = 1;
inline bool ListenJobChangedResponse::_internal_has_job_creation() const {
  return change_case() == kJobCreation;
}
inline bool ListenJobChangedResponse::has_job_creation() const {
  return _internal_has_job_creation();
}
inline void ListenJobChangedResponse::set_has_job_creation() {
  _impl_._oneof_case_[0] = kJobCreation;
}
inline void ListenJobChangedResponse::clear_job_creation() {
  if (_internal_has_job_creation()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.change_.job_creation_;
    }
    clear_has_change();
  }
}
inline ::duo::JobCreateion* ListenJobChangedResponse::release_job_creation() {
  // @@protoc_insertion_point(field_release:duo.ListenJobChangedResponse.job_creation)
  if (_internal_has_job_creation()) {
    clear_has_change();
    ::duo::JobCreateion* temp = _impl_.change_.job_creation_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.change_.job_creation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::duo::JobCreateion& ListenJobChangedResponse::_internal_job_creation() const {
  return _internal_has_job_creation()
      ? *_impl_.change_.job_creation_
      : reinterpret_cast< ::duo::JobCreateion&>(::duo::_JobCreateion_default_instance_);
}
inline const ::duo::JobCreateion& ListenJobChangedResponse::job_creation() const {
  // @@protoc_insertion_point(field_get:duo.ListenJobChangedResponse.job_creation)
  return _internal_job_creation();
}
inline ::duo::JobCreateion* ListenJobChangedResponse::unsafe_arena_release_job_creation() {
  // @@protoc_insertion_point(field_unsafe_arena_release:duo.ListenJobChangedResponse.job_creation)
  if (_internal_has_job_creation()) {
    clear_has_change();
    ::duo::JobCreateion* temp = _impl_.change_.job_creation_;
    _impl_.change_.job_creation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ListenJobChangedResponse::unsafe_arena_set_allocated_job_creation(::duo::JobCreateion* job_creation) {
  clear_change();
  if (job_creation) {
    set_has_job_creation();
    _impl_.change_.job_creation_ = job_creation;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:duo.ListenJobChangedResponse.job_creation)
}
inline ::duo::JobCreateion* ListenJobChangedResponse::_internal_mutable_job_creation() {
  if (!_internal_has_job_creation()) {
    clear_change();
    set_has_job_creation();
    _impl_.change_.job_creation_ = CreateMaybeMessage< ::duo::JobCreateion >(GetArenaForAllocation());
  }
  return _impl_.change_.job_creation_;
}
inline ::duo::JobCreateion* ListenJobChangedResponse::mutable_job_creation() {
  ::duo::JobCreateion* _msg = _internal_mutable_job_creation();
  // @@protoc_insertion_point(field_mutable:duo.ListenJobChangedResponse.job_creation)
  return _msg;
}

// .duo.JobModification job_modification = 2;
inline bool ListenJobChangedResponse::_internal_has_job_modification() const {
  return change_case() == kJobModification;
}
inline bool ListenJobChangedResponse::has_job_modification() const {
  return _internal_has_job_modification();
}
inline void ListenJobChangedResponse::set_has_job_modification() {
  _impl_._oneof_case_[0] = kJobModification;
}
inline void ListenJobChangedResponse::clear_job_modification() {
  if (_internal_has_job_modification()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.change_.job_modification_;
    }
    clear_has_change();
  }
}
inline ::duo::JobModification* ListenJobChangedResponse::release_job_modification() {
  // @@protoc_insertion_point(field_release:duo.ListenJobChangedResponse.job_modification)
  if (_internal_has_job_modification()) {
    clear_has_change();
    ::duo::JobModification* temp = _impl_.change_.job_modification_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.change_.job_modification_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::duo::JobModification& ListenJobChangedResponse::_internal_job_modification() const {
  return _internal_has_job_modification()
      ? *_impl_.change_.job_modification_
      : reinterpret_cast< ::duo::JobModification&>(::duo::_JobModification_default_instance_);
}
inline const ::duo::JobModification& ListenJobChangedResponse::job_modification() const {
  // @@protoc_insertion_point(field_get:duo.ListenJobChangedResponse.job_modification)
  return _internal_job_modification();
}
inline ::duo::JobModification* ListenJobChangedResponse::unsafe_arena_release_job_modification() {
  // @@protoc_insertion_point(field_unsafe_arena_release:duo.ListenJobChangedResponse.job_modification)
  if (_internal_has_job_modification()) {
    clear_has_change();
    ::duo::JobModification* temp = _impl_.change_.job_modification_;
    _impl_.change_.job_modification_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ListenJobChangedResponse::unsafe_arena_set_allocated_job_modification(::duo::JobModification* job_modification) {
  clear_change();
  if (job_modification) {
    set_has_job_modification();
    _impl_.change_.job_modification_ = job_modification;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:duo.ListenJobChangedResponse.job_modification)
}
inline ::duo::JobModification* ListenJobChangedResponse::_internal_mutable_job_modification() {
  if (!_internal_has_job_modification()) {
    clear_change();
    set_has_job_modification();
    _impl_.change_.job_modification_ = CreateMaybeMessage< ::duo::JobModification >(GetArenaForAllocation());
  }
  return _impl_.change_.job_modification_;
}
inline ::duo::JobModification* ListenJobChangedResponse::mutable_job_modification() {
  ::duo::JobModification* _msg = _internal_mutable_job_modification();
  // @@protoc_insertion_point(field_mutable:duo.ListenJobChangedResponse.job_modification)
  return _msg;
}

// .duo.JobListenEvent job_event = 3;
inline bool ListenJobChangedResponse::_internal_has_job_event() const {
  return change_case() == kJobEvent;
}
inline bool ListenJobChangedResponse::has_job_event() const {
  return _internal_has_job_event();
}
inline void ListenJobChangedResponse::set_has_job_event() {
  _impl_._oneof_case_[0] = kJobEvent;
}
inline void ListenJobChangedResponse::clear_job_event() {
  if (_internal_has_job_event()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.change_.job_event_;
    }
    clear_has_change();
  }
}
inline ::duo::JobListenEvent* ListenJobChangedResponse::release_job_event() {
  // @@protoc_insertion_point(field_release:duo.ListenJobChangedResponse.job_event)
  if (_internal_has_job_event()) {
    clear_has_change();
    ::duo::JobListenEvent* temp = _impl_.change_.job_event_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.change_.job_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::duo::JobListenEvent& ListenJobChangedResponse::_internal_job_event() const {
  return _internal_has_job_event()
      ? *_impl_.change_.job_event_
      : reinterpret_cast< ::duo::JobListenEvent&>(::duo::_JobListenEvent_default_instance_);
}
inline const ::duo::JobListenEvent& ListenJobChangedResponse::job_event() const {
  // @@protoc_insertion_point(field_get:duo.ListenJobChangedResponse.job_event)
  return _internal_job_event();
}
inline ::duo::JobListenEvent* ListenJobChangedResponse::unsafe_arena_release_job_event() {
  // @@protoc_insertion_point(field_unsafe_arena_release:duo.ListenJobChangedResponse.job_event)
  if (_internal_has_job_event()) {
    clear_has_change();
    ::duo::JobListenEvent* temp = _impl_.change_.job_event_;
    _impl_.change_.job_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ListenJobChangedResponse::unsafe_arena_set_allocated_job_event(::duo::JobListenEvent* job_event) {
  clear_change();
  if (job_event) {
    set_has_job_event();
    _impl_.change_.job_event_ = job_event;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:duo.ListenJobChangedResponse.job_event)
}
inline ::duo::JobListenEvent* ListenJobChangedResponse::_internal_mutable_job_event() {
  if (!_internal_has_job_event()) {
    clear_change();
    set_has_job_event();
    _impl_.change_.job_event_ = CreateMaybeMessage< ::duo::JobListenEvent >(GetArenaForAllocation());
  }
  return _impl_.change_.job_event_;
}
inline ::duo::JobListenEvent* ListenJobChangedResponse::mutable_job_event() {
  ::duo::JobListenEvent* _msg = _internal_mutable_job_event();
  // @@protoc_insertion_point(field_mutable:duo.ListenJobChangedResponse.job_event)
  return _msg;
}

inline bool ListenJobChangedResponse::has_change() const {
  return change_case() != CHANGE_NOT_SET;
}
inline void ListenJobChangedResponse::clear_has_change() {
  _impl_._oneof_case_[0] = CHANGE_NOT_SET;
}
inline ListenJobChangedResponse::ChangeCase ListenJobChangedResponse::change_case() const {
  return ListenJobChangedResponse::ChangeCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace duo

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::duo::StatusCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::duo::StatusCode>() {
  return ::duo::StatusCode_descriptor();
}
template <> struct is_proto_enum< ::duo::JobStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::duo::JobStatus>() {
  return ::duo::JobStatus_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_duo_2fduo_2eproto
