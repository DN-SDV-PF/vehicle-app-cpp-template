// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: sdv/databroker/v1/collector.proto
// Original file comments:
// *******************************************************************************
// Copyright (c) 2022 Contributors to the Eclipse Foundation
//
// See the NOTICE file(s) distributed with this work for additional
// information regarding copyright ownership.
//
// This program and the accompanying materials are made available under the
// terms of the Apache License 2.0 which is available at
// http://www.apache.org/licenses/LICENSE-2.0
//
// SPDX-License-Identifier: Apache-2.0
// ******************************************************************************
//
#ifndef GRPC_sdv_2fdatabroker_2fv1_2fcollector_2eproto__INCLUDED
#define GRPC_sdv_2fdatabroker_2fv1_2fcollector_2eproto__INCLUDED

#include "sdv/databroker/v1/collector.pb.h"

#include <functional>
#include <grpcpp/generic/async_generic_service.h>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace sdv {
namespace databroker {
namespace v1 {

class Collector final {
 public:
  static constexpr char const* service_full_name() {
    return "sdv.databroker.v1.Collector";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Register new datapoint (metadata)
    //
    // If the registration of at least one of the passed data point fails, the overall registration
    // is rejected and the gRPC status code ABORTED is returned (to indicate the "aborted" registration).
    // The details, which data point(s) caused the failure and the reason, is passed in back in human-
    // readable form in the status message. Possible failure resaons are:
    //  * PERMISSION_DENIED - Not allowed to register this name
    //  * ALREADY_REGISTERED - The data point is already registered by some other feeder
    //  * RE_REGISTRATION_MISMATCH - Already registered by this feeder but with differing metadata
    //  * INVALID_NAME - The passed name of the datapoint has an invalid structure
    //  * INVALID_VALUE_TYPE - The passed ValueType is not supported
    //  * INVALID_CHANGE_TYPE - The passed ChangeType is not supported
    virtual ::grpc::Status RegisterDatapoints(::grpc::ClientContext* context, const ::sdv::databroker::v1::RegisterDatapointsRequest& request, ::sdv::databroker::v1::RegisterDatapointsReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sdv::databroker::v1::RegisterDatapointsReply>> AsyncRegisterDatapoints(::grpc::ClientContext* context, const ::sdv::databroker::v1::RegisterDatapointsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sdv::databroker::v1::RegisterDatapointsReply>>(AsyncRegisterDatapointsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sdv::databroker::v1::RegisterDatapointsReply>> PrepareAsyncRegisterDatapoints(::grpc::ClientContext* context, const ::sdv::databroker::v1::RegisterDatapointsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sdv::databroker::v1::RegisterDatapointsReply>>(PrepareAsyncRegisterDatapointsRaw(context, request, cq));
    }
    // Provide a set of updated datapoint values to the broker.
    // This is the unary equivalent of `StreamDatapoints` below and is better suited for cases
    // where the frequency of updates is rather low.
    //
    // NOTE: The values provided in a single request are handled as a single update in the
    // data broker. This ensures that any clients requesting (or subscribing to) a set of
    // datapoints will get a consistent update, i.e. that either all values are updated or
    // none are.
    //
    // Returns: any errors encountered updating the datapoints
    //
    virtual ::grpc::Status UpdateDatapoints(::grpc::ClientContext* context, const ::sdv::databroker::v1::UpdateDatapointsRequest& request, ::sdv::databroker::v1::UpdateDatapointsReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sdv::databroker::v1::UpdateDatapointsReply>> AsyncUpdateDatapoints(::grpc::ClientContext* context, const ::sdv::databroker::v1::UpdateDatapointsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sdv::databroker::v1::UpdateDatapointsReply>>(AsyncUpdateDatapointsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sdv::databroker::v1::UpdateDatapointsReply>> PrepareAsyncUpdateDatapoints(::grpc::ClientContext* context, const ::sdv::databroker::v1::UpdateDatapointsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sdv::databroker::v1::UpdateDatapointsReply>>(PrepareAsyncUpdateDatapointsRaw(context, request, cq));
    }
    // Provide a stream with updated datapoint values to the broker.
    // This is the streaming equivalent of `UpdateDatapoints` above and is better suited for
    // cases where the frequency of updates is high.
    //
    // NOTE: The values provided in a single request are handled as a single update in the
    // data broker. This ensures that any clients requesting (or subscribing to) a set of
    // datapoints will get a consistent update, i.e. that either all values are updated or
    // none are.
    //
    // Returns: any errors encountered updating the datapoints
    //
    std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::sdv::databroker::v1::StreamDatapointsRequest, ::sdv::databroker::v1::StreamDatapointsReply>> StreamDatapoints(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::sdv::databroker::v1::StreamDatapointsRequest, ::sdv::databroker::v1::StreamDatapointsReply>>(StreamDatapointsRaw(context));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::sdv::databroker::v1::StreamDatapointsRequest, ::sdv::databroker::v1::StreamDatapointsReply>> AsyncStreamDatapoints(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::sdv::databroker::v1::StreamDatapointsRequest, ::sdv::databroker::v1::StreamDatapointsReply>>(AsyncStreamDatapointsRaw(context, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::sdv::databroker::v1::StreamDatapointsRequest, ::sdv::databroker::v1::StreamDatapointsReply>> PrepareAsyncStreamDatapoints(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::sdv::databroker::v1::StreamDatapointsRequest, ::sdv::databroker::v1::StreamDatapointsReply>>(PrepareAsyncStreamDatapointsRaw(context, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // Register new datapoint (metadata)
      //
      // If the registration of at least one of the passed data point fails, the overall registration
      // is rejected and the gRPC status code ABORTED is returned (to indicate the "aborted" registration).
      // The details, which data point(s) caused the failure and the reason, is passed in back in human-
      // readable form in the status message. Possible failure resaons are:
      //  * PERMISSION_DENIED - Not allowed to register this name
      //  * ALREADY_REGISTERED - The data point is already registered by some other feeder
      //  * RE_REGISTRATION_MISMATCH - Already registered by this feeder but with differing metadata
      //  * INVALID_NAME - The passed name of the datapoint has an invalid structure
      //  * INVALID_VALUE_TYPE - The passed ValueType is not supported
      //  * INVALID_CHANGE_TYPE - The passed ChangeType is not supported
      virtual void RegisterDatapoints(::grpc::ClientContext* context, const ::sdv::databroker::v1::RegisterDatapointsRequest* request, ::sdv::databroker::v1::RegisterDatapointsReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void RegisterDatapoints(::grpc::ClientContext* context, const ::sdv::databroker::v1::RegisterDatapointsRequest* request, ::sdv::databroker::v1::RegisterDatapointsReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Provide a set of updated datapoint values to the broker.
      // This is the unary equivalent of `StreamDatapoints` below and is better suited for cases
      // where the frequency of updates is rather low.
      //
      // NOTE: The values provided in a single request are handled as a single update in the
      // data broker. This ensures that any clients requesting (or subscribing to) a set of
      // datapoints will get a consistent update, i.e. that either all values are updated or
      // none are.
      //
      // Returns: any errors encountered updating the datapoints
      //
      virtual void UpdateDatapoints(::grpc::ClientContext* context, const ::sdv::databroker::v1::UpdateDatapointsRequest* request, ::sdv::databroker::v1::UpdateDatapointsReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UpdateDatapoints(::grpc::ClientContext* context, const ::sdv::databroker::v1::UpdateDatapointsRequest* request, ::sdv::databroker::v1::UpdateDatapointsReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Provide a stream with updated datapoint values to the broker.
      // This is the streaming equivalent of `UpdateDatapoints` above and is better suited for
      // cases where the frequency of updates is high.
      //
      // NOTE: The values provided in a single request are handled as a single update in the
      // data broker. This ensures that any clients requesting (or subscribing to) a set of
      // datapoints will get a consistent update, i.e. that either all values are updated or
      // none are.
      //
      // Returns: any errors encountered updating the datapoints
      //
      virtual void StreamDatapoints(::grpc::ClientContext* context, ::grpc::ClientBidiReactor< ::sdv::databroker::v1::StreamDatapointsRequest,::sdv::databroker::v1::StreamDatapointsReply>* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sdv::databroker::v1::RegisterDatapointsReply>* AsyncRegisterDatapointsRaw(::grpc::ClientContext* context, const ::sdv::databroker::v1::RegisterDatapointsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sdv::databroker::v1::RegisterDatapointsReply>* PrepareAsyncRegisterDatapointsRaw(::grpc::ClientContext* context, const ::sdv::databroker::v1::RegisterDatapointsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sdv::databroker::v1::UpdateDatapointsReply>* AsyncUpdateDatapointsRaw(::grpc::ClientContext* context, const ::sdv::databroker::v1::UpdateDatapointsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sdv::databroker::v1::UpdateDatapointsReply>* PrepareAsyncUpdateDatapointsRaw(::grpc::ClientContext* context, const ::sdv::databroker::v1::UpdateDatapointsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderWriterInterface< ::sdv::databroker::v1::StreamDatapointsRequest, ::sdv::databroker::v1::StreamDatapointsReply>* StreamDatapointsRaw(::grpc::ClientContext* context) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::sdv::databroker::v1::StreamDatapointsRequest, ::sdv::databroker::v1::StreamDatapointsReply>* AsyncStreamDatapointsRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::sdv::databroker::v1::StreamDatapointsRequest, ::sdv::databroker::v1::StreamDatapointsReply>* PrepareAsyncStreamDatapointsRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status RegisterDatapoints(::grpc::ClientContext* context, const ::sdv::databroker::v1::RegisterDatapointsRequest& request, ::sdv::databroker::v1::RegisterDatapointsReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sdv::databroker::v1::RegisterDatapointsReply>> AsyncRegisterDatapoints(::grpc::ClientContext* context, const ::sdv::databroker::v1::RegisterDatapointsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sdv::databroker::v1::RegisterDatapointsReply>>(AsyncRegisterDatapointsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sdv::databroker::v1::RegisterDatapointsReply>> PrepareAsyncRegisterDatapoints(::grpc::ClientContext* context, const ::sdv::databroker::v1::RegisterDatapointsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sdv::databroker::v1::RegisterDatapointsReply>>(PrepareAsyncRegisterDatapointsRaw(context, request, cq));
    }
    ::grpc::Status UpdateDatapoints(::grpc::ClientContext* context, const ::sdv::databroker::v1::UpdateDatapointsRequest& request, ::sdv::databroker::v1::UpdateDatapointsReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sdv::databroker::v1::UpdateDatapointsReply>> AsyncUpdateDatapoints(::grpc::ClientContext* context, const ::sdv::databroker::v1::UpdateDatapointsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sdv::databroker::v1::UpdateDatapointsReply>>(AsyncUpdateDatapointsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sdv::databroker::v1::UpdateDatapointsReply>> PrepareAsyncUpdateDatapoints(::grpc::ClientContext* context, const ::sdv::databroker::v1::UpdateDatapointsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sdv::databroker::v1::UpdateDatapointsReply>>(PrepareAsyncUpdateDatapointsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderWriter< ::sdv::databroker::v1::StreamDatapointsRequest, ::sdv::databroker::v1::StreamDatapointsReply>> StreamDatapoints(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriter< ::sdv::databroker::v1::StreamDatapointsRequest, ::sdv::databroker::v1::StreamDatapointsReply>>(StreamDatapointsRaw(context));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::sdv::databroker::v1::StreamDatapointsRequest, ::sdv::databroker::v1::StreamDatapointsReply>> AsyncStreamDatapoints(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::sdv::databroker::v1::StreamDatapointsRequest, ::sdv::databroker::v1::StreamDatapointsReply>>(AsyncStreamDatapointsRaw(context, cq, tag));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::sdv::databroker::v1::StreamDatapointsRequest, ::sdv::databroker::v1::StreamDatapointsReply>> PrepareAsyncStreamDatapoints(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::sdv::databroker::v1::StreamDatapointsRequest, ::sdv::databroker::v1::StreamDatapointsReply>>(PrepareAsyncStreamDatapointsRaw(context, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void RegisterDatapoints(::grpc::ClientContext* context, const ::sdv::databroker::v1::RegisterDatapointsRequest* request, ::sdv::databroker::v1::RegisterDatapointsReply* response, std::function<void(::grpc::Status)>) override;
      void RegisterDatapoints(::grpc::ClientContext* context, const ::sdv::databroker::v1::RegisterDatapointsRequest* request, ::sdv::databroker::v1::RegisterDatapointsReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void UpdateDatapoints(::grpc::ClientContext* context, const ::sdv::databroker::v1::UpdateDatapointsRequest* request, ::sdv::databroker::v1::UpdateDatapointsReply* response, std::function<void(::grpc::Status)>) override;
      void UpdateDatapoints(::grpc::ClientContext* context, const ::sdv::databroker::v1::UpdateDatapointsRequest* request, ::sdv::databroker::v1::UpdateDatapointsReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void StreamDatapoints(::grpc::ClientContext* context, ::grpc::ClientBidiReactor< ::sdv::databroker::v1::StreamDatapointsRequest,::sdv::databroker::v1::StreamDatapointsReply>* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::sdv::databroker::v1::RegisterDatapointsReply>* AsyncRegisterDatapointsRaw(::grpc::ClientContext* context, const ::sdv::databroker::v1::RegisterDatapointsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sdv::databroker::v1::RegisterDatapointsReply>* PrepareAsyncRegisterDatapointsRaw(::grpc::ClientContext* context, const ::sdv::databroker::v1::RegisterDatapointsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sdv::databroker::v1::UpdateDatapointsReply>* AsyncUpdateDatapointsRaw(::grpc::ClientContext* context, const ::sdv::databroker::v1::UpdateDatapointsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sdv::databroker::v1::UpdateDatapointsReply>* PrepareAsyncUpdateDatapointsRaw(::grpc::ClientContext* context, const ::sdv::databroker::v1::UpdateDatapointsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReaderWriter< ::sdv::databroker::v1::StreamDatapointsRequest, ::sdv::databroker::v1::StreamDatapointsReply>* StreamDatapointsRaw(::grpc::ClientContext* context) override;
    ::grpc::ClientAsyncReaderWriter< ::sdv::databroker::v1::StreamDatapointsRequest, ::sdv::databroker::v1::StreamDatapointsReply>* AsyncStreamDatapointsRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReaderWriter< ::sdv::databroker::v1::StreamDatapointsRequest, ::sdv::databroker::v1::StreamDatapointsReply>* PrepareAsyncStreamDatapointsRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_RegisterDatapoints_;
    const ::grpc::internal::RpcMethod rpcmethod_UpdateDatapoints_;
    const ::grpc::internal::RpcMethod rpcmethod_StreamDatapoints_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Register new datapoint (metadata)
    //
    // If the registration of at least one of the passed data point fails, the overall registration
    // is rejected and the gRPC status code ABORTED is returned (to indicate the "aborted" registration).
    // The details, which data point(s) caused the failure and the reason, is passed in back in human-
    // readable form in the status message. Possible failure resaons are:
    //  * PERMISSION_DENIED - Not allowed to register this name
    //  * ALREADY_REGISTERED - The data point is already registered by some other feeder
    //  * RE_REGISTRATION_MISMATCH - Already registered by this feeder but with differing metadata
    //  * INVALID_NAME - The passed name of the datapoint has an invalid structure
    //  * INVALID_VALUE_TYPE - The passed ValueType is not supported
    //  * INVALID_CHANGE_TYPE - The passed ChangeType is not supported
    virtual ::grpc::Status RegisterDatapoints(::grpc::ServerContext* context, const ::sdv::databroker::v1::RegisterDatapointsRequest* request, ::sdv::databroker::v1::RegisterDatapointsReply* response);
    // Provide a set of updated datapoint values to the broker.
    // This is the unary equivalent of `StreamDatapoints` below and is better suited for cases
    // where the frequency of updates is rather low.
    //
    // NOTE: The values provided in a single request are handled as a single update in the
    // data broker. This ensures that any clients requesting (or subscribing to) a set of
    // datapoints will get a consistent update, i.e. that either all values are updated or
    // none are.
    //
    // Returns: any errors encountered updating the datapoints
    //
    virtual ::grpc::Status UpdateDatapoints(::grpc::ServerContext* context, const ::sdv::databroker::v1::UpdateDatapointsRequest* request, ::sdv::databroker::v1::UpdateDatapointsReply* response);
    // Provide a stream with updated datapoint values to the broker.
    // This is the streaming equivalent of `UpdateDatapoints` above and is better suited for
    // cases where the frequency of updates is high.
    //
    // NOTE: The values provided in a single request are handled as a single update in the
    // data broker. This ensures that any clients requesting (or subscribing to) a set of
    // datapoints will get a consistent update, i.e. that either all values are updated or
    // none are.
    //
    // Returns: any errors encountered updating the datapoints
    //
    virtual ::grpc::Status StreamDatapoints(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::sdv::databroker::v1::StreamDatapointsReply, ::sdv::databroker::v1::StreamDatapointsRequest>* stream);
  };
  template <class BaseClass>
  class WithAsyncMethod_RegisterDatapoints : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RegisterDatapoints() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_RegisterDatapoints() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RegisterDatapoints(::grpc::ServerContext* /*context*/, const ::sdv::databroker::v1::RegisterDatapointsRequest* /*request*/, ::sdv::databroker::v1::RegisterDatapointsReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRegisterDatapoints(::grpc::ServerContext* context, ::sdv::databroker::v1::RegisterDatapointsRequest* request, ::grpc::ServerAsyncResponseWriter< ::sdv::databroker::v1::RegisterDatapointsReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UpdateDatapoints : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UpdateDatapoints() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_UpdateDatapoints() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateDatapoints(::grpc::ServerContext* /*context*/, const ::sdv::databroker::v1::UpdateDatapointsRequest* /*request*/, ::sdv::databroker::v1::UpdateDatapointsReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateDatapoints(::grpc::ServerContext* context, ::sdv::databroker::v1::UpdateDatapointsRequest* request, ::grpc::ServerAsyncResponseWriter< ::sdv::databroker::v1::UpdateDatapointsReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StreamDatapoints : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_StreamDatapoints() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_StreamDatapoints() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamDatapoints(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::sdv::databroker::v1::StreamDatapointsReply, ::sdv::databroker::v1::StreamDatapointsRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStreamDatapoints(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::sdv::databroker::v1::StreamDatapointsReply, ::sdv::databroker::v1::StreamDatapointsRequest>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(2, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_RegisterDatapoints<WithAsyncMethod_UpdateDatapoints<WithAsyncMethod_StreamDatapoints<Service > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_RegisterDatapoints : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_RegisterDatapoints() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::sdv::databroker::v1::RegisterDatapointsRequest, ::sdv::databroker::v1::RegisterDatapointsReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::sdv::databroker::v1::RegisterDatapointsRequest* request, ::sdv::databroker::v1::RegisterDatapointsReply* response) { return this->RegisterDatapoints(context, request, response); }));}
    void SetMessageAllocatorFor_RegisterDatapoints(
        ::grpc::MessageAllocator< ::sdv::databroker::v1::RegisterDatapointsRequest, ::sdv::databroker::v1::RegisterDatapointsReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::sdv::databroker::v1::RegisterDatapointsRequest, ::sdv::databroker::v1::RegisterDatapointsReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_RegisterDatapoints() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RegisterDatapoints(::grpc::ServerContext* /*context*/, const ::sdv::databroker::v1::RegisterDatapointsRequest* /*request*/, ::sdv::databroker::v1::RegisterDatapointsReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RegisterDatapoints(
      ::grpc::CallbackServerContext* /*context*/, const ::sdv::databroker::v1::RegisterDatapointsRequest* /*request*/, ::sdv::databroker::v1::RegisterDatapointsReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_UpdateDatapoints : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_UpdateDatapoints() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::sdv::databroker::v1::UpdateDatapointsRequest, ::sdv::databroker::v1::UpdateDatapointsReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::sdv::databroker::v1::UpdateDatapointsRequest* request, ::sdv::databroker::v1::UpdateDatapointsReply* response) { return this->UpdateDatapoints(context, request, response); }));}
    void SetMessageAllocatorFor_UpdateDatapoints(
        ::grpc::MessageAllocator< ::sdv::databroker::v1::UpdateDatapointsRequest, ::sdv::databroker::v1::UpdateDatapointsReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::sdv::databroker::v1::UpdateDatapointsRequest, ::sdv::databroker::v1::UpdateDatapointsReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_UpdateDatapoints() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateDatapoints(::grpc::ServerContext* /*context*/, const ::sdv::databroker::v1::UpdateDatapointsRequest* /*request*/, ::sdv::databroker::v1::UpdateDatapointsReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* UpdateDatapoints(
      ::grpc::CallbackServerContext* /*context*/, const ::sdv::databroker::v1::UpdateDatapointsRequest* /*request*/, ::sdv::databroker::v1::UpdateDatapointsReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_StreamDatapoints : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_StreamDatapoints() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackBidiHandler< ::sdv::databroker::v1::StreamDatapointsRequest, ::sdv::databroker::v1::StreamDatapointsReply>(
            [this](
                   ::grpc::CallbackServerContext* context) { return this->StreamDatapoints(context); }));
    }
    ~WithCallbackMethod_StreamDatapoints() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamDatapoints(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::sdv::databroker::v1::StreamDatapointsReply, ::sdv::databroker::v1::StreamDatapointsRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerBidiReactor< ::sdv::databroker::v1::StreamDatapointsRequest, ::sdv::databroker::v1::StreamDatapointsReply>* StreamDatapoints(
      ::grpc::CallbackServerContext* /*context*/)
      { return nullptr; }
  };
  typedef WithCallbackMethod_RegisterDatapoints<WithCallbackMethod_UpdateDatapoints<WithCallbackMethod_StreamDatapoints<Service > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_RegisterDatapoints : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RegisterDatapoints() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_RegisterDatapoints() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RegisterDatapoints(::grpc::ServerContext* /*context*/, const ::sdv::databroker::v1::RegisterDatapointsRequest* /*request*/, ::sdv::databroker::v1::RegisterDatapointsReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UpdateDatapoints : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UpdateDatapoints() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_UpdateDatapoints() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateDatapoints(::grpc::ServerContext* /*context*/, const ::sdv::databroker::v1::UpdateDatapointsRequest* /*request*/, ::sdv::databroker::v1::UpdateDatapointsReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StreamDatapoints : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_StreamDatapoints() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_StreamDatapoints() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamDatapoints(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::sdv::databroker::v1::StreamDatapointsReply, ::sdv::databroker::v1::StreamDatapointsRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_RegisterDatapoints : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RegisterDatapoints() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_RegisterDatapoints() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RegisterDatapoints(::grpc::ServerContext* /*context*/, const ::sdv::databroker::v1::RegisterDatapointsRequest* /*request*/, ::sdv::databroker::v1::RegisterDatapointsReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRegisterDatapoints(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UpdateDatapoints : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UpdateDatapoints() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_UpdateDatapoints() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateDatapoints(::grpc::ServerContext* /*context*/, const ::sdv::databroker::v1::UpdateDatapointsRequest* /*request*/, ::sdv::databroker::v1::UpdateDatapointsReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateDatapoints(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StreamDatapoints : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_StreamDatapoints() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_StreamDatapoints() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamDatapoints(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::sdv::databroker::v1::StreamDatapointsReply, ::sdv::databroker::v1::StreamDatapointsRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStreamDatapoints(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(2, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_RegisterDatapoints : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_RegisterDatapoints() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->RegisterDatapoints(context, request, response); }));
    }
    ~WithRawCallbackMethod_RegisterDatapoints() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RegisterDatapoints(::grpc::ServerContext* /*context*/, const ::sdv::databroker::v1::RegisterDatapointsRequest* /*request*/, ::sdv::databroker::v1::RegisterDatapointsReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RegisterDatapoints(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_UpdateDatapoints : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_UpdateDatapoints() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UpdateDatapoints(context, request, response); }));
    }
    ~WithRawCallbackMethod_UpdateDatapoints() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateDatapoints(::grpc::ServerContext* /*context*/, const ::sdv::databroker::v1::UpdateDatapointsRequest* /*request*/, ::sdv::databroker::v1::UpdateDatapointsReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* UpdateDatapoints(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_StreamDatapoints : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_StreamDatapoints() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackBidiHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context) { return this->StreamDatapoints(context); }));
    }
    ~WithRawCallbackMethod_StreamDatapoints() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamDatapoints(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::sdv::databroker::v1::StreamDatapointsReply, ::sdv::databroker::v1::StreamDatapointsRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerBidiReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* StreamDatapoints(
      ::grpc::CallbackServerContext* /*context*/)
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RegisterDatapoints : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RegisterDatapoints() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::sdv::databroker::v1::RegisterDatapointsRequest, ::sdv::databroker::v1::RegisterDatapointsReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::sdv::databroker::v1::RegisterDatapointsRequest, ::sdv::databroker::v1::RegisterDatapointsReply>* streamer) {
                       return this->StreamedRegisterDatapoints(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_RegisterDatapoints() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RegisterDatapoints(::grpc::ServerContext* /*context*/, const ::sdv::databroker::v1::RegisterDatapointsRequest* /*request*/, ::sdv::databroker::v1::RegisterDatapointsReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRegisterDatapoints(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::sdv::databroker::v1::RegisterDatapointsRequest,::sdv::databroker::v1::RegisterDatapointsReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UpdateDatapoints : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UpdateDatapoints() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::sdv::databroker::v1::UpdateDatapointsRequest, ::sdv::databroker::v1::UpdateDatapointsReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::sdv::databroker::v1::UpdateDatapointsRequest, ::sdv::databroker::v1::UpdateDatapointsReply>* streamer) {
                       return this->StreamedUpdateDatapoints(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_UpdateDatapoints() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UpdateDatapoints(::grpc::ServerContext* /*context*/, const ::sdv::databroker::v1::UpdateDatapointsRequest* /*request*/, ::sdv::databroker::v1::UpdateDatapointsReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUpdateDatapoints(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::sdv::databroker::v1::UpdateDatapointsRequest,::sdv::databroker::v1::UpdateDatapointsReply>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_RegisterDatapoints<WithStreamedUnaryMethod_UpdateDatapoints<Service > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_RegisterDatapoints<WithStreamedUnaryMethod_UpdateDatapoints<Service > > StreamedService;
};

}  // namespace v1
}  // namespace databroker
}  // namespace sdv


#endif  // GRPC_sdv_2fdatabroker_2fv1_2fcollector_2eproto__INCLUDED
