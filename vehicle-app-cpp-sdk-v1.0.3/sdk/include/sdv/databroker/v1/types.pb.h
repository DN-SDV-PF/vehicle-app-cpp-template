// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sdv/databroker/v1/types.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_sdv_2fdatabroker_2fv1_2ftypes_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_sdv_2fdatabroker_2fv1_2ftypes_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_sdv_2fdatabroker_2fv1_2ftypes_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_sdv_2fdatabroker_2fv1_2ftypes_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_sdv_2fdatabroker_2fv1_2ftypes_2eproto;
namespace sdv {
namespace databroker {
namespace v1 {
class BoolArray;
struct BoolArrayDefaultTypeInternal;
extern BoolArrayDefaultTypeInternal _BoolArray_default_instance_;
class Datapoint;
struct DatapointDefaultTypeInternal;
extern DatapointDefaultTypeInternal _Datapoint_default_instance_;
class DoubleArray;
struct DoubleArrayDefaultTypeInternal;
extern DoubleArrayDefaultTypeInternal _DoubleArray_default_instance_;
class FloatArray;
struct FloatArrayDefaultTypeInternal;
extern FloatArrayDefaultTypeInternal _FloatArray_default_instance_;
class Int32Array;
struct Int32ArrayDefaultTypeInternal;
extern Int32ArrayDefaultTypeInternal _Int32Array_default_instance_;
class Int64Array;
struct Int64ArrayDefaultTypeInternal;
extern Int64ArrayDefaultTypeInternal _Int64Array_default_instance_;
class Metadata;
struct MetadataDefaultTypeInternal;
extern MetadataDefaultTypeInternal _Metadata_default_instance_;
class StringArray;
struct StringArrayDefaultTypeInternal;
extern StringArrayDefaultTypeInternal _StringArray_default_instance_;
class Uint32Array;
struct Uint32ArrayDefaultTypeInternal;
extern Uint32ArrayDefaultTypeInternal _Uint32Array_default_instance_;
class Uint64Array;
struct Uint64ArrayDefaultTypeInternal;
extern Uint64ArrayDefaultTypeInternal _Uint64Array_default_instance_;
}  // namespace v1
}  // namespace databroker
}  // namespace sdv
PROTOBUF_NAMESPACE_OPEN
template<> ::sdv::databroker::v1::BoolArray* Arena::CreateMaybeMessage<::sdv::databroker::v1::BoolArray>(Arena*);
template<> ::sdv::databroker::v1::Datapoint* Arena::CreateMaybeMessage<::sdv::databroker::v1::Datapoint>(Arena*);
template<> ::sdv::databroker::v1::DoubleArray* Arena::CreateMaybeMessage<::sdv::databroker::v1::DoubleArray>(Arena*);
template<> ::sdv::databroker::v1::FloatArray* Arena::CreateMaybeMessage<::sdv::databroker::v1::FloatArray>(Arena*);
template<> ::sdv::databroker::v1::Int32Array* Arena::CreateMaybeMessage<::sdv::databroker::v1::Int32Array>(Arena*);
template<> ::sdv::databroker::v1::Int64Array* Arena::CreateMaybeMessage<::sdv::databroker::v1::Int64Array>(Arena*);
template<> ::sdv::databroker::v1::Metadata* Arena::CreateMaybeMessage<::sdv::databroker::v1::Metadata>(Arena*);
template<> ::sdv::databroker::v1::StringArray* Arena::CreateMaybeMessage<::sdv::databroker::v1::StringArray>(Arena*);
template<> ::sdv::databroker::v1::Uint32Array* Arena::CreateMaybeMessage<::sdv::databroker::v1::Uint32Array>(Arena*);
template<> ::sdv::databroker::v1::Uint64Array* Arena::CreateMaybeMessage<::sdv::databroker::v1::Uint64Array>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace sdv {
namespace databroker {
namespace v1 {

enum Datapoint_Failure : int {
  Datapoint_Failure_INVALID_VALUE = 0,
  Datapoint_Failure_NOT_AVAILABLE = 1,
  Datapoint_Failure_UNKNOWN_DATAPOINT = 2,
  Datapoint_Failure_ACCESS_DENIED = 3,
  Datapoint_Failure_INTERNAL_ERROR = 4,
  Datapoint_Failure_Datapoint_Failure_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Datapoint_Failure_Datapoint_Failure_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Datapoint_Failure_IsValid(int value);
constexpr Datapoint_Failure Datapoint_Failure_Failure_MIN = Datapoint_Failure_INVALID_VALUE;
constexpr Datapoint_Failure Datapoint_Failure_Failure_MAX = Datapoint_Failure_INTERNAL_ERROR;
constexpr int Datapoint_Failure_Failure_ARRAYSIZE = Datapoint_Failure_Failure_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Datapoint_Failure_descriptor();
template<typename T>
inline const std::string& Datapoint_Failure_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Datapoint_Failure>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Datapoint_Failure_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Datapoint_Failure_descriptor(), enum_t_value);
}
inline bool Datapoint_Failure_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Datapoint_Failure* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Datapoint_Failure>(
    Datapoint_Failure_descriptor(), name, value);
}
enum DataType : int {
  STRING = 0,
  BOOL = 1,
  INT8 = 2,
  INT16 = 3,
  INT32 = 4,
  INT64 = 5,
  UINT8 = 6,
  UINT16 = 7,
  UINT32 = 8,
  UINT64 = 9,
  FLOAT = 10,
  DOUBLE = 11,
  STRING_ARRAY = 20,
  BOOL_ARRAY = 21,
  INT8_ARRAY = 22,
  INT16_ARRAY = 23,
  INT32_ARRAY = 24,
  INT64_ARRAY = 25,
  UINT8_ARRAY = 26,
  UINT16_ARRAY = 27,
  UINT32_ARRAY = 28,
  UINT64_ARRAY = 29,
  FLOAT_ARRAY = 30,
  DOUBLE_ARRAY = 31,
  DataType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DataType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DataType_IsValid(int value);
constexpr DataType DataType_MIN = STRING;
constexpr DataType DataType_MAX = DOUBLE_ARRAY;
constexpr int DataType_ARRAYSIZE = DataType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DataType_descriptor();
template<typename T>
inline const std::string& DataType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DataType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DataType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DataType_descriptor(), enum_t_value);
}
inline bool DataType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DataType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DataType>(
    DataType_descriptor(), name, value);
}
enum DatapointError : int {
  UNKNOWN_DATAPOINT = 0,
  INVALID_TYPE = 1,
  ACCESS_DENIED = 2,
  INTERNAL_ERROR = 3,
  OUT_OF_BOUNDS = 4,
  DatapointError_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DatapointError_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DatapointError_IsValid(int value);
constexpr DatapointError DatapointError_MIN = UNKNOWN_DATAPOINT;
constexpr DatapointError DatapointError_MAX = OUT_OF_BOUNDS;
constexpr int DatapointError_ARRAYSIZE = DatapointError_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DatapointError_descriptor();
template<typename T>
inline const std::string& DatapointError_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DatapointError>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DatapointError_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DatapointError_descriptor(), enum_t_value);
}
inline bool DatapointError_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DatapointError* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DatapointError>(
    DatapointError_descriptor(), name, value);
}
enum EntryType : int {
  ENTRY_TYPE_UNSPECIFIED = 0,
  ENTRY_TYPE_SENSOR = 1,
  ENTRY_TYPE_ACTUATOR = 2,
  ENTRY_TYPE_ATTRIBUTE = 3,
  EntryType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EntryType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EntryType_IsValid(int value);
constexpr EntryType EntryType_MIN = ENTRY_TYPE_UNSPECIFIED;
constexpr EntryType EntryType_MAX = ENTRY_TYPE_ATTRIBUTE;
constexpr int EntryType_ARRAYSIZE = EntryType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EntryType_descriptor();
template<typename T>
inline const std::string& EntryType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EntryType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EntryType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EntryType_descriptor(), enum_t_value);
}
inline bool EntryType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EntryType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EntryType>(
    EntryType_descriptor(), name, value);
}
enum ChangeType : int {
  STATIC = 0,
  ON_CHANGE = 1,
  CONTINUOUS = 2,
  ChangeType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ChangeType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ChangeType_IsValid(int value);
constexpr ChangeType ChangeType_MIN = STATIC;
constexpr ChangeType ChangeType_MAX = CONTINUOUS;
constexpr int ChangeType_ARRAYSIZE = ChangeType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ChangeType_descriptor();
template<typename T>
inline const std::string& ChangeType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ChangeType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ChangeType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ChangeType_descriptor(), enum_t_value);
}
inline bool ChangeType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ChangeType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ChangeType>(
    ChangeType_descriptor(), name, value);
}
// ===================================================================

class StringArray final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sdv.databroker.v1.StringArray) */ {
 public:
  inline StringArray() : StringArray(nullptr) {}
  ~StringArray() override;
  explicit PROTOBUF_CONSTEXPR StringArray(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StringArray(const StringArray& from);
  StringArray(StringArray&& from) noexcept
    : StringArray() {
    *this = ::std::move(from);
  }

  inline StringArray& operator=(const StringArray& from) {
    CopyFrom(from);
    return *this;
  }
  inline StringArray& operator=(StringArray&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StringArray& default_instance() {
    return *internal_default_instance();
  }
  static inline const StringArray* internal_default_instance() {
    return reinterpret_cast<const StringArray*>(
               &_StringArray_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(StringArray& a, StringArray& b) {
    a.Swap(&b);
  }
  inline void Swap(StringArray* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StringArray* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StringArray* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StringArray>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StringArray& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StringArray& from) {
    StringArray::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StringArray* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sdv.databroker.v1.StringArray";
  }
  protected:
  explicit StringArray(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated string values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  const std::string& values(int index) const;
  std::string* mutable_values(int index);
  void set_values(int index, const std::string& value);
  void set_values(int index, std::string&& value);
  void set_values(int index, const char* value);
  void set_values(int index, const char* value, size_t size);
  std::string* add_values();
  void add_values(const std::string& value);
  void add_values(std::string&& value);
  void add_values(const char* value);
  void add_values(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_values();
  private:
  const std::string& _internal_values(int index) const;
  std::string* _internal_add_values();
  public:

  // @@protoc_insertion_point(class_scope:sdv.databroker.v1.StringArray)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> values_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sdv_2fdatabroker_2fv1_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class BoolArray final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sdv.databroker.v1.BoolArray) */ {
 public:
  inline BoolArray() : BoolArray(nullptr) {}
  ~BoolArray() override;
  explicit PROTOBUF_CONSTEXPR BoolArray(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BoolArray(const BoolArray& from);
  BoolArray(BoolArray&& from) noexcept
    : BoolArray() {
    *this = ::std::move(from);
  }

  inline BoolArray& operator=(const BoolArray& from) {
    CopyFrom(from);
    return *this;
  }
  inline BoolArray& operator=(BoolArray&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BoolArray& default_instance() {
    return *internal_default_instance();
  }
  static inline const BoolArray* internal_default_instance() {
    return reinterpret_cast<const BoolArray*>(
               &_BoolArray_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(BoolArray& a, BoolArray& b) {
    a.Swap(&b);
  }
  inline void Swap(BoolArray* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BoolArray* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BoolArray* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BoolArray>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BoolArray& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BoolArray& from) {
    BoolArray::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BoolArray* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sdv.databroker.v1.BoolArray";
  }
  protected:
  explicit BoolArray(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated bool values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  private:
  bool _internal_values(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      _internal_values() const;
  void _internal_add_values(bool value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      _internal_mutable_values();
  public:
  bool values(int index) const;
  void set_values(int index, bool value);
  void add_values(bool value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:sdv.databroker.v1.BoolArray)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool > values_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sdv_2fdatabroker_2fv1_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class Int32Array final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sdv.databroker.v1.Int32Array) */ {
 public:
  inline Int32Array() : Int32Array(nullptr) {}
  ~Int32Array() override;
  explicit PROTOBUF_CONSTEXPR Int32Array(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Int32Array(const Int32Array& from);
  Int32Array(Int32Array&& from) noexcept
    : Int32Array() {
    *this = ::std::move(from);
  }

  inline Int32Array& operator=(const Int32Array& from) {
    CopyFrom(from);
    return *this;
  }
  inline Int32Array& operator=(Int32Array&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Int32Array& default_instance() {
    return *internal_default_instance();
  }
  static inline const Int32Array* internal_default_instance() {
    return reinterpret_cast<const Int32Array*>(
               &_Int32Array_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Int32Array& a, Int32Array& b) {
    a.Swap(&b);
  }
  inline void Swap(Int32Array* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Int32Array* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Int32Array* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Int32Array>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Int32Array& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Int32Array& from) {
    Int32Array::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Int32Array* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sdv.databroker.v1.Int32Array";
  }
  protected:
  explicit Int32Array(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated sint32 values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  private:
  int32_t _internal_values(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_values() const;
  void _internal_add_values(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_values();
  public:
  int32_t values(int index) const;
  void set_values(int index, int32_t value);
  void add_values(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:sdv.databroker.v1.Int32Array)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > values_;
    mutable std::atomic<int> _values_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sdv_2fdatabroker_2fv1_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class Int64Array final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sdv.databroker.v1.Int64Array) */ {
 public:
  inline Int64Array() : Int64Array(nullptr) {}
  ~Int64Array() override;
  explicit PROTOBUF_CONSTEXPR Int64Array(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Int64Array(const Int64Array& from);
  Int64Array(Int64Array&& from) noexcept
    : Int64Array() {
    *this = ::std::move(from);
  }

  inline Int64Array& operator=(const Int64Array& from) {
    CopyFrom(from);
    return *this;
  }
  inline Int64Array& operator=(Int64Array&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Int64Array& default_instance() {
    return *internal_default_instance();
  }
  static inline const Int64Array* internal_default_instance() {
    return reinterpret_cast<const Int64Array*>(
               &_Int64Array_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Int64Array& a, Int64Array& b) {
    a.Swap(&b);
  }
  inline void Swap(Int64Array* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Int64Array* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Int64Array* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Int64Array>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Int64Array& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Int64Array& from) {
    Int64Array::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Int64Array* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sdv.databroker.v1.Int64Array";
  }
  protected:
  explicit Int64Array(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated sint64 values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  private:
  int64_t _internal_values(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_values() const;
  void _internal_add_values(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_values();
  public:
  int64_t values(int index) const;
  void set_values(int index, int64_t value);
  void add_values(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:sdv.databroker.v1.Int64Array)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > values_;
    mutable std::atomic<int> _values_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sdv_2fdatabroker_2fv1_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class Uint32Array final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sdv.databroker.v1.Uint32Array) */ {
 public:
  inline Uint32Array() : Uint32Array(nullptr) {}
  ~Uint32Array() override;
  explicit PROTOBUF_CONSTEXPR Uint32Array(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Uint32Array(const Uint32Array& from);
  Uint32Array(Uint32Array&& from) noexcept
    : Uint32Array() {
    *this = ::std::move(from);
  }

  inline Uint32Array& operator=(const Uint32Array& from) {
    CopyFrom(from);
    return *this;
  }
  inline Uint32Array& operator=(Uint32Array&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Uint32Array& default_instance() {
    return *internal_default_instance();
  }
  static inline const Uint32Array* internal_default_instance() {
    return reinterpret_cast<const Uint32Array*>(
               &_Uint32Array_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Uint32Array& a, Uint32Array& b) {
    a.Swap(&b);
  }
  inline void Swap(Uint32Array* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Uint32Array* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Uint32Array* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Uint32Array>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Uint32Array& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Uint32Array& from) {
    Uint32Array::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Uint32Array* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sdv.databroker.v1.Uint32Array";
  }
  protected:
  explicit Uint32Array(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated uint32 values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  private:
  uint32_t _internal_values(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_values() const;
  void _internal_add_values(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_values();
  public:
  uint32_t values(int index) const;
  void set_values(int index, uint32_t value);
  void add_values(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:sdv.databroker.v1.Uint32Array)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > values_;
    mutable std::atomic<int> _values_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sdv_2fdatabroker_2fv1_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class Uint64Array final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sdv.databroker.v1.Uint64Array) */ {
 public:
  inline Uint64Array() : Uint64Array(nullptr) {}
  ~Uint64Array() override;
  explicit PROTOBUF_CONSTEXPR Uint64Array(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Uint64Array(const Uint64Array& from);
  Uint64Array(Uint64Array&& from) noexcept
    : Uint64Array() {
    *this = ::std::move(from);
  }

  inline Uint64Array& operator=(const Uint64Array& from) {
    CopyFrom(from);
    return *this;
  }
  inline Uint64Array& operator=(Uint64Array&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Uint64Array& default_instance() {
    return *internal_default_instance();
  }
  static inline const Uint64Array* internal_default_instance() {
    return reinterpret_cast<const Uint64Array*>(
               &_Uint64Array_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Uint64Array& a, Uint64Array& b) {
    a.Swap(&b);
  }
  inline void Swap(Uint64Array* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Uint64Array* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Uint64Array* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Uint64Array>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Uint64Array& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Uint64Array& from) {
    Uint64Array::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Uint64Array* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sdv.databroker.v1.Uint64Array";
  }
  protected:
  explicit Uint64Array(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated uint64 values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  private:
  uint64_t _internal_values(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_values() const;
  void _internal_add_values(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_values();
  public:
  uint64_t values(int index) const;
  void set_values(int index, uint64_t value);
  void add_values(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:sdv.databroker.v1.Uint64Array)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > values_;
    mutable std::atomic<int> _values_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sdv_2fdatabroker_2fv1_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class FloatArray final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sdv.databroker.v1.FloatArray) */ {
 public:
  inline FloatArray() : FloatArray(nullptr) {}
  ~FloatArray() override;
  explicit PROTOBUF_CONSTEXPR FloatArray(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FloatArray(const FloatArray& from);
  FloatArray(FloatArray&& from) noexcept
    : FloatArray() {
    *this = ::std::move(from);
  }

  inline FloatArray& operator=(const FloatArray& from) {
    CopyFrom(from);
    return *this;
  }
  inline FloatArray& operator=(FloatArray&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FloatArray& default_instance() {
    return *internal_default_instance();
  }
  static inline const FloatArray* internal_default_instance() {
    return reinterpret_cast<const FloatArray*>(
               &_FloatArray_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(FloatArray& a, FloatArray& b) {
    a.Swap(&b);
  }
  inline void Swap(FloatArray* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FloatArray* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FloatArray* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FloatArray>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FloatArray& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FloatArray& from) {
    FloatArray::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FloatArray* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sdv.databroker.v1.FloatArray";
  }
  protected:
  explicit FloatArray(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated float values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  private:
  float _internal_values(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_values() const;
  void _internal_add_values(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_values();
  public:
  float values(int index) const;
  void set_values(int index, float value);
  void add_values(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:sdv.databroker.v1.FloatArray)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > values_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sdv_2fdatabroker_2fv1_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class DoubleArray final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sdv.databroker.v1.DoubleArray) */ {
 public:
  inline DoubleArray() : DoubleArray(nullptr) {}
  ~DoubleArray() override;
  explicit PROTOBUF_CONSTEXPR DoubleArray(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DoubleArray(const DoubleArray& from);
  DoubleArray(DoubleArray&& from) noexcept
    : DoubleArray() {
    *this = ::std::move(from);
  }

  inline DoubleArray& operator=(const DoubleArray& from) {
    CopyFrom(from);
    return *this;
  }
  inline DoubleArray& operator=(DoubleArray&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DoubleArray& default_instance() {
    return *internal_default_instance();
  }
  static inline const DoubleArray* internal_default_instance() {
    return reinterpret_cast<const DoubleArray*>(
               &_DoubleArray_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(DoubleArray& a, DoubleArray& b) {
    a.Swap(&b);
  }
  inline void Swap(DoubleArray* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DoubleArray* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DoubleArray* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DoubleArray>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DoubleArray& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DoubleArray& from) {
    DoubleArray::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DoubleArray* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sdv.databroker.v1.DoubleArray";
  }
  protected:
  explicit DoubleArray(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated double values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  private:
  double _internal_values(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_values() const;
  void _internal_add_values(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_values();
  public:
  double values(int index) const;
  void set_values(int index, double value);
  void add_values(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:sdv.databroker.v1.DoubleArray)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > values_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sdv_2fdatabroker_2fv1_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class Datapoint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sdv.databroker.v1.Datapoint) */ {
 public:
  inline Datapoint() : Datapoint(nullptr) {}
  ~Datapoint() override;
  explicit PROTOBUF_CONSTEXPR Datapoint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Datapoint(const Datapoint& from);
  Datapoint(Datapoint&& from) noexcept
    : Datapoint() {
    *this = ::std::move(from);
  }

  inline Datapoint& operator=(const Datapoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline Datapoint& operator=(Datapoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Datapoint& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kFailureValue = 10,
    kStringValue = 11,
    kBoolValue = 12,
    kInt32Value = 13,
    kInt64Value = 14,
    kUint32Value = 15,
    kUint64Value = 16,
    kFloatValue = 17,
    kDoubleValue = 18,
    kStringArray = 21,
    kBoolArray = 22,
    kInt32Array = 23,
    kInt64Array = 24,
    kUint32Array = 25,
    kUint64Array = 26,
    kFloatArray = 27,
    kDoubleArray = 28,
    VALUE_NOT_SET = 0,
  };

  static inline const Datapoint* internal_default_instance() {
    return reinterpret_cast<const Datapoint*>(
               &_Datapoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Datapoint& a, Datapoint& b) {
    a.Swap(&b);
  }
  inline void Swap(Datapoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Datapoint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Datapoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Datapoint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Datapoint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Datapoint& from) {
    Datapoint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Datapoint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sdv.databroker.v1.Datapoint";
  }
  protected:
  explicit Datapoint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Datapoint_Failure Failure;
  static constexpr Failure INVALID_VALUE =
    Datapoint_Failure_INVALID_VALUE;
  static constexpr Failure NOT_AVAILABLE =
    Datapoint_Failure_NOT_AVAILABLE;
  static constexpr Failure UNKNOWN_DATAPOINT =
    Datapoint_Failure_UNKNOWN_DATAPOINT;
  static constexpr Failure ACCESS_DENIED =
    Datapoint_Failure_ACCESS_DENIED;
  static constexpr Failure INTERNAL_ERROR =
    Datapoint_Failure_INTERNAL_ERROR;
  static inline bool Failure_IsValid(int value) {
    return Datapoint_Failure_IsValid(value);
  }
  static constexpr Failure Failure_MIN =
    Datapoint_Failure_Failure_MIN;
  static constexpr Failure Failure_MAX =
    Datapoint_Failure_Failure_MAX;
  static constexpr int Failure_ARRAYSIZE =
    Datapoint_Failure_Failure_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Failure_descriptor() {
    return Datapoint_Failure_descriptor();
  }
  template<typename T>
  static inline const std::string& Failure_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Failure>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Failure_Name.");
    return Datapoint_Failure_Name(enum_t_value);
  }
  static inline bool Failure_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Failure* value) {
    return Datapoint_Failure_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 1,
    kFailureValueFieldNumber = 10,
    kStringValueFieldNumber = 11,
    kBoolValueFieldNumber = 12,
    kInt32ValueFieldNumber = 13,
    kInt64ValueFieldNumber = 14,
    kUint32ValueFieldNumber = 15,
    kUint64ValueFieldNumber = 16,
    kFloatValueFieldNumber = 17,
    kDoubleValueFieldNumber = 18,
    kStringArrayFieldNumber = 21,
    kBoolArrayFieldNumber = 22,
    kInt32ArrayFieldNumber = 23,
    kInt64ArrayFieldNumber = 24,
    kUint32ArrayFieldNumber = 25,
    kUint64ArrayFieldNumber = 26,
    kFloatArrayFieldNumber = 27,
    kDoubleArrayFieldNumber = 28,
  };
  // .google.protobuf.Timestamp timestamp = 1;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // .sdv.databroker.v1.Datapoint.Failure failure_value = 10;
  bool has_failure_value() const;
  private:
  bool _internal_has_failure_value() const;
  public:
  void clear_failure_value();
  ::sdv::databroker::v1::Datapoint_Failure failure_value() const;
  void set_failure_value(::sdv::databroker::v1::Datapoint_Failure value);
  private:
  ::sdv::databroker::v1::Datapoint_Failure _internal_failure_value() const;
  void _internal_set_failure_value(::sdv::databroker::v1::Datapoint_Failure value);
  public:

  // string string_value = 11;
  bool has_string_value() const;
  private:
  bool _internal_has_string_value() const;
  public:
  void clear_string_value();
  const std::string& string_value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_string_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_string_value();
  PROTOBUF_NODISCARD std::string* release_string_value();
  void set_allocated_string_value(std::string* string_value);
  private:
  const std::string& _internal_string_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_string_value(const std::string& value);
  std::string* _internal_mutable_string_value();
  public:

  // bool bool_value = 12;
  bool has_bool_value() const;
  private:
  bool _internal_has_bool_value() const;
  public:
  void clear_bool_value();
  bool bool_value() const;
  void set_bool_value(bool value);
  private:
  bool _internal_bool_value() const;
  void _internal_set_bool_value(bool value);
  public:

  // sint32 int32_value = 13;
  bool has_int32_value() const;
  private:
  bool _internal_has_int32_value() const;
  public:
  void clear_int32_value();
  int32_t int32_value() const;
  void set_int32_value(int32_t value);
  private:
  int32_t _internal_int32_value() const;
  void _internal_set_int32_value(int32_t value);
  public:

  // sint64 int64_value = 14;
  bool has_int64_value() const;
  private:
  bool _internal_has_int64_value() const;
  public:
  void clear_int64_value();
  int64_t int64_value() const;
  void set_int64_value(int64_t value);
  private:
  int64_t _internal_int64_value() const;
  void _internal_set_int64_value(int64_t value);
  public:

  // uint32 uint32_value = 15;
  bool has_uint32_value() const;
  private:
  bool _internal_has_uint32_value() const;
  public:
  void clear_uint32_value();
  uint32_t uint32_value() const;
  void set_uint32_value(uint32_t value);
  private:
  uint32_t _internal_uint32_value() const;
  void _internal_set_uint32_value(uint32_t value);
  public:

  // uint64 uint64_value = 16;
  bool has_uint64_value() const;
  private:
  bool _internal_has_uint64_value() const;
  public:
  void clear_uint64_value();
  uint64_t uint64_value() const;
  void set_uint64_value(uint64_t value);
  private:
  uint64_t _internal_uint64_value() const;
  void _internal_set_uint64_value(uint64_t value);
  public:

  // float float_value = 17;
  bool has_float_value() const;
  private:
  bool _internal_has_float_value() const;
  public:
  void clear_float_value();
  float float_value() const;
  void set_float_value(float value);
  private:
  float _internal_float_value() const;
  void _internal_set_float_value(float value);
  public:

  // double double_value = 18;
  bool has_double_value() const;
  private:
  bool _internal_has_double_value() const;
  public:
  void clear_double_value();
  double double_value() const;
  void set_double_value(double value);
  private:
  double _internal_double_value() const;
  void _internal_set_double_value(double value);
  public:

  // .sdv.databroker.v1.StringArray string_array = 21;
  bool has_string_array() const;
  private:
  bool _internal_has_string_array() const;
  public:
  void clear_string_array();
  const ::sdv::databroker::v1::StringArray& string_array() const;
  PROTOBUF_NODISCARD ::sdv::databroker::v1::StringArray* release_string_array();
  ::sdv::databroker::v1::StringArray* mutable_string_array();
  void set_allocated_string_array(::sdv::databroker::v1::StringArray* string_array);
  private:
  const ::sdv::databroker::v1::StringArray& _internal_string_array() const;
  ::sdv::databroker::v1::StringArray* _internal_mutable_string_array();
  public:
  void unsafe_arena_set_allocated_string_array(
      ::sdv::databroker::v1::StringArray* string_array);
  ::sdv::databroker::v1::StringArray* unsafe_arena_release_string_array();

  // .sdv.databroker.v1.BoolArray bool_array = 22;
  bool has_bool_array() const;
  private:
  bool _internal_has_bool_array() const;
  public:
  void clear_bool_array();
  const ::sdv::databroker::v1::BoolArray& bool_array() const;
  PROTOBUF_NODISCARD ::sdv::databroker::v1::BoolArray* release_bool_array();
  ::sdv::databroker::v1::BoolArray* mutable_bool_array();
  void set_allocated_bool_array(::sdv::databroker::v1::BoolArray* bool_array);
  private:
  const ::sdv::databroker::v1::BoolArray& _internal_bool_array() const;
  ::sdv::databroker::v1::BoolArray* _internal_mutable_bool_array();
  public:
  void unsafe_arena_set_allocated_bool_array(
      ::sdv::databroker::v1::BoolArray* bool_array);
  ::sdv::databroker::v1::BoolArray* unsafe_arena_release_bool_array();

  // .sdv.databroker.v1.Int32Array int32_array = 23;
  bool has_int32_array() const;
  private:
  bool _internal_has_int32_array() const;
  public:
  void clear_int32_array();
  const ::sdv::databroker::v1::Int32Array& int32_array() const;
  PROTOBUF_NODISCARD ::sdv::databroker::v1::Int32Array* release_int32_array();
  ::sdv::databroker::v1::Int32Array* mutable_int32_array();
  void set_allocated_int32_array(::sdv::databroker::v1::Int32Array* int32_array);
  private:
  const ::sdv::databroker::v1::Int32Array& _internal_int32_array() const;
  ::sdv::databroker::v1::Int32Array* _internal_mutable_int32_array();
  public:
  void unsafe_arena_set_allocated_int32_array(
      ::sdv::databroker::v1::Int32Array* int32_array);
  ::sdv::databroker::v1::Int32Array* unsafe_arena_release_int32_array();

  // .sdv.databroker.v1.Int64Array int64_array = 24;
  bool has_int64_array() const;
  private:
  bool _internal_has_int64_array() const;
  public:
  void clear_int64_array();
  const ::sdv::databroker::v1::Int64Array& int64_array() const;
  PROTOBUF_NODISCARD ::sdv::databroker::v1::Int64Array* release_int64_array();
  ::sdv::databroker::v1::Int64Array* mutable_int64_array();
  void set_allocated_int64_array(::sdv::databroker::v1::Int64Array* int64_array);
  private:
  const ::sdv::databroker::v1::Int64Array& _internal_int64_array() const;
  ::sdv::databroker::v1::Int64Array* _internal_mutable_int64_array();
  public:
  void unsafe_arena_set_allocated_int64_array(
      ::sdv::databroker::v1::Int64Array* int64_array);
  ::sdv::databroker::v1::Int64Array* unsafe_arena_release_int64_array();

  // .sdv.databroker.v1.Uint32Array uint32_array = 25;
  bool has_uint32_array() const;
  private:
  bool _internal_has_uint32_array() const;
  public:
  void clear_uint32_array();
  const ::sdv::databroker::v1::Uint32Array& uint32_array() const;
  PROTOBUF_NODISCARD ::sdv::databroker::v1::Uint32Array* release_uint32_array();
  ::sdv::databroker::v1::Uint32Array* mutable_uint32_array();
  void set_allocated_uint32_array(::sdv::databroker::v1::Uint32Array* uint32_array);
  private:
  const ::sdv::databroker::v1::Uint32Array& _internal_uint32_array() const;
  ::sdv::databroker::v1::Uint32Array* _internal_mutable_uint32_array();
  public:
  void unsafe_arena_set_allocated_uint32_array(
      ::sdv::databroker::v1::Uint32Array* uint32_array);
  ::sdv::databroker::v1::Uint32Array* unsafe_arena_release_uint32_array();

  // .sdv.databroker.v1.Uint64Array uint64_array = 26;
  bool has_uint64_array() const;
  private:
  bool _internal_has_uint64_array() const;
  public:
  void clear_uint64_array();
  const ::sdv::databroker::v1::Uint64Array& uint64_array() const;
  PROTOBUF_NODISCARD ::sdv::databroker::v1::Uint64Array* release_uint64_array();
  ::sdv::databroker::v1::Uint64Array* mutable_uint64_array();
  void set_allocated_uint64_array(::sdv::databroker::v1::Uint64Array* uint64_array);
  private:
  const ::sdv::databroker::v1::Uint64Array& _internal_uint64_array() const;
  ::sdv::databroker::v1::Uint64Array* _internal_mutable_uint64_array();
  public:
  void unsafe_arena_set_allocated_uint64_array(
      ::sdv::databroker::v1::Uint64Array* uint64_array);
  ::sdv::databroker::v1::Uint64Array* unsafe_arena_release_uint64_array();

  // .sdv.databroker.v1.FloatArray float_array = 27;
  bool has_float_array() const;
  private:
  bool _internal_has_float_array() const;
  public:
  void clear_float_array();
  const ::sdv::databroker::v1::FloatArray& float_array() const;
  PROTOBUF_NODISCARD ::sdv::databroker::v1::FloatArray* release_float_array();
  ::sdv::databroker::v1::FloatArray* mutable_float_array();
  void set_allocated_float_array(::sdv::databroker::v1::FloatArray* float_array);
  private:
  const ::sdv::databroker::v1::FloatArray& _internal_float_array() const;
  ::sdv::databroker::v1::FloatArray* _internal_mutable_float_array();
  public:
  void unsafe_arena_set_allocated_float_array(
      ::sdv::databroker::v1::FloatArray* float_array);
  ::sdv::databroker::v1::FloatArray* unsafe_arena_release_float_array();

  // .sdv.databroker.v1.DoubleArray double_array = 28;
  bool has_double_array() const;
  private:
  bool _internal_has_double_array() const;
  public:
  void clear_double_array();
  const ::sdv::databroker::v1::DoubleArray& double_array() const;
  PROTOBUF_NODISCARD ::sdv::databroker::v1::DoubleArray* release_double_array();
  ::sdv::databroker::v1::DoubleArray* mutable_double_array();
  void set_allocated_double_array(::sdv::databroker::v1::DoubleArray* double_array);
  private:
  const ::sdv::databroker::v1::DoubleArray& _internal_double_array() const;
  ::sdv::databroker::v1::DoubleArray* _internal_mutable_double_array();
  public:
  void unsafe_arena_set_allocated_double_array(
      ::sdv::databroker::v1::DoubleArray* double_array);
  ::sdv::databroker::v1::DoubleArray* unsafe_arena_release_double_array();

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:sdv.databroker.v1.Datapoint)
 private:
  class _Internal;
  void set_has_failure_value();
  void set_has_string_value();
  void set_has_bool_value();
  void set_has_int32_value();
  void set_has_int64_value();
  void set_has_uint32_value();
  void set_has_uint64_value();
  void set_has_float_value();
  void set_has_double_value();
  void set_has_string_array();
  void set_has_bool_array();
  void set_has_int32_array();
  void set_has_int64_array();
  void set_has_uint32_array();
  void set_has_uint64_array();
  void set_has_float_array();
  void set_has_double_array();

  inline bool has_value() const;
  inline void clear_has_value();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
    union ValueUnion {
      constexpr ValueUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      int failure_value_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr string_value_;
      bool bool_value_;
      int32_t int32_value_;
      int64_t int64_value_;
      uint32_t uint32_value_;
      uint64_t uint64_value_;
      float float_value_;
      double double_value_;
      ::sdv::databroker::v1::StringArray* string_array_;
      ::sdv::databroker::v1::BoolArray* bool_array_;
      ::sdv::databroker::v1::Int32Array* int32_array_;
      ::sdv::databroker::v1::Int64Array* int64_array_;
      ::sdv::databroker::v1::Uint32Array* uint32_array_;
      ::sdv::databroker::v1::Uint64Array* uint64_array_;
      ::sdv::databroker::v1::FloatArray* float_array_;
      ::sdv::databroker::v1::DoubleArray* double_array_;
    } value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sdv_2fdatabroker_2fv1_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class Metadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sdv.databroker.v1.Metadata) */ {
 public:
  inline Metadata() : Metadata(nullptr) {}
  ~Metadata() override;
  explicit PROTOBUF_CONSTEXPR Metadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Metadata(const Metadata& from);
  Metadata(Metadata&& from) noexcept
    : Metadata() {
    *this = ::std::move(from);
  }

  inline Metadata& operator=(const Metadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline Metadata& operator=(Metadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Metadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const Metadata* internal_default_instance() {
    return reinterpret_cast<const Metadata*>(
               &_Metadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Metadata& a, Metadata& b) {
    a.Swap(&b);
  }
  inline void Swap(Metadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Metadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Metadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Metadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Metadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Metadata& from) {
    Metadata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Metadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sdv.databroker.v1.Metadata";
  }
  protected:
  explicit Metadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 4,
    kDescriptionFieldNumber = 7,
    kIdFieldNumber = 1,
    kEntryTypeFieldNumber = 2,
    kDataTypeFieldNumber = 5,
    kChangeTypeFieldNumber = 6,
  };
  // string name = 4;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string description = 7;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // int32 id = 1;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // .sdv.databroker.v1.EntryType entry_type = 2;
  void clear_entry_type();
  ::sdv::databroker::v1::EntryType entry_type() const;
  void set_entry_type(::sdv::databroker::v1::EntryType value);
  private:
  ::sdv::databroker::v1::EntryType _internal_entry_type() const;
  void _internal_set_entry_type(::sdv::databroker::v1::EntryType value);
  public:

  // .sdv.databroker.v1.DataType data_type = 5;
  void clear_data_type();
  ::sdv::databroker::v1::DataType data_type() const;
  void set_data_type(::sdv::databroker::v1::DataType value);
  private:
  ::sdv::databroker::v1::DataType _internal_data_type() const;
  void _internal_set_data_type(::sdv::databroker::v1::DataType value);
  public:

  // .sdv.databroker.v1.ChangeType change_type = 6;
  void clear_change_type();
  ::sdv::databroker::v1::ChangeType change_type() const;
  void set_change_type(::sdv::databroker::v1::ChangeType value);
  private:
  ::sdv::databroker::v1::ChangeType _internal_change_type() const;
  void _internal_set_change_type(::sdv::databroker::v1::ChangeType value);
  public:

  // @@protoc_insertion_point(class_scope:sdv.databroker.v1.Metadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    int32_t id_;
    int entry_type_;
    int data_type_;
    int change_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sdv_2fdatabroker_2fv1_2ftypes_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// StringArray

// repeated string values = 1;
inline int StringArray::_internal_values_size() const {
  return _impl_.values_.size();
}
inline int StringArray::values_size() const {
  return _internal_values_size();
}
inline void StringArray::clear_values() {
  _impl_.values_.Clear();
}
inline std::string* StringArray::add_values() {
  std::string* _s = _internal_add_values();
  // @@protoc_insertion_point(field_add_mutable:sdv.databroker.v1.StringArray.values)
  return _s;
}
inline const std::string& StringArray::_internal_values(int index) const {
  return _impl_.values_.Get(index);
}
inline const std::string& StringArray::values(int index) const {
  // @@protoc_insertion_point(field_get:sdv.databroker.v1.StringArray.values)
  return _internal_values(index);
}
inline std::string* StringArray::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:sdv.databroker.v1.StringArray.values)
  return _impl_.values_.Mutable(index);
}
inline void StringArray::set_values(int index, const std::string& value) {
  _impl_.values_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:sdv.databroker.v1.StringArray.values)
}
inline void StringArray::set_values(int index, std::string&& value) {
  _impl_.values_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:sdv.databroker.v1.StringArray.values)
}
inline void StringArray::set_values(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.values_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:sdv.databroker.v1.StringArray.values)
}
inline void StringArray::set_values(int index, const char* value, size_t size) {
  _impl_.values_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:sdv.databroker.v1.StringArray.values)
}
inline std::string* StringArray::_internal_add_values() {
  return _impl_.values_.Add();
}
inline void StringArray::add_values(const std::string& value) {
  _impl_.values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:sdv.databroker.v1.StringArray.values)
}
inline void StringArray::add_values(std::string&& value) {
  _impl_.values_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:sdv.databroker.v1.StringArray.values)
}
inline void StringArray::add_values(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:sdv.databroker.v1.StringArray.values)
}
inline void StringArray::add_values(const char* value, size_t size) {
  _impl_.values_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:sdv.databroker.v1.StringArray.values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StringArray::values() const {
  // @@protoc_insertion_point(field_list:sdv.databroker.v1.StringArray.values)
  return _impl_.values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
StringArray::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:sdv.databroker.v1.StringArray.values)
  return &_impl_.values_;
}

// -------------------------------------------------------------------

// BoolArray

// repeated bool values = 1;
inline int BoolArray::_internal_values_size() const {
  return _impl_.values_.size();
}
inline int BoolArray::values_size() const {
  return _internal_values_size();
}
inline void BoolArray::clear_values() {
  _impl_.values_.Clear();
}
inline bool BoolArray::_internal_values(int index) const {
  return _impl_.values_.Get(index);
}
inline bool BoolArray::values(int index) const {
  // @@protoc_insertion_point(field_get:sdv.databroker.v1.BoolArray.values)
  return _internal_values(index);
}
inline void BoolArray::set_values(int index, bool value) {
  _impl_.values_.Set(index, value);
  // @@protoc_insertion_point(field_set:sdv.databroker.v1.BoolArray.values)
}
inline void BoolArray::_internal_add_values(bool value) {
  _impl_.values_.Add(value);
}
inline void BoolArray::add_values(bool value) {
  _internal_add_values(value);
  // @@protoc_insertion_point(field_add:sdv.databroker.v1.BoolArray.values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
BoolArray::_internal_values() const {
  return _impl_.values_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
BoolArray::values() const {
  // @@protoc_insertion_point(field_list:sdv.databroker.v1.BoolArray.values)
  return _internal_values();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
BoolArray::_internal_mutable_values() {
  return &_impl_.values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
BoolArray::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:sdv.databroker.v1.BoolArray.values)
  return _internal_mutable_values();
}

// -------------------------------------------------------------------

// Int32Array

// repeated sint32 values = 1;
inline int Int32Array::_internal_values_size() const {
  return _impl_.values_.size();
}
inline int Int32Array::values_size() const {
  return _internal_values_size();
}
inline void Int32Array::clear_values() {
  _impl_.values_.Clear();
}
inline int32_t Int32Array::_internal_values(int index) const {
  return _impl_.values_.Get(index);
}
inline int32_t Int32Array::values(int index) const {
  // @@protoc_insertion_point(field_get:sdv.databroker.v1.Int32Array.values)
  return _internal_values(index);
}
inline void Int32Array::set_values(int index, int32_t value) {
  _impl_.values_.Set(index, value);
  // @@protoc_insertion_point(field_set:sdv.databroker.v1.Int32Array.values)
}
inline void Int32Array::_internal_add_values(int32_t value) {
  _impl_.values_.Add(value);
}
inline void Int32Array::add_values(int32_t value) {
  _internal_add_values(value);
  // @@protoc_insertion_point(field_add:sdv.databroker.v1.Int32Array.values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
Int32Array::_internal_values() const {
  return _impl_.values_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
Int32Array::values() const {
  // @@protoc_insertion_point(field_list:sdv.databroker.v1.Int32Array.values)
  return _internal_values();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
Int32Array::_internal_mutable_values() {
  return &_impl_.values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
Int32Array::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:sdv.databroker.v1.Int32Array.values)
  return _internal_mutable_values();
}

// -------------------------------------------------------------------

// Int64Array

// repeated sint64 values = 1;
inline int Int64Array::_internal_values_size() const {
  return _impl_.values_.size();
}
inline int Int64Array::values_size() const {
  return _internal_values_size();
}
inline void Int64Array::clear_values() {
  _impl_.values_.Clear();
}
inline int64_t Int64Array::_internal_values(int index) const {
  return _impl_.values_.Get(index);
}
inline int64_t Int64Array::values(int index) const {
  // @@protoc_insertion_point(field_get:sdv.databroker.v1.Int64Array.values)
  return _internal_values(index);
}
inline void Int64Array::set_values(int index, int64_t value) {
  _impl_.values_.Set(index, value);
  // @@protoc_insertion_point(field_set:sdv.databroker.v1.Int64Array.values)
}
inline void Int64Array::_internal_add_values(int64_t value) {
  _impl_.values_.Add(value);
}
inline void Int64Array::add_values(int64_t value) {
  _internal_add_values(value);
  // @@protoc_insertion_point(field_add:sdv.databroker.v1.Int64Array.values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
Int64Array::_internal_values() const {
  return _impl_.values_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
Int64Array::values() const {
  // @@protoc_insertion_point(field_list:sdv.databroker.v1.Int64Array.values)
  return _internal_values();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
Int64Array::_internal_mutable_values() {
  return &_impl_.values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
Int64Array::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:sdv.databroker.v1.Int64Array.values)
  return _internal_mutable_values();
}

// -------------------------------------------------------------------

// Uint32Array

// repeated uint32 values = 1;
inline int Uint32Array::_internal_values_size() const {
  return _impl_.values_.size();
}
inline int Uint32Array::values_size() const {
  return _internal_values_size();
}
inline void Uint32Array::clear_values() {
  _impl_.values_.Clear();
}
inline uint32_t Uint32Array::_internal_values(int index) const {
  return _impl_.values_.Get(index);
}
inline uint32_t Uint32Array::values(int index) const {
  // @@protoc_insertion_point(field_get:sdv.databroker.v1.Uint32Array.values)
  return _internal_values(index);
}
inline void Uint32Array::set_values(int index, uint32_t value) {
  _impl_.values_.Set(index, value);
  // @@protoc_insertion_point(field_set:sdv.databroker.v1.Uint32Array.values)
}
inline void Uint32Array::_internal_add_values(uint32_t value) {
  _impl_.values_.Add(value);
}
inline void Uint32Array::add_values(uint32_t value) {
  _internal_add_values(value);
  // @@protoc_insertion_point(field_add:sdv.databroker.v1.Uint32Array.values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
Uint32Array::_internal_values() const {
  return _impl_.values_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
Uint32Array::values() const {
  // @@protoc_insertion_point(field_list:sdv.databroker.v1.Uint32Array.values)
  return _internal_values();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
Uint32Array::_internal_mutable_values() {
  return &_impl_.values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
Uint32Array::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:sdv.databroker.v1.Uint32Array.values)
  return _internal_mutable_values();
}

// -------------------------------------------------------------------

// Uint64Array

// repeated uint64 values = 1;
inline int Uint64Array::_internal_values_size() const {
  return _impl_.values_.size();
}
inline int Uint64Array::values_size() const {
  return _internal_values_size();
}
inline void Uint64Array::clear_values() {
  _impl_.values_.Clear();
}
inline uint64_t Uint64Array::_internal_values(int index) const {
  return _impl_.values_.Get(index);
}
inline uint64_t Uint64Array::values(int index) const {
  // @@protoc_insertion_point(field_get:sdv.databroker.v1.Uint64Array.values)
  return _internal_values(index);
}
inline void Uint64Array::set_values(int index, uint64_t value) {
  _impl_.values_.Set(index, value);
  // @@protoc_insertion_point(field_set:sdv.databroker.v1.Uint64Array.values)
}
inline void Uint64Array::_internal_add_values(uint64_t value) {
  _impl_.values_.Add(value);
}
inline void Uint64Array::add_values(uint64_t value) {
  _internal_add_values(value);
  // @@protoc_insertion_point(field_add:sdv.databroker.v1.Uint64Array.values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
Uint64Array::_internal_values() const {
  return _impl_.values_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
Uint64Array::values() const {
  // @@protoc_insertion_point(field_list:sdv.databroker.v1.Uint64Array.values)
  return _internal_values();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
Uint64Array::_internal_mutable_values() {
  return &_impl_.values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
Uint64Array::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:sdv.databroker.v1.Uint64Array.values)
  return _internal_mutable_values();
}

// -------------------------------------------------------------------

// FloatArray

// repeated float values = 1;
inline int FloatArray::_internal_values_size() const {
  return _impl_.values_.size();
}
inline int FloatArray::values_size() const {
  return _internal_values_size();
}
inline void FloatArray::clear_values() {
  _impl_.values_.Clear();
}
inline float FloatArray::_internal_values(int index) const {
  return _impl_.values_.Get(index);
}
inline float FloatArray::values(int index) const {
  // @@protoc_insertion_point(field_get:sdv.databroker.v1.FloatArray.values)
  return _internal_values(index);
}
inline void FloatArray::set_values(int index, float value) {
  _impl_.values_.Set(index, value);
  // @@protoc_insertion_point(field_set:sdv.databroker.v1.FloatArray.values)
}
inline void FloatArray::_internal_add_values(float value) {
  _impl_.values_.Add(value);
}
inline void FloatArray::add_values(float value) {
  _internal_add_values(value);
  // @@protoc_insertion_point(field_add:sdv.databroker.v1.FloatArray.values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
FloatArray::_internal_values() const {
  return _impl_.values_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
FloatArray::values() const {
  // @@protoc_insertion_point(field_list:sdv.databroker.v1.FloatArray.values)
  return _internal_values();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
FloatArray::_internal_mutable_values() {
  return &_impl_.values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
FloatArray::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:sdv.databroker.v1.FloatArray.values)
  return _internal_mutable_values();
}

// -------------------------------------------------------------------

// DoubleArray

// repeated double values = 1;
inline int DoubleArray::_internal_values_size() const {
  return _impl_.values_.size();
}
inline int DoubleArray::values_size() const {
  return _internal_values_size();
}
inline void DoubleArray::clear_values() {
  _impl_.values_.Clear();
}
inline double DoubleArray::_internal_values(int index) const {
  return _impl_.values_.Get(index);
}
inline double DoubleArray::values(int index) const {
  // @@protoc_insertion_point(field_get:sdv.databroker.v1.DoubleArray.values)
  return _internal_values(index);
}
inline void DoubleArray::set_values(int index, double value) {
  _impl_.values_.Set(index, value);
  // @@protoc_insertion_point(field_set:sdv.databroker.v1.DoubleArray.values)
}
inline void DoubleArray::_internal_add_values(double value) {
  _impl_.values_.Add(value);
}
inline void DoubleArray::add_values(double value) {
  _internal_add_values(value);
  // @@protoc_insertion_point(field_add:sdv.databroker.v1.DoubleArray.values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
DoubleArray::_internal_values() const {
  return _impl_.values_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
DoubleArray::values() const {
  // @@protoc_insertion_point(field_list:sdv.databroker.v1.DoubleArray.values)
  return _internal_values();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
DoubleArray::_internal_mutable_values() {
  return &_impl_.values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
DoubleArray::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:sdv.databroker.v1.DoubleArray.values)
  return _internal_mutable_values();
}

// -------------------------------------------------------------------

// Datapoint

// .google.protobuf.Timestamp timestamp = 1;
inline bool Datapoint::_internal_has_timestamp() const {
  return this != internal_default_instance() && _impl_.timestamp_ != nullptr;
}
inline bool Datapoint::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Datapoint::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Datapoint::timestamp() const {
  // @@protoc_insertion_point(field_get:sdv.databroker.v1.Datapoint.timestamp)
  return _internal_timestamp();
}
inline void Datapoint::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sdv.databroker.v1.Datapoint.timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Datapoint::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Datapoint::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:sdv.databroker.v1.Datapoint.timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Datapoint::_internal_mutable_timestamp() {
  
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.timestamp_ = p;
  }
  return _impl_.timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Datapoint::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:sdv.databroker.v1.Datapoint.timestamp)
  return _msg;
}
inline void Datapoint::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:sdv.databroker.v1.Datapoint.timestamp)
}

// .sdv.databroker.v1.Datapoint.Failure failure_value = 10;
inline bool Datapoint::_internal_has_failure_value() const {
  return value_case() == kFailureValue;
}
inline bool Datapoint::has_failure_value() const {
  return _internal_has_failure_value();
}
inline void Datapoint::set_has_failure_value() {
  _impl_._oneof_case_[0] = kFailureValue;
}
inline void Datapoint::clear_failure_value() {
  if (_internal_has_failure_value()) {
    _impl_.value_.failure_value_ = 0;
    clear_has_value();
  }
}
inline ::sdv::databroker::v1::Datapoint_Failure Datapoint::_internal_failure_value() const {
  if (_internal_has_failure_value()) {
    return static_cast< ::sdv::databroker::v1::Datapoint_Failure >(_impl_.value_.failure_value_);
  }
  return static_cast< ::sdv::databroker::v1::Datapoint_Failure >(0);
}
inline ::sdv::databroker::v1::Datapoint_Failure Datapoint::failure_value() const {
  // @@protoc_insertion_point(field_get:sdv.databroker.v1.Datapoint.failure_value)
  return _internal_failure_value();
}
inline void Datapoint::_internal_set_failure_value(::sdv::databroker::v1::Datapoint_Failure value) {
  if (!_internal_has_failure_value()) {
    clear_value();
    set_has_failure_value();
  }
  _impl_.value_.failure_value_ = value;
}
inline void Datapoint::set_failure_value(::sdv::databroker::v1::Datapoint_Failure value) {
  _internal_set_failure_value(value);
  // @@protoc_insertion_point(field_set:sdv.databroker.v1.Datapoint.failure_value)
}

// string string_value = 11;
inline bool Datapoint::_internal_has_string_value() const {
  return value_case() == kStringValue;
}
inline bool Datapoint::has_string_value() const {
  return _internal_has_string_value();
}
inline void Datapoint::set_has_string_value() {
  _impl_._oneof_case_[0] = kStringValue;
}
inline void Datapoint::clear_string_value() {
  if (_internal_has_string_value()) {
    _impl_.value_.string_value_.Destroy();
    clear_has_value();
  }
}
inline const std::string& Datapoint::string_value() const {
  // @@protoc_insertion_point(field_get:sdv.databroker.v1.Datapoint.string_value)
  return _internal_string_value();
}
template <typename ArgT0, typename... ArgT>
inline void Datapoint::set_string_value(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_string_value()) {
    clear_value();
    set_has_string_value();
    _impl_.value_.string_value_.InitDefault();
  }
  _impl_.value_.string_value_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sdv.databroker.v1.Datapoint.string_value)
}
inline std::string* Datapoint::mutable_string_value() {
  std::string* _s = _internal_mutable_string_value();
  // @@protoc_insertion_point(field_mutable:sdv.databroker.v1.Datapoint.string_value)
  return _s;
}
inline const std::string& Datapoint::_internal_string_value() const {
  if (_internal_has_string_value()) {
    return _impl_.value_.string_value_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Datapoint::_internal_set_string_value(const std::string& value) {
  if (!_internal_has_string_value()) {
    clear_value();
    set_has_string_value();
    _impl_.value_.string_value_.InitDefault();
  }
  _impl_.value_.string_value_.Set(value, GetArenaForAllocation());
}
inline std::string* Datapoint::_internal_mutable_string_value() {
  if (!_internal_has_string_value()) {
    clear_value();
    set_has_string_value();
    _impl_.value_.string_value_.InitDefault();
  }
  return _impl_.value_.string_value_.Mutable(      GetArenaForAllocation());
}
inline std::string* Datapoint::release_string_value() {
  // @@protoc_insertion_point(field_release:sdv.databroker.v1.Datapoint.string_value)
  if (_internal_has_string_value()) {
    clear_has_value();
    return _impl_.value_.string_value_.Release();
  } else {
    return nullptr;
  }
}
inline void Datapoint::set_allocated_string_value(std::string* string_value) {
  if (has_value()) {
    clear_value();
  }
  if (string_value != nullptr) {
    set_has_string_value();
    _impl_.value_.string_value_.InitAllocated(string_value, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:sdv.databroker.v1.Datapoint.string_value)
}

// bool bool_value = 12;
inline bool Datapoint::_internal_has_bool_value() const {
  return value_case() == kBoolValue;
}
inline bool Datapoint::has_bool_value() const {
  return _internal_has_bool_value();
}
inline void Datapoint::set_has_bool_value() {
  _impl_._oneof_case_[0] = kBoolValue;
}
inline void Datapoint::clear_bool_value() {
  if (_internal_has_bool_value()) {
    _impl_.value_.bool_value_ = false;
    clear_has_value();
  }
}
inline bool Datapoint::_internal_bool_value() const {
  if (_internal_has_bool_value()) {
    return _impl_.value_.bool_value_;
  }
  return false;
}
inline void Datapoint::_internal_set_bool_value(bool value) {
  if (!_internal_has_bool_value()) {
    clear_value();
    set_has_bool_value();
  }
  _impl_.value_.bool_value_ = value;
}
inline bool Datapoint::bool_value() const {
  // @@protoc_insertion_point(field_get:sdv.databroker.v1.Datapoint.bool_value)
  return _internal_bool_value();
}
inline void Datapoint::set_bool_value(bool value) {
  _internal_set_bool_value(value);
  // @@protoc_insertion_point(field_set:sdv.databroker.v1.Datapoint.bool_value)
}

// sint32 int32_value = 13;
inline bool Datapoint::_internal_has_int32_value() const {
  return value_case() == kInt32Value;
}
inline bool Datapoint::has_int32_value() const {
  return _internal_has_int32_value();
}
inline void Datapoint::set_has_int32_value() {
  _impl_._oneof_case_[0] = kInt32Value;
}
inline void Datapoint::clear_int32_value() {
  if (_internal_has_int32_value()) {
    _impl_.value_.int32_value_ = 0;
    clear_has_value();
  }
}
inline int32_t Datapoint::_internal_int32_value() const {
  if (_internal_has_int32_value()) {
    return _impl_.value_.int32_value_;
  }
  return 0;
}
inline void Datapoint::_internal_set_int32_value(int32_t value) {
  if (!_internal_has_int32_value()) {
    clear_value();
    set_has_int32_value();
  }
  _impl_.value_.int32_value_ = value;
}
inline int32_t Datapoint::int32_value() const {
  // @@protoc_insertion_point(field_get:sdv.databroker.v1.Datapoint.int32_value)
  return _internal_int32_value();
}
inline void Datapoint::set_int32_value(int32_t value) {
  _internal_set_int32_value(value);
  // @@protoc_insertion_point(field_set:sdv.databroker.v1.Datapoint.int32_value)
}

// sint64 int64_value = 14;
inline bool Datapoint::_internal_has_int64_value() const {
  return value_case() == kInt64Value;
}
inline bool Datapoint::has_int64_value() const {
  return _internal_has_int64_value();
}
inline void Datapoint::set_has_int64_value() {
  _impl_._oneof_case_[0] = kInt64Value;
}
inline void Datapoint::clear_int64_value() {
  if (_internal_has_int64_value()) {
    _impl_.value_.int64_value_ = int64_t{0};
    clear_has_value();
  }
}
inline int64_t Datapoint::_internal_int64_value() const {
  if (_internal_has_int64_value()) {
    return _impl_.value_.int64_value_;
  }
  return int64_t{0};
}
inline void Datapoint::_internal_set_int64_value(int64_t value) {
  if (!_internal_has_int64_value()) {
    clear_value();
    set_has_int64_value();
  }
  _impl_.value_.int64_value_ = value;
}
inline int64_t Datapoint::int64_value() const {
  // @@protoc_insertion_point(field_get:sdv.databroker.v1.Datapoint.int64_value)
  return _internal_int64_value();
}
inline void Datapoint::set_int64_value(int64_t value) {
  _internal_set_int64_value(value);
  // @@protoc_insertion_point(field_set:sdv.databroker.v1.Datapoint.int64_value)
}

// uint32 uint32_value = 15;
inline bool Datapoint::_internal_has_uint32_value() const {
  return value_case() == kUint32Value;
}
inline bool Datapoint::has_uint32_value() const {
  return _internal_has_uint32_value();
}
inline void Datapoint::set_has_uint32_value() {
  _impl_._oneof_case_[0] = kUint32Value;
}
inline void Datapoint::clear_uint32_value() {
  if (_internal_has_uint32_value()) {
    _impl_.value_.uint32_value_ = 0u;
    clear_has_value();
  }
}
inline uint32_t Datapoint::_internal_uint32_value() const {
  if (_internal_has_uint32_value()) {
    return _impl_.value_.uint32_value_;
  }
  return 0u;
}
inline void Datapoint::_internal_set_uint32_value(uint32_t value) {
  if (!_internal_has_uint32_value()) {
    clear_value();
    set_has_uint32_value();
  }
  _impl_.value_.uint32_value_ = value;
}
inline uint32_t Datapoint::uint32_value() const {
  // @@protoc_insertion_point(field_get:sdv.databroker.v1.Datapoint.uint32_value)
  return _internal_uint32_value();
}
inline void Datapoint::set_uint32_value(uint32_t value) {
  _internal_set_uint32_value(value);
  // @@protoc_insertion_point(field_set:sdv.databroker.v1.Datapoint.uint32_value)
}

// uint64 uint64_value = 16;
inline bool Datapoint::_internal_has_uint64_value() const {
  return value_case() == kUint64Value;
}
inline bool Datapoint::has_uint64_value() const {
  return _internal_has_uint64_value();
}
inline void Datapoint::set_has_uint64_value() {
  _impl_._oneof_case_[0] = kUint64Value;
}
inline void Datapoint::clear_uint64_value() {
  if (_internal_has_uint64_value()) {
    _impl_.value_.uint64_value_ = uint64_t{0u};
    clear_has_value();
  }
}
inline uint64_t Datapoint::_internal_uint64_value() const {
  if (_internal_has_uint64_value()) {
    return _impl_.value_.uint64_value_;
  }
  return uint64_t{0u};
}
inline void Datapoint::_internal_set_uint64_value(uint64_t value) {
  if (!_internal_has_uint64_value()) {
    clear_value();
    set_has_uint64_value();
  }
  _impl_.value_.uint64_value_ = value;
}
inline uint64_t Datapoint::uint64_value() const {
  // @@protoc_insertion_point(field_get:sdv.databroker.v1.Datapoint.uint64_value)
  return _internal_uint64_value();
}
inline void Datapoint::set_uint64_value(uint64_t value) {
  _internal_set_uint64_value(value);
  // @@protoc_insertion_point(field_set:sdv.databroker.v1.Datapoint.uint64_value)
}

// float float_value = 17;
inline bool Datapoint::_internal_has_float_value() const {
  return value_case() == kFloatValue;
}
inline bool Datapoint::has_float_value() const {
  return _internal_has_float_value();
}
inline void Datapoint::set_has_float_value() {
  _impl_._oneof_case_[0] = kFloatValue;
}
inline void Datapoint::clear_float_value() {
  if (_internal_has_float_value()) {
    _impl_.value_.float_value_ = 0;
    clear_has_value();
  }
}
inline float Datapoint::_internal_float_value() const {
  if (_internal_has_float_value()) {
    return _impl_.value_.float_value_;
  }
  return 0;
}
inline void Datapoint::_internal_set_float_value(float value) {
  if (!_internal_has_float_value()) {
    clear_value();
    set_has_float_value();
  }
  _impl_.value_.float_value_ = value;
}
inline float Datapoint::float_value() const {
  // @@protoc_insertion_point(field_get:sdv.databroker.v1.Datapoint.float_value)
  return _internal_float_value();
}
inline void Datapoint::set_float_value(float value) {
  _internal_set_float_value(value);
  // @@protoc_insertion_point(field_set:sdv.databroker.v1.Datapoint.float_value)
}

// double double_value = 18;
inline bool Datapoint::_internal_has_double_value() const {
  return value_case() == kDoubleValue;
}
inline bool Datapoint::has_double_value() const {
  return _internal_has_double_value();
}
inline void Datapoint::set_has_double_value() {
  _impl_._oneof_case_[0] = kDoubleValue;
}
inline void Datapoint::clear_double_value() {
  if (_internal_has_double_value()) {
    _impl_.value_.double_value_ = 0;
    clear_has_value();
  }
}
inline double Datapoint::_internal_double_value() const {
  if (_internal_has_double_value()) {
    return _impl_.value_.double_value_;
  }
  return 0;
}
inline void Datapoint::_internal_set_double_value(double value) {
  if (!_internal_has_double_value()) {
    clear_value();
    set_has_double_value();
  }
  _impl_.value_.double_value_ = value;
}
inline double Datapoint::double_value() const {
  // @@protoc_insertion_point(field_get:sdv.databroker.v1.Datapoint.double_value)
  return _internal_double_value();
}
inline void Datapoint::set_double_value(double value) {
  _internal_set_double_value(value);
  // @@protoc_insertion_point(field_set:sdv.databroker.v1.Datapoint.double_value)
}

// .sdv.databroker.v1.StringArray string_array = 21;
inline bool Datapoint::_internal_has_string_array() const {
  return value_case() == kStringArray;
}
inline bool Datapoint::has_string_array() const {
  return _internal_has_string_array();
}
inline void Datapoint::set_has_string_array() {
  _impl_._oneof_case_[0] = kStringArray;
}
inline void Datapoint::clear_string_array() {
  if (_internal_has_string_array()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.string_array_;
    }
    clear_has_value();
  }
}
inline ::sdv::databroker::v1::StringArray* Datapoint::release_string_array() {
  // @@protoc_insertion_point(field_release:sdv.databroker.v1.Datapoint.string_array)
  if (_internal_has_string_array()) {
    clear_has_value();
    ::sdv::databroker::v1::StringArray* temp = _impl_.value_.string_array_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.string_array_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sdv::databroker::v1::StringArray& Datapoint::_internal_string_array() const {
  return _internal_has_string_array()
      ? *_impl_.value_.string_array_
      : reinterpret_cast< ::sdv::databroker::v1::StringArray&>(::sdv::databroker::v1::_StringArray_default_instance_);
}
inline const ::sdv::databroker::v1::StringArray& Datapoint::string_array() const {
  // @@protoc_insertion_point(field_get:sdv.databroker.v1.Datapoint.string_array)
  return _internal_string_array();
}
inline ::sdv::databroker::v1::StringArray* Datapoint::unsafe_arena_release_string_array() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sdv.databroker.v1.Datapoint.string_array)
  if (_internal_has_string_array()) {
    clear_has_value();
    ::sdv::databroker::v1::StringArray* temp = _impl_.value_.string_array_;
    _impl_.value_.string_array_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Datapoint::unsafe_arena_set_allocated_string_array(::sdv::databroker::v1::StringArray* string_array) {
  clear_value();
  if (string_array) {
    set_has_string_array();
    _impl_.value_.string_array_ = string_array;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sdv.databroker.v1.Datapoint.string_array)
}
inline ::sdv::databroker::v1::StringArray* Datapoint::_internal_mutable_string_array() {
  if (!_internal_has_string_array()) {
    clear_value();
    set_has_string_array();
    _impl_.value_.string_array_ = CreateMaybeMessage< ::sdv::databroker::v1::StringArray >(GetArenaForAllocation());
  }
  return _impl_.value_.string_array_;
}
inline ::sdv::databroker::v1::StringArray* Datapoint::mutable_string_array() {
  ::sdv::databroker::v1::StringArray* _msg = _internal_mutable_string_array();
  // @@protoc_insertion_point(field_mutable:sdv.databroker.v1.Datapoint.string_array)
  return _msg;
}

// .sdv.databroker.v1.BoolArray bool_array = 22;
inline bool Datapoint::_internal_has_bool_array() const {
  return value_case() == kBoolArray;
}
inline bool Datapoint::has_bool_array() const {
  return _internal_has_bool_array();
}
inline void Datapoint::set_has_bool_array() {
  _impl_._oneof_case_[0] = kBoolArray;
}
inline void Datapoint::clear_bool_array() {
  if (_internal_has_bool_array()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.bool_array_;
    }
    clear_has_value();
  }
}
inline ::sdv::databroker::v1::BoolArray* Datapoint::release_bool_array() {
  // @@protoc_insertion_point(field_release:sdv.databroker.v1.Datapoint.bool_array)
  if (_internal_has_bool_array()) {
    clear_has_value();
    ::sdv::databroker::v1::BoolArray* temp = _impl_.value_.bool_array_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.bool_array_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sdv::databroker::v1::BoolArray& Datapoint::_internal_bool_array() const {
  return _internal_has_bool_array()
      ? *_impl_.value_.bool_array_
      : reinterpret_cast< ::sdv::databroker::v1::BoolArray&>(::sdv::databroker::v1::_BoolArray_default_instance_);
}
inline const ::sdv::databroker::v1::BoolArray& Datapoint::bool_array() const {
  // @@protoc_insertion_point(field_get:sdv.databroker.v1.Datapoint.bool_array)
  return _internal_bool_array();
}
inline ::sdv::databroker::v1::BoolArray* Datapoint::unsafe_arena_release_bool_array() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sdv.databroker.v1.Datapoint.bool_array)
  if (_internal_has_bool_array()) {
    clear_has_value();
    ::sdv::databroker::v1::BoolArray* temp = _impl_.value_.bool_array_;
    _impl_.value_.bool_array_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Datapoint::unsafe_arena_set_allocated_bool_array(::sdv::databroker::v1::BoolArray* bool_array) {
  clear_value();
  if (bool_array) {
    set_has_bool_array();
    _impl_.value_.bool_array_ = bool_array;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sdv.databroker.v1.Datapoint.bool_array)
}
inline ::sdv::databroker::v1::BoolArray* Datapoint::_internal_mutable_bool_array() {
  if (!_internal_has_bool_array()) {
    clear_value();
    set_has_bool_array();
    _impl_.value_.bool_array_ = CreateMaybeMessage< ::sdv::databroker::v1::BoolArray >(GetArenaForAllocation());
  }
  return _impl_.value_.bool_array_;
}
inline ::sdv::databroker::v1::BoolArray* Datapoint::mutable_bool_array() {
  ::sdv::databroker::v1::BoolArray* _msg = _internal_mutable_bool_array();
  // @@protoc_insertion_point(field_mutable:sdv.databroker.v1.Datapoint.bool_array)
  return _msg;
}

// .sdv.databroker.v1.Int32Array int32_array = 23;
inline bool Datapoint::_internal_has_int32_array() const {
  return value_case() == kInt32Array;
}
inline bool Datapoint::has_int32_array() const {
  return _internal_has_int32_array();
}
inline void Datapoint::set_has_int32_array() {
  _impl_._oneof_case_[0] = kInt32Array;
}
inline void Datapoint::clear_int32_array() {
  if (_internal_has_int32_array()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.int32_array_;
    }
    clear_has_value();
  }
}
inline ::sdv::databroker::v1::Int32Array* Datapoint::release_int32_array() {
  // @@protoc_insertion_point(field_release:sdv.databroker.v1.Datapoint.int32_array)
  if (_internal_has_int32_array()) {
    clear_has_value();
    ::sdv::databroker::v1::Int32Array* temp = _impl_.value_.int32_array_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.int32_array_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sdv::databroker::v1::Int32Array& Datapoint::_internal_int32_array() const {
  return _internal_has_int32_array()
      ? *_impl_.value_.int32_array_
      : reinterpret_cast< ::sdv::databroker::v1::Int32Array&>(::sdv::databroker::v1::_Int32Array_default_instance_);
}
inline const ::sdv::databroker::v1::Int32Array& Datapoint::int32_array() const {
  // @@protoc_insertion_point(field_get:sdv.databroker.v1.Datapoint.int32_array)
  return _internal_int32_array();
}
inline ::sdv::databroker::v1::Int32Array* Datapoint::unsafe_arena_release_int32_array() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sdv.databroker.v1.Datapoint.int32_array)
  if (_internal_has_int32_array()) {
    clear_has_value();
    ::sdv::databroker::v1::Int32Array* temp = _impl_.value_.int32_array_;
    _impl_.value_.int32_array_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Datapoint::unsafe_arena_set_allocated_int32_array(::sdv::databroker::v1::Int32Array* int32_array) {
  clear_value();
  if (int32_array) {
    set_has_int32_array();
    _impl_.value_.int32_array_ = int32_array;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sdv.databroker.v1.Datapoint.int32_array)
}
inline ::sdv::databroker::v1::Int32Array* Datapoint::_internal_mutable_int32_array() {
  if (!_internal_has_int32_array()) {
    clear_value();
    set_has_int32_array();
    _impl_.value_.int32_array_ = CreateMaybeMessage< ::sdv::databroker::v1::Int32Array >(GetArenaForAllocation());
  }
  return _impl_.value_.int32_array_;
}
inline ::sdv::databroker::v1::Int32Array* Datapoint::mutable_int32_array() {
  ::sdv::databroker::v1::Int32Array* _msg = _internal_mutable_int32_array();
  // @@protoc_insertion_point(field_mutable:sdv.databroker.v1.Datapoint.int32_array)
  return _msg;
}

// .sdv.databroker.v1.Int64Array int64_array = 24;
inline bool Datapoint::_internal_has_int64_array() const {
  return value_case() == kInt64Array;
}
inline bool Datapoint::has_int64_array() const {
  return _internal_has_int64_array();
}
inline void Datapoint::set_has_int64_array() {
  _impl_._oneof_case_[0] = kInt64Array;
}
inline void Datapoint::clear_int64_array() {
  if (_internal_has_int64_array()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.int64_array_;
    }
    clear_has_value();
  }
}
inline ::sdv::databroker::v1::Int64Array* Datapoint::release_int64_array() {
  // @@protoc_insertion_point(field_release:sdv.databroker.v1.Datapoint.int64_array)
  if (_internal_has_int64_array()) {
    clear_has_value();
    ::sdv::databroker::v1::Int64Array* temp = _impl_.value_.int64_array_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.int64_array_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sdv::databroker::v1::Int64Array& Datapoint::_internal_int64_array() const {
  return _internal_has_int64_array()
      ? *_impl_.value_.int64_array_
      : reinterpret_cast< ::sdv::databroker::v1::Int64Array&>(::sdv::databroker::v1::_Int64Array_default_instance_);
}
inline const ::sdv::databroker::v1::Int64Array& Datapoint::int64_array() const {
  // @@protoc_insertion_point(field_get:sdv.databroker.v1.Datapoint.int64_array)
  return _internal_int64_array();
}
inline ::sdv::databroker::v1::Int64Array* Datapoint::unsafe_arena_release_int64_array() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sdv.databroker.v1.Datapoint.int64_array)
  if (_internal_has_int64_array()) {
    clear_has_value();
    ::sdv::databroker::v1::Int64Array* temp = _impl_.value_.int64_array_;
    _impl_.value_.int64_array_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Datapoint::unsafe_arena_set_allocated_int64_array(::sdv::databroker::v1::Int64Array* int64_array) {
  clear_value();
  if (int64_array) {
    set_has_int64_array();
    _impl_.value_.int64_array_ = int64_array;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sdv.databroker.v1.Datapoint.int64_array)
}
inline ::sdv::databroker::v1::Int64Array* Datapoint::_internal_mutable_int64_array() {
  if (!_internal_has_int64_array()) {
    clear_value();
    set_has_int64_array();
    _impl_.value_.int64_array_ = CreateMaybeMessage< ::sdv::databroker::v1::Int64Array >(GetArenaForAllocation());
  }
  return _impl_.value_.int64_array_;
}
inline ::sdv::databroker::v1::Int64Array* Datapoint::mutable_int64_array() {
  ::sdv::databroker::v1::Int64Array* _msg = _internal_mutable_int64_array();
  // @@protoc_insertion_point(field_mutable:sdv.databroker.v1.Datapoint.int64_array)
  return _msg;
}

// .sdv.databroker.v1.Uint32Array uint32_array = 25;
inline bool Datapoint::_internal_has_uint32_array() const {
  return value_case() == kUint32Array;
}
inline bool Datapoint::has_uint32_array() const {
  return _internal_has_uint32_array();
}
inline void Datapoint::set_has_uint32_array() {
  _impl_._oneof_case_[0] = kUint32Array;
}
inline void Datapoint::clear_uint32_array() {
  if (_internal_has_uint32_array()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.uint32_array_;
    }
    clear_has_value();
  }
}
inline ::sdv::databroker::v1::Uint32Array* Datapoint::release_uint32_array() {
  // @@protoc_insertion_point(field_release:sdv.databroker.v1.Datapoint.uint32_array)
  if (_internal_has_uint32_array()) {
    clear_has_value();
    ::sdv::databroker::v1::Uint32Array* temp = _impl_.value_.uint32_array_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.uint32_array_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sdv::databroker::v1::Uint32Array& Datapoint::_internal_uint32_array() const {
  return _internal_has_uint32_array()
      ? *_impl_.value_.uint32_array_
      : reinterpret_cast< ::sdv::databroker::v1::Uint32Array&>(::sdv::databroker::v1::_Uint32Array_default_instance_);
}
inline const ::sdv::databroker::v1::Uint32Array& Datapoint::uint32_array() const {
  // @@protoc_insertion_point(field_get:sdv.databroker.v1.Datapoint.uint32_array)
  return _internal_uint32_array();
}
inline ::sdv::databroker::v1::Uint32Array* Datapoint::unsafe_arena_release_uint32_array() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sdv.databroker.v1.Datapoint.uint32_array)
  if (_internal_has_uint32_array()) {
    clear_has_value();
    ::sdv::databroker::v1::Uint32Array* temp = _impl_.value_.uint32_array_;
    _impl_.value_.uint32_array_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Datapoint::unsafe_arena_set_allocated_uint32_array(::sdv::databroker::v1::Uint32Array* uint32_array) {
  clear_value();
  if (uint32_array) {
    set_has_uint32_array();
    _impl_.value_.uint32_array_ = uint32_array;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sdv.databroker.v1.Datapoint.uint32_array)
}
inline ::sdv::databroker::v1::Uint32Array* Datapoint::_internal_mutable_uint32_array() {
  if (!_internal_has_uint32_array()) {
    clear_value();
    set_has_uint32_array();
    _impl_.value_.uint32_array_ = CreateMaybeMessage< ::sdv::databroker::v1::Uint32Array >(GetArenaForAllocation());
  }
  return _impl_.value_.uint32_array_;
}
inline ::sdv::databroker::v1::Uint32Array* Datapoint::mutable_uint32_array() {
  ::sdv::databroker::v1::Uint32Array* _msg = _internal_mutable_uint32_array();
  // @@protoc_insertion_point(field_mutable:sdv.databroker.v1.Datapoint.uint32_array)
  return _msg;
}

// .sdv.databroker.v1.Uint64Array uint64_array = 26;
inline bool Datapoint::_internal_has_uint64_array() const {
  return value_case() == kUint64Array;
}
inline bool Datapoint::has_uint64_array() const {
  return _internal_has_uint64_array();
}
inline void Datapoint::set_has_uint64_array() {
  _impl_._oneof_case_[0] = kUint64Array;
}
inline void Datapoint::clear_uint64_array() {
  if (_internal_has_uint64_array()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.uint64_array_;
    }
    clear_has_value();
  }
}
inline ::sdv::databroker::v1::Uint64Array* Datapoint::release_uint64_array() {
  // @@protoc_insertion_point(field_release:sdv.databroker.v1.Datapoint.uint64_array)
  if (_internal_has_uint64_array()) {
    clear_has_value();
    ::sdv::databroker::v1::Uint64Array* temp = _impl_.value_.uint64_array_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.uint64_array_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sdv::databroker::v1::Uint64Array& Datapoint::_internal_uint64_array() const {
  return _internal_has_uint64_array()
      ? *_impl_.value_.uint64_array_
      : reinterpret_cast< ::sdv::databroker::v1::Uint64Array&>(::sdv::databroker::v1::_Uint64Array_default_instance_);
}
inline const ::sdv::databroker::v1::Uint64Array& Datapoint::uint64_array() const {
  // @@protoc_insertion_point(field_get:sdv.databroker.v1.Datapoint.uint64_array)
  return _internal_uint64_array();
}
inline ::sdv::databroker::v1::Uint64Array* Datapoint::unsafe_arena_release_uint64_array() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sdv.databroker.v1.Datapoint.uint64_array)
  if (_internal_has_uint64_array()) {
    clear_has_value();
    ::sdv::databroker::v1::Uint64Array* temp = _impl_.value_.uint64_array_;
    _impl_.value_.uint64_array_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Datapoint::unsafe_arena_set_allocated_uint64_array(::sdv::databroker::v1::Uint64Array* uint64_array) {
  clear_value();
  if (uint64_array) {
    set_has_uint64_array();
    _impl_.value_.uint64_array_ = uint64_array;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sdv.databroker.v1.Datapoint.uint64_array)
}
inline ::sdv::databroker::v1::Uint64Array* Datapoint::_internal_mutable_uint64_array() {
  if (!_internal_has_uint64_array()) {
    clear_value();
    set_has_uint64_array();
    _impl_.value_.uint64_array_ = CreateMaybeMessage< ::sdv::databroker::v1::Uint64Array >(GetArenaForAllocation());
  }
  return _impl_.value_.uint64_array_;
}
inline ::sdv::databroker::v1::Uint64Array* Datapoint::mutable_uint64_array() {
  ::sdv::databroker::v1::Uint64Array* _msg = _internal_mutable_uint64_array();
  // @@protoc_insertion_point(field_mutable:sdv.databroker.v1.Datapoint.uint64_array)
  return _msg;
}

// .sdv.databroker.v1.FloatArray float_array = 27;
inline bool Datapoint::_internal_has_float_array() const {
  return value_case() == kFloatArray;
}
inline bool Datapoint::has_float_array() const {
  return _internal_has_float_array();
}
inline void Datapoint::set_has_float_array() {
  _impl_._oneof_case_[0] = kFloatArray;
}
inline void Datapoint::clear_float_array() {
  if (_internal_has_float_array()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.float_array_;
    }
    clear_has_value();
  }
}
inline ::sdv::databroker::v1::FloatArray* Datapoint::release_float_array() {
  // @@protoc_insertion_point(field_release:sdv.databroker.v1.Datapoint.float_array)
  if (_internal_has_float_array()) {
    clear_has_value();
    ::sdv::databroker::v1::FloatArray* temp = _impl_.value_.float_array_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.float_array_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sdv::databroker::v1::FloatArray& Datapoint::_internal_float_array() const {
  return _internal_has_float_array()
      ? *_impl_.value_.float_array_
      : reinterpret_cast< ::sdv::databroker::v1::FloatArray&>(::sdv::databroker::v1::_FloatArray_default_instance_);
}
inline const ::sdv::databroker::v1::FloatArray& Datapoint::float_array() const {
  // @@protoc_insertion_point(field_get:sdv.databroker.v1.Datapoint.float_array)
  return _internal_float_array();
}
inline ::sdv::databroker::v1::FloatArray* Datapoint::unsafe_arena_release_float_array() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sdv.databroker.v1.Datapoint.float_array)
  if (_internal_has_float_array()) {
    clear_has_value();
    ::sdv::databroker::v1::FloatArray* temp = _impl_.value_.float_array_;
    _impl_.value_.float_array_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Datapoint::unsafe_arena_set_allocated_float_array(::sdv::databroker::v1::FloatArray* float_array) {
  clear_value();
  if (float_array) {
    set_has_float_array();
    _impl_.value_.float_array_ = float_array;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sdv.databroker.v1.Datapoint.float_array)
}
inline ::sdv::databroker::v1::FloatArray* Datapoint::_internal_mutable_float_array() {
  if (!_internal_has_float_array()) {
    clear_value();
    set_has_float_array();
    _impl_.value_.float_array_ = CreateMaybeMessage< ::sdv::databroker::v1::FloatArray >(GetArenaForAllocation());
  }
  return _impl_.value_.float_array_;
}
inline ::sdv::databroker::v1::FloatArray* Datapoint::mutable_float_array() {
  ::sdv::databroker::v1::FloatArray* _msg = _internal_mutable_float_array();
  // @@protoc_insertion_point(field_mutable:sdv.databroker.v1.Datapoint.float_array)
  return _msg;
}

// .sdv.databroker.v1.DoubleArray double_array = 28;
inline bool Datapoint::_internal_has_double_array() const {
  return value_case() == kDoubleArray;
}
inline bool Datapoint::has_double_array() const {
  return _internal_has_double_array();
}
inline void Datapoint::set_has_double_array() {
  _impl_._oneof_case_[0] = kDoubleArray;
}
inline void Datapoint::clear_double_array() {
  if (_internal_has_double_array()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.double_array_;
    }
    clear_has_value();
  }
}
inline ::sdv::databroker::v1::DoubleArray* Datapoint::release_double_array() {
  // @@protoc_insertion_point(field_release:sdv.databroker.v1.Datapoint.double_array)
  if (_internal_has_double_array()) {
    clear_has_value();
    ::sdv::databroker::v1::DoubleArray* temp = _impl_.value_.double_array_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.double_array_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sdv::databroker::v1::DoubleArray& Datapoint::_internal_double_array() const {
  return _internal_has_double_array()
      ? *_impl_.value_.double_array_
      : reinterpret_cast< ::sdv::databroker::v1::DoubleArray&>(::sdv::databroker::v1::_DoubleArray_default_instance_);
}
inline const ::sdv::databroker::v1::DoubleArray& Datapoint::double_array() const {
  // @@protoc_insertion_point(field_get:sdv.databroker.v1.Datapoint.double_array)
  return _internal_double_array();
}
inline ::sdv::databroker::v1::DoubleArray* Datapoint::unsafe_arena_release_double_array() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sdv.databroker.v1.Datapoint.double_array)
  if (_internal_has_double_array()) {
    clear_has_value();
    ::sdv::databroker::v1::DoubleArray* temp = _impl_.value_.double_array_;
    _impl_.value_.double_array_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Datapoint::unsafe_arena_set_allocated_double_array(::sdv::databroker::v1::DoubleArray* double_array) {
  clear_value();
  if (double_array) {
    set_has_double_array();
    _impl_.value_.double_array_ = double_array;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sdv.databroker.v1.Datapoint.double_array)
}
inline ::sdv::databroker::v1::DoubleArray* Datapoint::_internal_mutable_double_array() {
  if (!_internal_has_double_array()) {
    clear_value();
    set_has_double_array();
    _impl_.value_.double_array_ = CreateMaybeMessage< ::sdv::databroker::v1::DoubleArray >(GetArenaForAllocation());
  }
  return _impl_.value_.double_array_;
}
inline ::sdv::databroker::v1::DoubleArray* Datapoint::mutable_double_array() {
  ::sdv::databroker::v1::DoubleArray* _msg = _internal_mutable_double_array();
  // @@protoc_insertion_point(field_mutable:sdv.databroker.v1.Datapoint.double_array)
  return _msg;
}

inline bool Datapoint::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void Datapoint::clear_has_value() {
  _impl_._oneof_case_[0] = VALUE_NOT_SET;
}
inline Datapoint::ValueCase Datapoint::value_case() const {
  return Datapoint::ValueCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Metadata

// int32 id = 1;
inline void Metadata::clear_id() {
  _impl_.id_ = 0;
}
inline int32_t Metadata::_internal_id() const {
  return _impl_.id_;
}
inline int32_t Metadata::id() const {
  // @@protoc_insertion_point(field_get:sdv.databroker.v1.Metadata.id)
  return _internal_id();
}
inline void Metadata::_internal_set_id(int32_t value) {
  
  _impl_.id_ = value;
}
inline void Metadata::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:sdv.databroker.v1.Metadata.id)
}

// .sdv.databroker.v1.EntryType entry_type = 2;
inline void Metadata::clear_entry_type() {
  _impl_.entry_type_ = 0;
}
inline ::sdv::databroker::v1::EntryType Metadata::_internal_entry_type() const {
  return static_cast< ::sdv::databroker::v1::EntryType >(_impl_.entry_type_);
}
inline ::sdv::databroker::v1::EntryType Metadata::entry_type() const {
  // @@protoc_insertion_point(field_get:sdv.databroker.v1.Metadata.entry_type)
  return _internal_entry_type();
}
inline void Metadata::_internal_set_entry_type(::sdv::databroker::v1::EntryType value) {
  
  _impl_.entry_type_ = value;
}
inline void Metadata::set_entry_type(::sdv::databroker::v1::EntryType value) {
  _internal_set_entry_type(value);
  // @@protoc_insertion_point(field_set:sdv.databroker.v1.Metadata.entry_type)
}

// string name = 4;
inline void Metadata::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Metadata::name() const {
  // @@protoc_insertion_point(field_get:sdv.databroker.v1.Metadata.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Metadata::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sdv.databroker.v1.Metadata.name)
}
inline std::string* Metadata::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:sdv.databroker.v1.Metadata.name)
  return _s;
}
inline const std::string& Metadata::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Metadata::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Metadata::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Metadata::release_name() {
  // @@protoc_insertion_point(field_release:sdv.databroker.v1.Metadata.name)
  return _impl_.name_.Release();
}
inline void Metadata::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sdv.databroker.v1.Metadata.name)
}

// .sdv.databroker.v1.DataType data_type = 5;
inline void Metadata::clear_data_type() {
  _impl_.data_type_ = 0;
}
inline ::sdv::databroker::v1::DataType Metadata::_internal_data_type() const {
  return static_cast< ::sdv::databroker::v1::DataType >(_impl_.data_type_);
}
inline ::sdv::databroker::v1::DataType Metadata::data_type() const {
  // @@protoc_insertion_point(field_get:sdv.databroker.v1.Metadata.data_type)
  return _internal_data_type();
}
inline void Metadata::_internal_set_data_type(::sdv::databroker::v1::DataType value) {
  
  _impl_.data_type_ = value;
}
inline void Metadata::set_data_type(::sdv::databroker::v1::DataType value) {
  _internal_set_data_type(value);
  // @@protoc_insertion_point(field_set:sdv.databroker.v1.Metadata.data_type)
}

// .sdv.databroker.v1.ChangeType change_type = 6;
inline void Metadata::clear_change_type() {
  _impl_.change_type_ = 0;
}
inline ::sdv::databroker::v1::ChangeType Metadata::_internal_change_type() const {
  return static_cast< ::sdv::databroker::v1::ChangeType >(_impl_.change_type_);
}
inline ::sdv::databroker::v1::ChangeType Metadata::change_type() const {
  // @@protoc_insertion_point(field_get:sdv.databroker.v1.Metadata.change_type)
  return _internal_change_type();
}
inline void Metadata::_internal_set_change_type(::sdv::databroker::v1::ChangeType value) {
  
  _impl_.change_type_ = value;
}
inline void Metadata::set_change_type(::sdv::databroker::v1::ChangeType value) {
  _internal_set_change_type(value);
  // @@protoc_insertion_point(field_set:sdv.databroker.v1.Metadata.change_type)
}

// string description = 7;
inline void Metadata::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& Metadata::description() const {
  // @@protoc_insertion_point(field_get:sdv.databroker.v1.Metadata.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Metadata::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sdv.databroker.v1.Metadata.description)
}
inline std::string* Metadata::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:sdv.databroker.v1.Metadata.description)
  return _s;
}
inline const std::string& Metadata::_internal_description() const {
  return _impl_.description_.Get();
}
inline void Metadata::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* Metadata::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* Metadata::release_description() {
  // @@protoc_insertion_point(field_release:sdv.databroker.v1.Metadata.description)
  return _impl_.description_.Release();
}
inline void Metadata::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sdv.databroker.v1.Metadata.description)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace databroker
}  // namespace sdv

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::sdv::databroker::v1::Datapoint_Failure> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sdv::databroker::v1::Datapoint_Failure>() {
  return ::sdv::databroker::v1::Datapoint_Failure_descriptor();
}
template <> struct is_proto_enum< ::sdv::databroker::v1::DataType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sdv::databroker::v1::DataType>() {
  return ::sdv::databroker::v1::DataType_descriptor();
}
template <> struct is_proto_enum< ::sdv::databroker::v1::DatapointError> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sdv::databroker::v1::DatapointError>() {
  return ::sdv::databroker::v1::DatapointError_descriptor();
}
template <> struct is_proto_enum< ::sdv::databroker::v1::EntryType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sdv::databroker::v1::EntryType>() {
  return ::sdv::databroker::v1::EntryType_descriptor();
}
template <> struct is_proto_enum< ::sdv::databroker::v1::ChangeType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sdv::databroker::v1::ChangeType>() {
  return ::sdv::databroker::v1::ChangeType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_sdv_2fdatabroker_2fv1_2ftypes_2eproto
