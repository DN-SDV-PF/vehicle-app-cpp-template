// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: kuksa/val/v2/val.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_kuksa_2fval_2fv2_2fval_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_kuksa_2fval_2fv2_2fval_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
#include "kuksa/val/v2/types.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_kuksa_2fval_2fv2_2fval_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_kuksa_2fval_2fv2_2fval_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_kuksa_2fval_2fv2_2fval_2eproto;
namespace kuksa {
namespace val {
namespace v2 {
class ActuateRequest;
struct ActuateRequestDefaultTypeInternal;
extern ActuateRequestDefaultTypeInternal _ActuateRequest_default_instance_;
class ActuateResponse;
struct ActuateResponseDefaultTypeInternal;
extern ActuateResponseDefaultTypeInternal _ActuateResponse_default_instance_;
class BatchActuateRequest;
struct BatchActuateRequestDefaultTypeInternal;
extern BatchActuateRequestDefaultTypeInternal _BatchActuateRequest_default_instance_;
class BatchActuateResponse;
struct BatchActuateResponseDefaultTypeInternal;
extern BatchActuateResponseDefaultTypeInternal _BatchActuateResponse_default_instance_;
class BatchActuateStreamRequest;
struct BatchActuateStreamRequestDefaultTypeInternal;
extern BatchActuateStreamRequestDefaultTypeInternal _BatchActuateStreamRequest_default_instance_;
class BatchActuateStreamResponse;
struct BatchActuateStreamResponseDefaultTypeInternal;
extern BatchActuateStreamResponseDefaultTypeInternal _BatchActuateStreamResponse_default_instance_;
class GetServerInfoRequest;
struct GetServerInfoRequestDefaultTypeInternal;
extern GetServerInfoRequestDefaultTypeInternal _GetServerInfoRequest_default_instance_;
class GetServerInfoResponse;
struct GetServerInfoResponseDefaultTypeInternal;
extern GetServerInfoResponseDefaultTypeInternal _GetServerInfoResponse_default_instance_;
class GetValueRequest;
struct GetValueRequestDefaultTypeInternal;
extern GetValueRequestDefaultTypeInternal _GetValueRequest_default_instance_;
class GetValueResponse;
struct GetValueResponseDefaultTypeInternal;
extern GetValueResponseDefaultTypeInternal _GetValueResponse_default_instance_;
class GetValuesRequest;
struct GetValuesRequestDefaultTypeInternal;
extern GetValuesRequestDefaultTypeInternal _GetValuesRequest_default_instance_;
class GetValuesResponse;
struct GetValuesResponseDefaultTypeInternal;
extern GetValuesResponseDefaultTypeInternal _GetValuesResponse_default_instance_;
class ListMetadataRequest;
struct ListMetadataRequestDefaultTypeInternal;
extern ListMetadataRequestDefaultTypeInternal _ListMetadataRequest_default_instance_;
class ListMetadataResponse;
struct ListMetadataResponseDefaultTypeInternal;
extern ListMetadataResponseDefaultTypeInternal _ListMetadataResponse_default_instance_;
class OpenProviderStreamRequest;
struct OpenProviderStreamRequestDefaultTypeInternal;
extern OpenProviderStreamRequestDefaultTypeInternal _OpenProviderStreamRequest_default_instance_;
class OpenProviderStreamResponse;
struct OpenProviderStreamResponseDefaultTypeInternal;
extern OpenProviderStreamResponseDefaultTypeInternal _OpenProviderStreamResponse_default_instance_;
class ProvideActuationRequest;
struct ProvideActuationRequestDefaultTypeInternal;
extern ProvideActuationRequestDefaultTypeInternal _ProvideActuationRequest_default_instance_;
class ProvideActuationResponse;
struct ProvideActuationResponseDefaultTypeInternal;
extern ProvideActuationResponseDefaultTypeInternal _ProvideActuationResponse_default_instance_;
class PublishValueRequest;
struct PublishValueRequestDefaultTypeInternal;
extern PublishValueRequestDefaultTypeInternal _PublishValueRequest_default_instance_;
class PublishValueResponse;
struct PublishValueResponseDefaultTypeInternal;
extern PublishValueResponseDefaultTypeInternal _PublishValueResponse_default_instance_;
class PublishValuesRequest;
struct PublishValuesRequestDefaultTypeInternal;
extern PublishValuesRequestDefaultTypeInternal _PublishValuesRequest_default_instance_;
class PublishValuesRequest_DataPointsEntry_DoNotUse;
struct PublishValuesRequest_DataPointsEntry_DoNotUseDefaultTypeInternal;
extern PublishValuesRequest_DataPointsEntry_DoNotUseDefaultTypeInternal _PublishValuesRequest_DataPointsEntry_DoNotUse_default_instance_;
class PublishValuesResponse;
struct PublishValuesResponseDefaultTypeInternal;
extern PublishValuesResponseDefaultTypeInternal _PublishValuesResponse_default_instance_;
class PublishValuesResponse_StatusEntry_DoNotUse;
struct PublishValuesResponse_StatusEntry_DoNotUseDefaultTypeInternal;
extern PublishValuesResponse_StatusEntry_DoNotUseDefaultTypeInternal _PublishValuesResponse_StatusEntry_DoNotUse_default_instance_;
class SubscribeByIdRequest;
struct SubscribeByIdRequestDefaultTypeInternal;
extern SubscribeByIdRequestDefaultTypeInternal _SubscribeByIdRequest_default_instance_;
class SubscribeByIdResponse;
struct SubscribeByIdResponseDefaultTypeInternal;
extern SubscribeByIdResponseDefaultTypeInternal _SubscribeByIdResponse_default_instance_;
class SubscribeByIdResponse_EntriesEntry_DoNotUse;
struct SubscribeByIdResponse_EntriesEntry_DoNotUseDefaultTypeInternal;
extern SubscribeByIdResponse_EntriesEntry_DoNotUseDefaultTypeInternal _SubscribeByIdResponse_EntriesEntry_DoNotUse_default_instance_;
class SubscribeRequest;
struct SubscribeRequestDefaultTypeInternal;
extern SubscribeRequestDefaultTypeInternal _SubscribeRequest_default_instance_;
class SubscribeResponse;
struct SubscribeResponseDefaultTypeInternal;
extern SubscribeResponseDefaultTypeInternal _SubscribeResponse_default_instance_;
class SubscribeResponse_EntriesEntry_DoNotUse;
struct SubscribeResponse_EntriesEntry_DoNotUseDefaultTypeInternal;
extern SubscribeResponse_EntriesEntry_DoNotUseDefaultTypeInternal _SubscribeResponse_EntriesEntry_DoNotUse_default_instance_;
}  // namespace v2
}  // namespace val
}  // namespace kuksa
PROTOBUF_NAMESPACE_OPEN
template<> ::kuksa::val::v2::ActuateRequest* Arena::CreateMaybeMessage<::kuksa::val::v2::ActuateRequest>(Arena*);
template<> ::kuksa::val::v2::ActuateResponse* Arena::CreateMaybeMessage<::kuksa::val::v2::ActuateResponse>(Arena*);
template<> ::kuksa::val::v2::BatchActuateRequest* Arena::CreateMaybeMessage<::kuksa::val::v2::BatchActuateRequest>(Arena*);
template<> ::kuksa::val::v2::BatchActuateResponse* Arena::CreateMaybeMessage<::kuksa::val::v2::BatchActuateResponse>(Arena*);
template<> ::kuksa::val::v2::BatchActuateStreamRequest* Arena::CreateMaybeMessage<::kuksa::val::v2::BatchActuateStreamRequest>(Arena*);
template<> ::kuksa::val::v2::BatchActuateStreamResponse* Arena::CreateMaybeMessage<::kuksa::val::v2::BatchActuateStreamResponse>(Arena*);
template<> ::kuksa::val::v2::GetServerInfoRequest* Arena::CreateMaybeMessage<::kuksa::val::v2::GetServerInfoRequest>(Arena*);
template<> ::kuksa::val::v2::GetServerInfoResponse* Arena::CreateMaybeMessage<::kuksa::val::v2::GetServerInfoResponse>(Arena*);
template<> ::kuksa::val::v2::GetValueRequest* Arena::CreateMaybeMessage<::kuksa::val::v2::GetValueRequest>(Arena*);
template<> ::kuksa::val::v2::GetValueResponse* Arena::CreateMaybeMessage<::kuksa::val::v2::GetValueResponse>(Arena*);
template<> ::kuksa::val::v2::GetValuesRequest* Arena::CreateMaybeMessage<::kuksa::val::v2::GetValuesRequest>(Arena*);
template<> ::kuksa::val::v2::GetValuesResponse* Arena::CreateMaybeMessage<::kuksa::val::v2::GetValuesResponse>(Arena*);
template<> ::kuksa::val::v2::ListMetadataRequest* Arena::CreateMaybeMessage<::kuksa::val::v2::ListMetadataRequest>(Arena*);
template<> ::kuksa::val::v2::ListMetadataResponse* Arena::CreateMaybeMessage<::kuksa::val::v2::ListMetadataResponse>(Arena*);
template<> ::kuksa::val::v2::OpenProviderStreamRequest* Arena::CreateMaybeMessage<::kuksa::val::v2::OpenProviderStreamRequest>(Arena*);
template<> ::kuksa::val::v2::OpenProviderStreamResponse* Arena::CreateMaybeMessage<::kuksa::val::v2::OpenProviderStreamResponse>(Arena*);
template<> ::kuksa::val::v2::ProvideActuationRequest* Arena::CreateMaybeMessage<::kuksa::val::v2::ProvideActuationRequest>(Arena*);
template<> ::kuksa::val::v2::ProvideActuationResponse* Arena::CreateMaybeMessage<::kuksa::val::v2::ProvideActuationResponse>(Arena*);
template<> ::kuksa::val::v2::PublishValueRequest* Arena::CreateMaybeMessage<::kuksa::val::v2::PublishValueRequest>(Arena*);
template<> ::kuksa::val::v2::PublishValueResponse* Arena::CreateMaybeMessage<::kuksa::val::v2::PublishValueResponse>(Arena*);
template<> ::kuksa::val::v2::PublishValuesRequest* Arena::CreateMaybeMessage<::kuksa::val::v2::PublishValuesRequest>(Arena*);
template<> ::kuksa::val::v2::PublishValuesRequest_DataPointsEntry_DoNotUse* Arena::CreateMaybeMessage<::kuksa::val::v2::PublishValuesRequest_DataPointsEntry_DoNotUse>(Arena*);
template<> ::kuksa::val::v2::PublishValuesResponse* Arena::CreateMaybeMessage<::kuksa::val::v2::PublishValuesResponse>(Arena*);
template<> ::kuksa::val::v2::PublishValuesResponse_StatusEntry_DoNotUse* Arena::CreateMaybeMessage<::kuksa::val::v2::PublishValuesResponse_StatusEntry_DoNotUse>(Arena*);
template<> ::kuksa::val::v2::SubscribeByIdRequest* Arena::CreateMaybeMessage<::kuksa::val::v2::SubscribeByIdRequest>(Arena*);
template<> ::kuksa::val::v2::SubscribeByIdResponse* Arena::CreateMaybeMessage<::kuksa::val::v2::SubscribeByIdResponse>(Arena*);
template<> ::kuksa::val::v2::SubscribeByIdResponse_EntriesEntry_DoNotUse* Arena::CreateMaybeMessage<::kuksa::val::v2::SubscribeByIdResponse_EntriesEntry_DoNotUse>(Arena*);
template<> ::kuksa::val::v2::SubscribeRequest* Arena::CreateMaybeMessage<::kuksa::val::v2::SubscribeRequest>(Arena*);
template<> ::kuksa::val::v2::SubscribeResponse* Arena::CreateMaybeMessage<::kuksa::val::v2::SubscribeResponse>(Arena*);
template<> ::kuksa::val::v2::SubscribeResponse_EntriesEntry_DoNotUse* Arena::CreateMaybeMessage<::kuksa::val::v2::SubscribeResponse_EntriesEntry_DoNotUse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace kuksa {
namespace val {
namespace v2 {

// ===================================================================

class GetValueRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kuksa.val.v2.GetValueRequest) */ {
 public:
  inline GetValueRequest() : GetValueRequest(nullptr) {}
  ~GetValueRequest() override;
  explicit PROTOBUF_CONSTEXPR GetValueRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetValueRequest(const GetValueRequest& from);
  GetValueRequest(GetValueRequest&& from) noexcept
    : GetValueRequest() {
    *this = ::std::move(from);
  }

  inline GetValueRequest& operator=(const GetValueRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetValueRequest& operator=(GetValueRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetValueRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetValueRequest* internal_default_instance() {
    return reinterpret_cast<const GetValueRequest*>(
               &_GetValueRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(GetValueRequest& a, GetValueRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetValueRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetValueRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetValueRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetValueRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetValueRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetValueRequest& from) {
    GetValueRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetValueRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kuksa.val.v2.GetValueRequest";
  }
  protected:
  explicit GetValueRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignalIdFieldNumber = 1,
  };
  // .kuksa.val.v2.SignalID signal_id = 1;
  bool has_signal_id() const;
  private:
  bool _internal_has_signal_id() const;
  public:
  void clear_signal_id();
  const ::kuksa::val::v2::SignalID& signal_id() const;
  PROTOBUF_NODISCARD ::kuksa::val::v2::SignalID* release_signal_id();
  ::kuksa::val::v2::SignalID* mutable_signal_id();
  void set_allocated_signal_id(::kuksa::val::v2::SignalID* signal_id);
  private:
  const ::kuksa::val::v2::SignalID& _internal_signal_id() const;
  ::kuksa::val::v2::SignalID* _internal_mutable_signal_id();
  public:
  void unsafe_arena_set_allocated_signal_id(
      ::kuksa::val::v2::SignalID* signal_id);
  ::kuksa::val::v2::SignalID* unsafe_arena_release_signal_id();

  // @@protoc_insertion_point(class_scope:kuksa.val.v2.GetValueRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::kuksa::val::v2::SignalID* signal_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kuksa_2fval_2fv2_2fval_2eproto;
};
// -------------------------------------------------------------------

class GetValueResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kuksa.val.v2.GetValueResponse) */ {
 public:
  inline GetValueResponse() : GetValueResponse(nullptr) {}
  ~GetValueResponse() override;
  explicit PROTOBUF_CONSTEXPR GetValueResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetValueResponse(const GetValueResponse& from);
  GetValueResponse(GetValueResponse&& from) noexcept
    : GetValueResponse() {
    *this = ::std::move(from);
  }

  inline GetValueResponse& operator=(const GetValueResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetValueResponse& operator=(GetValueResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetValueResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetValueResponse* internal_default_instance() {
    return reinterpret_cast<const GetValueResponse*>(
               &_GetValueResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(GetValueResponse& a, GetValueResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetValueResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetValueResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetValueResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetValueResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetValueResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetValueResponse& from) {
    GetValueResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetValueResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kuksa.val.v2.GetValueResponse";
  }
  protected:
  explicit GetValueResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataPointFieldNumber = 1,
  };
  // .kuksa.val.v2.Datapoint data_point = 1;
  bool has_data_point() const;
  private:
  bool _internal_has_data_point() const;
  public:
  void clear_data_point();
  const ::kuksa::val::v2::Datapoint& data_point() const;
  PROTOBUF_NODISCARD ::kuksa::val::v2::Datapoint* release_data_point();
  ::kuksa::val::v2::Datapoint* mutable_data_point();
  void set_allocated_data_point(::kuksa::val::v2::Datapoint* data_point);
  private:
  const ::kuksa::val::v2::Datapoint& _internal_data_point() const;
  ::kuksa::val::v2::Datapoint* _internal_mutable_data_point();
  public:
  void unsafe_arena_set_allocated_data_point(
      ::kuksa::val::v2::Datapoint* data_point);
  ::kuksa::val::v2::Datapoint* unsafe_arena_release_data_point();

  // @@protoc_insertion_point(class_scope:kuksa.val.v2.GetValueResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::kuksa::val::v2::Datapoint* data_point_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kuksa_2fval_2fv2_2fval_2eproto;
};
// -------------------------------------------------------------------

class GetValuesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kuksa.val.v2.GetValuesRequest) */ {
 public:
  inline GetValuesRequest() : GetValuesRequest(nullptr) {}
  ~GetValuesRequest() override;
  explicit PROTOBUF_CONSTEXPR GetValuesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetValuesRequest(const GetValuesRequest& from);
  GetValuesRequest(GetValuesRequest&& from) noexcept
    : GetValuesRequest() {
    *this = ::std::move(from);
  }

  inline GetValuesRequest& operator=(const GetValuesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetValuesRequest& operator=(GetValuesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetValuesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetValuesRequest* internal_default_instance() {
    return reinterpret_cast<const GetValuesRequest*>(
               &_GetValuesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(GetValuesRequest& a, GetValuesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetValuesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetValuesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetValuesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetValuesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetValuesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetValuesRequest& from) {
    GetValuesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetValuesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kuksa.val.v2.GetValuesRequest";
  }
  protected:
  explicit GetValuesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignalIdsFieldNumber = 1,
  };
  // repeated .kuksa.val.v2.SignalID signal_ids = 1;
  int signal_ids_size() const;
  private:
  int _internal_signal_ids_size() const;
  public:
  void clear_signal_ids();
  ::kuksa::val::v2::SignalID* mutable_signal_ids(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kuksa::val::v2::SignalID >*
      mutable_signal_ids();
  private:
  const ::kuksa::val::v2::SignalID& _internal_signal_ids(int index) const;
  ::kuksa::val::v2::SignalID* _internal_add_signal_ids();
  public:
  const ::kuksa::val::v2::SignalID& signal_ids(int index) const;
  ::kuksa::val::v2::SignalID* add_signal_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kuksa::val::v2::SignalID >&
      signal_ids() const;

  // @@protoc_insertion_point(class_scope:kuksa.val.v2.GetValuesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kuksa::val::v2::SignalID > signal_ids_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kuksa_2fval_2fv2_2fval_2eproto;
};
// -------------------------------------------------------------------

class GetValuesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kuksa.val.v2.GetValuesResponse) */ {
 public:
  inline GetValuesResponse() : GetValuesResponse(nullptr) {}
  ~GetValuesResponse() override;
  explicit PROTOBUF_CONSTEXPR GetValuesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetValuesResponse(const GetValuesResponse& from);
  GetValuesResponse(GetValuesResponse&& from) noexcept
    : GetValuesResponse() {
    *this = ::std::move(from);
  }

  inline GetValuesResponse& operator=(const GetValuesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetValuesResponse& operator=(GetValuesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetValuesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetValuesResponse* internal_default_instance() {
    return reinterpret_cast<const GetValuesResponse*>(
               &_GetValuesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(GetValuesResponse& a, GetValuesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetValuesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetValuesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetValuesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetValuesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetValuesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetValuesResponse& from) {
    GetValuesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetValuesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kuksa.val.v2.GetValuesResponse";
  }
  protected:
  explicit GetValuesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataPointsFieldNumber = 1,
  };
  // repeated .kuksa.val.v2.Datapoint data_points = 1;
  int data_points_size() const;
  private:
  int _internal_data_points_size() const;
  public:
  void clear_data_points();
  ::kuksa::val::v2::Datapoint* mutable_data_points(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kuksa::val::v2::Datapoint >*
      mutable_data_points();
  private:
  const ::kuksa::val::v2::Datapoint& _internal_data_points(int index) const;
  ::kuksa::val::v2::Datapoint* _internal_add_data_points();
  public:
  const ::kuksa::val::v2::Datapoint& data_points(int index) const;
  ::kuksa::val::v2::Datapoint* add_data_points();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kuksa::val::v2::Datapoint >&
      data_points() const;

  // @@protoc_insertion_point(class_scope:kuksa.val.v2.GetValuesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kuksa::val::v2::Datapoint > data_points_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kuksa_2fval_2fv2_2fval_2eproto;
};
// -------------------------------------------------------------------

class SubscribeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kuksa.val.v2.SubscribeRequest) */ {
 public:
  inline SubscribeRequest() : SubscribeRequest(nullptr) {}
  ~SubscribeRequest() override;
  explicit PROTOBUF_CONSTEXPR SubscribeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscribeRequest(const SubscribeRequest& from);
  SubscribeRequest(SubscribeRequest&& from) noexcept
    : SubscribeRequest() {
    *this = ::std::move(from);
  }

  inline SubscribeRequest& operator=(const SubscribeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeRequest& operator=(SubscribeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscribeRequest* internal_default_instance() {
    return reinterpret_cast<const SubscribeRequest*>(
               &_SubscribeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SubscribeRequest& a, SubscribeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscribeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscribeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubscribeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubscribeRequest& from) {
    SubscribeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubscribeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kuksa.val.v2.SubscribeRequest";
  }
  protected:
  explicit SubscribeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignalPathsFieldNumber = 1,
    kBufferSizeFieldNumber = 2,
  };
  // repeated string signal_paths = 1;
  int signal_paths_size() const;
  private:
  int _internal_signal_paths_size() const;
  public:
  void clear_signal_paths();
  const std::string& signal_paths(int index) const;
  std::string* mutable_signal_paths(int index);
  void set_signal_paths(int index, const std::string& value);
  void set_signal_paths(int index, std::string&& value);
  void set_signal_paths(int index, const char* value);
  void set_signal_paths(int index, const char* value, size_t size);
  std::string* add_signal_paths();
  void add_signal_paths(const std::string& value);
  void add_signal_paths(std::string&& value);
  void add_signal_paths(const char* value);
  void add_signal_paths(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& signal_paths() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_signal_paths();
  private:
  const std::string& _internal_signal_paths(int index) const;
  std::string* _internal_add_signal_paths();
  public:

  // uint32 buffer_size = 2;
  void clear_buffer_size();
  uint32_t buffer_size() const;
  void set_buffer_size(uint32_t value);
  private:
  uint32_t _internal_buffer_size() const;
  void _internal_set_buffer_size(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:kuksa.val.v2.SubscribeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> signal_paths_;
    uint32_t buffer_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kuksa_2fval_2fv2_2fval_2eproto;
};
// -------------------------------------------------------------------

class SubscribeResponse_EntriesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SubscribeResponse_EntriesEntry_DoNotUse, 
    std::string, ::kuksa::val::v2::Datapoint,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SubscribeResponse_EntriesEntry_DoNotUse, 
    std::string, ::kuksa::val::v2::Datapoint,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  SubscribeResponse_EntriesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR SubscribeResponse_EntriesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit SubscribeResponse_EntriesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const SubscribeResponse_EntriesEntry_DoNotUse& other);
  static const SubscribeResponse_EntriesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SubscribeResponse_EntriesEntry_DoNotUse*>(&_SubscribeResponse_EntriesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "kuksa.val.v2.SubscribeResponse.EntriesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_kuksa_2fval_2fv2_2fval_2eproto;
};

// -------------------------------------------------------------------

class SubscribeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kuksa.val.v2.SubscribeResponse) */ {
 public:
  inline SubscribeResponse() : SubscribeResponse(nullptr) {}
  ~SubscribeResponse() override;
  explicit PROTOBUF_CONSTEXPR SubscribeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscribeResponse(const SubscribeResponse& from);
  SubscribeResponse(SubscribeResponse&& from) noexcept
    : SubscribeResponse() {
    *this = ::std::move(from);
  }

  inline SubscribeResponse& operator=(const SubscribeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeResponse& operator=(SubscribeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscribeResponse* internal_default_instance() {
    return reinterpret_cast<const SubscribeResponse*>(
               &_SubscribeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SubscribeResponse& a, SubscribeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscribeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscribeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubscribeResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubscribeResponse& from) {
    SubscribeResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubscribeResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kuksa.val.v2.SubscribeResponse";
  }
  protected:
  explicit SubscribeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kEntriesFieldNumber = 1,
  };
  // map<string, .kuksa.val.v2.Datapoint> entries = 1;
  int entries_size() const;
  private:
  int _internal_entries_size() const;
  public:
  void clear_entries();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::kuksa::val::v2::Datapoint >&
      _internal_entries() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::kuksa::val::v2::Datapoint >*
      _internal_mutable_entries();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::kuksa::val::v2::Datapoint >&
      entries() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::kuksa::val::v2::Datapoint >*
      mutable_entries();

  // @@protoc_insertion_point(class_scope:kuksa.val.v2.SubscribeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        SubscribeResponse_EntriesEntry_DoNotUse,
        std::string, ::kuksa::val::v2::Datapoint,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> entries_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kuksa_2fval_2fv2_2fval_2eproto;
};
// -------------------------------------------------------------------

class SubscribeByIdRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kuksa.val.v2.SubscribeByIdRequest) */ {
 public:
  inline SubscribeByIdRequest() : SubscribeByIdRequest(nullptr) {}
  ~SubscribeByIdRequest() override;
  explicit PROTOBUF_CONSTEXPR SubscribeByIdRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscribeByIdRequest(const SubscribeByIdRequest& from);
  SubscribeByIdRequest(SubscribeByIdRequest&& from) noexcept
    : SubscribeByIdRequest() {
    *this = ::std::move(from);
  }

  inline SubscribeByIdRequest& operator=(const SubscribeByIdRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeByIdRequest& operator=(SubscribeByIdRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeByIdRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscribeByIdRequest* internal_default_instance() {
    return reinterpret_cast<const SubscribeByIdRequest*>(
               &_SubscribeByIdRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SubscribeByIdRequest& a, SubscribeByIdRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscribeByIdRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeByIdRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeByIdRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscribeByIdRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubscribeByIdRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubscribeByIdRequest& from) {
    SubscribeByIdRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubscribeByIdRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kuksa.val.v2.SubscribeByIdRequest";
  }
  protected:
  explicit SubscribeByIdRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignalIdsFieldNumber = 1,
    kBufferSizeFieldNumber = 2,
  };
  // repeated int32 signal_ids = 1;
  int signal_ids_size() const;
  private:
  int _internal_signal_ids_size() const;
  public:
  void clear_signal_ids();
  private:
  int32_t _internal_signal_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_signal_ids() const;
  void _internal_add_signal_ids(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_signal_ids();
  public:
  int32_t signal_ids(int index) const;
  void set_signal_ids(int index, int32_t value);
  void add_signal_ids(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      signal_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_signal_ids();

  // uint32 buffer_size = 2;
  void clear_buffer_size();
  uint32_t buffer_size() const;
  void set_buffer_size(uint32_t value);
  private:
  uint32_t _internal_buffer_size() const;
  void _internal_set_buffer_size(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:kuksa.val.v2.SubscribeByIdRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > signal_ids_;
    mutable std::atomic<int> _signal_ids_cached_byte_size_;
    uint32_t buffer_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kuksa_2fval_2fv2_2fval_2eproto;
};
// -------------------------------------------------------------------

class SubscribeByIdResponse_EntriesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SubscribeByIdResponse_EntriesEntry_DoNotUse, 
    int32_t, ::kuksa::val::v2::Datapoint,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SubscribeByIdResponse_EntriesEntry_DoNotUse, 
    int32_t, ::kuksa::val::v2::Datapoint,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  SubscribeByIdResponse_EntriesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR SubscribeByIdResponse_EntriesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit SubscribeByIdResponse_EntriesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const SubscribeByIdResponse_EntriesEntry_DoNotUse& other);
  static const SubscribeByIdResponse_EntriesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SubscribeByIdResponse_EntriesEntry_DoNotUse*>(&_SubscribeByIdResponse_EntriesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_kuksa_2fval_2fv2_2fval_2eproto;
};

// -------------------------------------------------------------------

class SubscribeByIdResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kuksa.val.v2.SubscribeByIdResponse) */ {
 public:
  inline SubscribeByIdResponse() : SubscribeByIdResponse(nullptr) {}
  ~SubscribeByIdResponse() override;
  explicit PROTOBUF_CONSTEXPR SubscribeByIdResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscribeByIdResponse(const SubscribeByIdResponse& from);
  SubscribeByIdResponse(SubscribeByIdResponse&& from) noexcept
    : SubscribeByIdResponse() {
    *this = ::std::move(from);
  }

  inline SubscribeByIdResponse& operator=(const SubscribeByIdResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeByIdResponse& operator=(SubscribeByIdResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeByIdResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscribeByIdResponse* internal_default_instance() {
    return reinterpret_cast<const SubscribeByIdResponse*>(
               &_SubscribeByIdResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SubscribeByIdResponse& a, SubscribeByIdResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscribeByIdResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeByIdResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeByIdResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscribeByIdResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubscribeByIdResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubscribeByIdResponse& from) {
    SubscribeByIdResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubscribeByIdResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kuksa.val.v2.SubscribeByIdResponse";
  }
  protected:
  explicit SubscribeByIdResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kEntriesFieldNumber = 1,
  };
  // map<int32, .kuksa.val.v2.Datapoint> entries = 1;
  int entries_size() const;
  private:
  int _internal_entries_size() const;
  public:
  void clear_entries();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::kuksa::val::v2::Datapoint >&
      _internal_entries() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::kuksa::val::v2::Datapoint >*
      _internal_mutable_entries();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::kuksa::val::v2::Datapoint >&
      entries() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::kuksa::val::v2::Datapoint >*
      mutable_entries();

  // @@protoc_insertion_point(class_scope:kuksa.val.v2.SubscribeByIdResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        SubscribeByIdResponse_EntriesEntry_DoNotUse,
        int32_t, ::kuksa::val::v2::Datapoint,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> entries_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kuksa_2fval_2fv2_2fval_2eproto;
};
// -------------------------------------------------------------------

class ActuateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kuksa.val.v2.ActuateRequest) */ {
 public:
  inline ActuateRequest() : ActuateRequest(nullptr) {}
  ~ActuateRequest() override;
  explicit PROTOBUF_CONSTEXPR ActuateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActuateRequest(const ActuateRequest& from);
  ActuateRequest(ActuateRequest&& from) noexcept
    : ActuateRequest() {
    *this = ::std::move(from);
  }

  inline ActuateRequest& operator=(const ActuateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActuateRequest& operator=(ActuateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActuateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActuateRequest* internal_default_instance() {
    return reinterpret_cast<const ActuateRequest*>(
               &_ActuateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ActuateRequest& a, ActuateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ActuateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActuateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActuateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActuateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ActuateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ActuateRequest& from) {
    ActuateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActuateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kuksa.val.v2.ActuateRequest";
  }
  protected:
  explicit ActuateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignalIdFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // .kuksa.val.v2.SignalID signal_id = 1;
  bool has_signal_id() const;
  private:
  bool _internal_has_signal_id() const;
  public:
  void clear_signal_id();
  const ::kuksa::val::v2::SignalID& signal_id() const;
  PROTOBUF_NODISCARD ::kuksa::val::v2::SignalID* release_signal_id();
  ::kuksa::val::v2::SignalID* mutable_signal_id();
  void set_allocated_signal_id(::kuksa::val::v2::SignalID* signal_id);
  private:
  const ::kuksa::val::v2::SignalID& _internal_signal_id() const;
  ::kuksa::val::v2::SignalID* _internal_mutable_signal_id();
  public:
  void unsafe_arena_set_allocated_signal_id(
      ::kuksa::val::v2::SignalID* signal_id);
  ::kuksa::val::v2::SignalID* unsafe_arena_release_signal_id();

  // .kuksa.val.v2.Value value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::kuksa::val::v2::Value& value() const;
  PROTOBUF_NODISCARD ::kuksa::val::v2::Value* release_value();
  ::kuksa::val::v2::Value* mutable_value();
  void set_allocated_value(::kuksa::val::v2::Value* value);
  private:
  const ::kuksa::val::v2::Value& _internal_value() const;
  ::kuksa::val::v2::Value* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::kuksa::val::v2::Value* value);
  ::kuksa::val::v2::Value* unsafe_arena_release_value();

  // @@protoc_insertion_point(class_scope:kuksa.val.v2.ActuateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::kuksa::val::v2::SignalID* signal_id_;
    ::kuksa::val::v2::Value* value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kuksa_2fval_2fv2_2fval_2eproto;
};
// -------------------------------------------------------------------

class ActuateResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:kuksa.val.v2.ActuateResponse) */ {
 public:
  inline ActuateResponse() : ActuateResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ActuateResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActuateResponse(const ActuateResponse& from);
  ActuateResponse(ActuateResponse&& from) noexcept
    : ActuateResponse() {
    *this = ::std::move(from);
  }

  inline ActuateResponse& operator=(const ActuateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActuateResponse& operator=(ActuateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActuateResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActuateResponse* internal_default_instance() {
    return reinterpret_cast<const ActuateResponse*>(
               &_ActuateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ActuateResponse& a, ActuateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ActuateResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActuateResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActuateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActuateResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ActuateResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ActuateResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kuksa.val.v2.ActuateResponse";
  }
  protected:
  explicit ActuateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:kuksa.val.v2.ActuateResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_kuksa_2fval_2fv2_2fval_2eproto;
};
// -------------------------------------------------------------------

class BatchActuateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kuksa.val.v2.BatchActuateRequest) */ {
 public:
  inline BatchActuateRequest() : BatchActuateRequest(nullptr) {}
  ~BatchActuateRequest() override;
  explicit PROTOBUF_CONSTEXPR BatchActuateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BatchActuateRequest(const BatchActuateRequest& from);
  BatchActuateRequest(BatchActuateRequest&& from) noexcept
    : BatchActuateRequest() {
    *this = ::std::move(from);
  }

  inline BatchActuateRequest& operator=(const BatchActuateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatchActuateRequest& operator=(BatchActuateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatchActuateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const BatchActuateRequest* internal_default_instance() {
    return reinterpret_cast<const BatchActuateRequest*>(
               &_BatchActuateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(BatchActuateRequest& a, BatchActuateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(BatchActuateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatchActuateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BatchActuateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BatchActuateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BatchActuateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BatchActuateRequest& from) {
    BatchActuateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatchActuateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kuksa.val.v2.BatchActuateRequest";
  }
  protected:
  explicit BatchActuateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActuateRequestsFieldNumber = 1,
  };
  // repeated .kuksa.val.v2.ActuateRequest actuate_requests = 1;
  int actuate_requests_size() const;
  private:
  int _internal_actuate_requests_size() const;
  public:
  void clear_actuate_requests();
  ::kuksa::val::v2::ActuateRequest* mutable_actuate_requests(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kuksa::val::v2::ActuateRequest >*
      mutable_actuate_requests();
  private:
  const ::kuksa::val::v2::ActuateRequest& _internal_actuate_requests(int index) const;
  ::kuksa::val::v2::ActuateRequest* _internal_add_actuate_requests();
  public:
  const ::kuksa::val::v2::ActuateRequest& actuate_requests(int index) const;
  ::kuksa::val::v2::ActuateRequest* add_actuate_requests();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kuksa::val::v2::ActuateRequest >&
      actuate_requests() const;

  // @@protoc_insertion_point(class_scope:kuksa.val.v2.BatchActuateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kuksa::val::v2::ActuateRequest > actuate_requests_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kuksa_2fval_2fv2_2fval_2eproto;
};
// -------------------------------------------------------------------

class BatchActuateResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:kuksa.val.v2.BatchActuateResponse) */ {
 public:
  inline BatchActuateResponse() : BatchActuateResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR BatchActuateResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BatchActuateResponse(const BatchActuateResponse& from);
  BatchActuateResponse(BatchActuateResponse&& from) noexcept
    : BatchActuateResponse() {
    *this = ::std::move(from);
  }

  inline BatchActuateResponse& operator=(const BatchActuateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatchActuateResponse& operator=(BatchActuateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatchActuateResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const BatchActuateResponse* internal_default_instance() {
    return reinterpret_cast<const BatchActuateResponse*>(
               &_BatchActuateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(BatchActuateResponse& a, BatchActuateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(BatchActuateResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatchActuateResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BatchActuateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BatchActuateResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const BatchActuateResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const BatchActuateResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kuksa.val.v2.BatchActuateResponse";
  }
  protected:
  explicit BatchActuateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:kuksa.val.v2.BatchActuateResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_kuksa_2fval_2fv2_2fval_2eproto;
};
// -------------------------------------------------------------------

class ListMetadataRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kuksa.val.v2.ListMetadataRequest) */ {
 public:
  inline ListMetadataRequest() : ListMetadataRequest(nullptr) {}
  ~ListMetadataRequest() override;
  explicit PROTOBUF_CONSTEXPR ListMetadataRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListMetadataRequest(const ListMetadataRequest& from);
  ListMetadataRequest(ListMetadataRequest&& from) noexcept
    : ListMetadataRequest() {
    *this = ::std::move(from);
  }

  inline ListMetadataRequest& operator=(const ListMetadataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListMetadataRequest& operator=(ListMetadataRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListMetadataRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListMetadataRequest* internal_default_instance() {
    return reinterpret_cast<const ListMetadataRequest*>(
               &_ListMetadataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ListMetadataRequest& a, ListMetadataRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListMetadataRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListMetadataRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListMetadataRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListMetadataRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListMetadataRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListMetadataRequest& from) {
    ListMetadataRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListMetadataRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kuksa.val.v2.ListMetadataRequest";
  }
  protected:
  explicit ListMetadataRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRootFieldNumber = 1,
    kFilterFieldNumber = 2,
  };
  // string root = 1;
  void clear_root();
  const std::string& root() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_root(ArgT0&& arg0, ArgT... args);
  std::string* mutable_root();
  PROTOBUF_NODISCARD std::string* release_root();
  void set_allocated_root(std::string* root);
  private:
  const std::string& _internal_root() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_root(const std::string& value);
  std::string* _internal_mutable_root();
  public:

  // string filter = 2;
  void clear_filter();
  const std::string& filter() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filter(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filter();
  PROTOBUF_NODISCARD std::string* release_filter();
  void set_allocated_filter(std::string* filter);
  private:
  const std::string& _internal_filter() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filter(const std::string& value);
  std::string* _internal_mutable_filter();
  public:

  // @@protoc_insertion_point(class_scope:kuksa.val.v2.ListMetadataRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr root_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filter_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kuksa_2fval_2fv2_2fval_2eproto;
};
// -------------------------------------------------------------------

class ListMetadataResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kuksa.val.v2.ListMetadataResponse) */ {
 public:
  inline ListMetadataResponse() : ListMetadataResponse(nullptr) {}
  ~ListMetadataResponse() override;
  explicit PROTOBUF_CONSTEXPR ListMetadataResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListMetadataResponse(const ListMetadataResponse& from);
  ListMetadataResponse(ListMetadataResponse&& from) noexcept
    : ListMetadataResponse() {
    *this = ::std::move(from);
  }

  inline ListMetadataResponse& operator=(const ListMetadataResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListMetadataResponse& operator=(ListMetadataResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListMetadataResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListMetadataResponse* internal_default_instance() {
    return reinterpret_cast<const ListMetadataResponse*>(
               &_ListMetadataResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ListMetadataResponse& a, ListMetadataResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListMetadataResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListMetadataResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListMetadataResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListMetadataResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListMetadataResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListMetadataResponse& from) {
    ListMetadataResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListMetadataResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kuksa.val.v2.ListMetadataResponse";
  }
  protected:
  explicit ListMetadataResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 1,
  };
  // repeated .kuksa.val.v2.Metadata metadata = 1;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;
  public:
  void clear_metadata();
  ::kuksa::val::v2::Metadata* mutable_metadata(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kuksa::val::v2::Metadata >*
      mutable_metadata();
  private:
  const ::kuksa::val::v2::Metadata& _internal_metadata(int index) const;
  ::kuksa::val::v2::Metadata* _internal_add_metadata();
  public:
  const ::kuksa::val::v2::Metadata& metadata(int index) const;
  ::kuksa::val::v2::Metadata* add_metadata();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kuksa::val::v2::Metadata >&
      metadata() const;

  // @@protoc_insertion_point(class_scope:kuksa.val.v2.ListMetadataResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kuksa::val::v2::Metadata > metadata_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kuksa_2fval_2fv2_2fval_2eproto;
};
// -------------------------------------------------------------------

class PublishValueRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kuksa.val.v2.PublishValueRequest) */ {
 public:
  inline PublishValueRequest() : PublishValueRequest(nullptr) {}
  ~PublishValueRequest() override;
  explicit PROTOBUF_CONSTEXPR PublishValueRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PublishValueRequest(const PublishValueRequest& from);
  PublishValueRequest(PublishValueRequest&& from) noexcept
    : PublishValueRequest() {
    *this = ::std::move(from);
  }

  inline PublishValueRequest& operator=(const PublishValueRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PublishValueRequest& operator=(PublishValueRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PublishValueRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PublishValueRequest* internal_default_instance() {
    return reinterpret_cast<const PublishValueRequest*>(
               &_PublishValueRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(PublishValueRequest& a, PublishValueRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PublishValueRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PublishValueRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PublishValueRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PublishValueRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PublishValueRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PublishValueRequest& from) {
    PublishValueRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PublishValueRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kuksa.val.v2.PublishValueRequest";
  }
  protected:
  explicit PublishValueRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignalIdFieldNumber = 1,
    kDataPointFieldNumber = 2,
  };
  // .kuksa.val.v2.SignalID signal_id = 1;
  bool has_signal_id() const;
  private:
  bool _internal_has_signal_id() const;
  public:
  void clear_signal_id();
  const ::kuksa::val::v2::SignalID& signal_id() const;
  PROTOBUF_NODISCARD ::kuksa::val::v2::SignalID* release_signal_id();
  ::kuksa::val::v2::SignalID* mutable_signal_id();
  void set_allocated_signal_id(::kuksa::val::v2::SignalID* signal_id);
  private:
  const ::kuksa::val::v2::SignalID& _internal_signal_id() const;
  ::kuksa::val::v2::SignalID* _internal_mutable_signal_id();
  public:
  void unsafe_arena_set_allocated_signal_id(
      ::kuksa::val::v2::SignalID* signal_id);
  ::kuksa::val::v2::SignalID* unsafe_arena_release_signal_id();

  // .kuksa.val.v2.Datapoint data_point = 2;
  bool has_data_point() const;
  private:
  bool _internal_has_data_point() const;
  public:
  void clear_data_point();
  const ::kuksa::val::v2::Datapoint& data_point() const;
  PROTOBUF_NODISCARD ::kuksa::val::v2::Datapoint* release_data_point();
  ::kuksa::val::v2::Datapoint* mutable_data_point();
  void set_allocated_data_point(::kuksa::val::v2::Datapoint* data_point);
  private:
  const ::kuksa::val::v2::Datapoint& _internal_data_point() const;
  ::kuksa::val::v2::Datapoint* _internal_mutable_data_point();
  public:
  void unsafe_arena_set_allocated_data_point(
      ::kuksa::val::v2::Datapoint* data_point);
  ::kuksa::val::v2::Datapoint* unsafe_arena_release_data_point();

  // @@protoc_insertion_point(class_scope:kuksa.val.v2.PublishValueRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::kuksa::val::v2::SignalID* signal_id_;
    ::kuksa::val::v2::Datapoint* data_point_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kuksa_2fval_2fv2_2fval_2eproto;
};
// -------------------------------------------------------------------

class PublishValueResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:kuksa.val.v2.PublishValueResponse) */ {
 public:
  inline PublishValueResponse() : PublishValueResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR PublishValueResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PublishValueResponse(const PublishValueResponse& from);
  PublishValueResponse(PublishValueResponse&& from) noexcept
    : PublishValueResponse() {
    *this = ::std::move(from);
  }

  inline PublishValueResponse& operator=(const PublishValueResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PublishValueResponse& operator=(PublishValueResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PublishValueResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PublishValueResponse* internal_default_instance() {
    return reinterpret_cast<const PublishValueResponse*>(
               &_PublishValueResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(PublishValueResponse& a, PublishValueResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PublishValueResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PublishValueResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PublishValueResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PublishValueResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const PublishValueResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const PublishValueResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kuksa.val.v2.PublishValueResponse";
  }
  protected:
  explicit PublishValueResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:kuksa.val.v2.PublishValueResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_kuksa_2fval_2fv2_2fval_2eproto;
};
// -------------------------------------------------------------------

class PublishValuesRequest_DataPointsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<PublishValuesRequest_DataPointsEntry_DoNotUse, 
    int32_t, ::kuksa::val::v2::Datapoint,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<PublishValuesRequest_DataPointsEntry_DoNotUse, 
    int32_t, ::kuksa::val::v2::Datapoint,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  PublishValuesRequest_DataPointsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR PublishValuesRequest_DataPointsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit PublishValuesRequest_DataPointsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const PublishValuesRequest_DataPointsEntry_DoNotUse& other);
  static const PublishValuesRequest_DataPointsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const PublishValuesRequest_DataPointsEntry_DoNotUse*>(&_PublishValuesRequest_DataPointsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_kuksa_2fval_2fv2_2fval_2eproto;
};

// -------------------------------------------------------------------

class PublishValuesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kuksa.val.v2.PublishValuesRequest) */ {
 public:
  inline PublishValuesRequest() : PublishValuesRequest(nullptr) {}
  ~PublishValuesRequest() override;
  explicit PROTOBUF_CONSTEXPR PublishValuesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PublishValuesRequest(const PublishValuesRequest& from);
  PublishValuesRequest(PublishValuesRequest&& from) noexcept
    : PublishValuesRequest() {
    *this = ::std::move(from);
  }

  inline PublishValuesRequest& operator=(const PublishValuesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PublishValuesRequest& operator=(PublishValuesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PublishValuesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PublishValuesRequest* internal_default_instance() {
    return reinterpret_cast<const PublishValuesRequest*>(
               &_PublishValuesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(PublishValuesRequest& a, PublishValuesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PublishValuesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PublishValuesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PublishValuesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PublishValuesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PublishValuesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PublishValuesRequest& from) {
    PublishValuesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PublishValuesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kuksa.val.v2.PublishValuesRequest";
  }
  protected:
  explicit PublishValuesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kDataPointsFieldNumber = 2,
    kRequestIdFieldNumber = 1,
  };
  // map<int32, .kuksa.val.v2.Datapoint> data_points = 2;
  int data_points_size() const;
  private:
  int _internal_data_points_size() const;
  public:
  void clear_data_points();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::kuksa::val::v2::Datapoint >&
      _internal_data_points() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::kuksa::val::v2::Datapoint >*
      _internal_mutable_data_points();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::kuksa::val::v2::Datapoint >&
      data_points() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::kuksa::val::v2::Datapoint >*
      mutable_data_points();

  // int32 request_id = 1;
  void clear_request_id();
  int32_t request_id() const;
  void set_request_id(int32_t value);
  private:
  int32_t _internal_request_id() const;
  void _internal_set_request_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:kuksa.val.v2.PublishValuesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        PublishValuesRequest_DataPointsEntry_DoNotUse,
        int32_t, ::kuksa::val::v2::Datapoint,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> data_points_;
    int32_t request_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kuksa_2fval_2fv2_2fval_2eproto;
};
// -------------------------------------------------------------------

class PublishValuesResponse_StatusEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<PublishValuesResponse_StatusEntry_DoNotUse, 
    int32_t, ::kuksa::val::v2::Error,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<PublishValuesResponse_StatusEntry_DoNotUse, 
    int32_t, ::kuksa::val::v2::Error,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  PublishValuesResponse_StatusEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR PublishValuesResponse_StatusEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit PublishValuesResponse_StatusEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const PublishValuesResponse_StatusEntry_DoNotUse& other);
  static const PublishValuesResponse_StatusEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const PublishValuesResponse_StatusEntry_DoNotUse*>(&_PublishValuesResponse_StatusEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_kuksa_2fval_2fv2_2fval_2eproto;
};

// -------------------------------------------------------------------

class PublishValuesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kuksa.val.v2.PublishValuesResponse) */ {
 public:
  inline PublishValuesResponse() : PublishValuesResponse(nullptr) {}
  ~PublishValuesResponse() override;
  explicit PROTOBUF_CONSTEXPR PublishValuesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PublishValuesResponse(const PublishValuesResponse& from);
  PublishValuesResponse(PublishValuesResponse&& from) noexcept
    : PublishValuesResponse() {
    *this = ::std::move(from);
  }

  inline PublishValuesResponse& operator=(const PublishValuesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PublishValuesResponse& operator=(PublishValuesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PublishValuesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PublishValuesResponse* internal_default_instance() {
    return reinterpret_cast<const PublishValuesResponse*>(
               &_PublishValuesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(PublishValuesResponse& a, PublishValuesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PublishValuesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PublishValuesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PublishValuesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PublishValuesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PublishValuesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PublishValuesResponse& from) {
    PublishValuesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PublishValuesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kuksa.val.v2.PublishValuesResponse";
  }
  protected:
  explicit PublishValuesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 2,
    kRequestIdFieldNumber = 1,
  };
  // map<int32, .kuksa.val.v2.Error> status = 2;
  int status_size() const;
  private:
  int _internal_status_size() const;
  public:
  void clear_status();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::kuksa::val::v2::Error >&
      _internal_status() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::kuksa::val::v2::Error >*
      _internal_mutable_status();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::kuksa::val::v2::Error >&
      status() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::kuksa::val::v2::Error >*
      mutable_status();

  // int32 request_id = 1;
  void clear_request_id();
  int32_t request_id() const;
  void set_request_id(int32_t value);
  private:
  int32_t _internal_request_id() const;
  void _internal_set_request_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:kuksa.val.v2.PublishValuesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        PublishValuesResponse_StatusEntry_DoNotUse,
        int32_t, ::kuksa::val::v2::Error,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> status_;
    int32_t request_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kuksa_2fval_2fv2_2fval_2eproto;
};
// -------------------------------------------------------------------

class ProvideActuationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kuksa.val.v2.ProvideActuationRequest) */ {
 public:
  inline ProvideActuationRequest() : ProvideActuationRequest(nullptr) {}
  ~ProvideActuationRequest() override;
  explicit PROTOBUF_CONSTEXPR ProvideActuationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProvideActuationRequest(const ProvideActuationRequest& from);
  ProvideActuationRequest(ProvideActuationRequest&& from) noexcept
    : ProvideActuationRequest() {
    *this = ::std::move(from);
  }

  inline ProvideActuationRequest& operator=(const ProvideActuationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProvideActuationRequest& operator=(ProvideActuationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProvideActuationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProvideActuationRequest* internal_default_instance() {
    return reinterpret_cast<const ProvideActuationRequest*>(
               &_ProvideActuationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(ProvideActuationRequest& a, ProvideActuationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ProvideActuationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProvideActuationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProvideActuationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProvideActuationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProvideActuationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProvideActuationRequest& from) {
    ProvideActuationRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProvideActuationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kuksa.val.v2.ProvideActuationRequest";
  }
  protected:
  explicit ProvideActuationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActuatorIdentifiersFieldNumber = 1,
  };
  // repeated .kuksa.val.v2.SignalID actuator_identifiers = 1;
  int actuator_identifiers_size() const;
  private:
  int _internal_actuator_identifiers_size() const;
  public:
  void clear_actuator_identifiers();
  ::kuksa::val::v2::SignalID* mutable_actuator_identifiers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kuksa::val::v2::SignalID >*
      mutable_actuator_identifiers();
  private:
  const ::kuksa::val::v2::SignalID& _internal_actuator_identifiers(int index) const;
  ::kuksa::val::v2::SignalID* _internal_add_actuator_identifiers();
  public:
  const ::kuksa::val::v2::SignalID& actuator_identifiers(int index) const;
  ::kuksa::val::v2::SignalID* add_actuator_identifiers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kuksa::val::v2::SignalID >&
      actuator_identifiers() const;

  // @@protoc_insertion_point(class_scope:kuksa.val.v2.ProvideActuationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kuksa::val::v2::SignalID > actuator_identifiers_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kuksa_2fval_2fv2_2fval_2eproto;
};
// -------------------------------------------------------------------

class ProvideActuationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:kuksa.val.v2.ProvideActuationResponse) */ {
 public:
  inline ProvideActuationResponse() : ProvideActuationResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ProvideActuationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProvideActuationResponse(const ProvideActuationResponse& from);
  ProvideActuationResponse(ProvideActuationResponse&& from) noexcept
    : ProvideActuationResponse() {
    *this = ::std::move(from);
  }

  inline ProvideActuationResponse& operator=(const ProvideActuationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProvideActuationResponse& operator=(ProvideActuationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProvideActuationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProvideActuationResponse* internal_default_instance() {
    return reinterpret_cast<const ProvideActuationResponse*>(
               &_ProvideActuationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(ProvideActuationResponse& a, ProvideActuationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ProvideActuationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProvideActuationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProvideActuationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProvideActuationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ProvideActuationResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ProvideActuationResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kuksa.val.v2.ProvideActuationResponse";
  }
  protected:
  explicit ProvideActuationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:kuksa.val.v2.ProvideActuationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_kuksa_2fval_2fv2_2fval_2eproto;
};
// -------------------------------------------------------------------

class BatchActuateStreamRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kuksa.val.v2.BatchActuateStreamRequest) */ {
 public:
  inline BatchActuateStreamRequest() : BatchActuateStreamRequest(nullptr) {}
  ~BatchActuateStreamRequest() override;
  explicit PROTOBUF_CONSTEXPR BatchActuateStreamRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BatchActuateStreamRequest(const BatchActuateStreamRequest& from);
  BatchActuateStreamRequest(BatchActuateStreamRequest&& from) noexcept
    : BatchActuateStreamRequest() {
    *this = ::std::move(from);
  }

  inline BatchActuateStreamRequest& operator=(const BatchActuateStreamRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatchActuateStreamRequest& operator=(BatchActuateStreamRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatchActuateStreamRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const BatchActuateStreamRequest* internal_default_instance() {
    return reinterpret_cast<const BatchActuateStreamRequest*>(
               &_BatchActuateStreamRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(BatchActuateStreamRequest& a, BatchActuateStreamRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(BatchActuateStreamRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatchActuateStreamRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BatchActuateStreamRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BatchActuateStreamRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BatchActuateStreamRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BatchActuateStreamRequest& from) {
    BatchActuateStreamRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatchActuateStreamRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kuksa.val.v2.BatchActuateStreamRequest";
  }
  protected:
  explicit BatchActuateStreamRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActuateRequestsFieldNumber = 1,
  };
  // repeated .kuksa.val.v2.ActuateRequest actuate_requests = 1;
  int actuate_requests_size() const;
  private:
  int _internal_actuate_requests_size() const;
  public:
  void clear_actuate_requests();
  ::kuksa::val::v2::ActuateRequest* mutable_actuate_requests(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kuksa::val::v2::ActuateRequest >*
      mutable_actuate_requests();
  private:
  const ::kuksa::val::v2::ActuateRequest& _internal_actuate_requests(int index) const;
  ::kuksa::val::v2::ActuateRequest* _internal_add_actuate_requests();
  public:
  const ::kuksa::val::v2::ActuateRequest& actuate_requests(int index) const;
  ::kuksa::val::v2::ActuateRequest* add_actuate_requests();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kuksa::val::v2::ActuateRequest >&
      actuate_requests() const;

  // @@protoc_insertion_point(class_scope:kuksa.val.v2.BatchActuateStreamRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kuksa::val::v2::ActuateRequest > actuate_requests_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kuksa_2fval_2fv2_2fval_2eproto;
};
// -------------------------------------------------------------------

class BatchActuateStreamResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kuksa.val.v2.BatchActuateStreamResponse) */ {
 public:
  inline BatchActuateStreamResponse() : BatchActuateStreamResponse(nullptr) {}
  ~BatchActuateStreamResponse() override;
  explicit PROTOBUF_CONSTEXPR BatchActuateStreamResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BatchActuateStreamResponse(const BatchActuateStreamResponse& from);
  BatchActuateStreamResponse(BatchActuateStreamResponse&& from) noexcept
    : BatchActuateStreamResponse() {
    *this = ::std::move(from);
  }

  inline BatchActuateStreamResponse& operator=(const BatchActuateStreamResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatchActuateStreamResponse& operator=(BatchActuateStreamResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatchActuateStreamResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const BatchActuateStreamResponse* internal_default_instance() {
    return reinterpret_cast<const BatchActuateStreamResponse*>(
               &_BatchActuateStreamResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(BatchActuateStreamResponse& a, BatchActuateStreamResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(BatchActuateStreamResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatchActuateStreamResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BatchActuateStreamResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BatchActuateStreamResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BatchActuateStreamResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BatchActuateStreamResponse& from) {
    BatchActuateStreamResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatchActuateStreamResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kuksa.val.v2.BatchActuateStreamResponse";
  }
  protected:
  explicit BatchActuateStreamResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignalIdFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  // .kuksa.val.v2.SignalID signal_id = 1;
  bool has_signal_id() const;
  private:
  bool _internal_has_signal_id() const;
  public:
  void clear_signal_id();
  const ::kuksa::val::v2::SignalID& signal_id() const;
  PROTOBUF_NODISCARD ::kuksa::val::v2::SignalID* release_signal_id();
  ::kuksa::val::v2::SignalID* mutable_signal_id();
  void set_allocated_signal_id(::kuksa::val::v2::SignalID* signal_id);
  private:
  const ::kuksa::val::v2::SignalID& _internal_signal_id() const;
  ::kuksa::val::v2::SignalID* _internal_mutable_signal_id();
  public:
  void unsafe_arena_set_allocated_signal_id(
      ::kuksa::val::v2::SignalID* signal_id);
  ::kuksa::val::v2::SignalID* unsafe_arena_release_signal_id();

  // .kuksa.val.v2.Error error = 2;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::kuksa::val::v2::Error& error() const;
  PROTOBUF_NODISCARD ::kuksa::val::v2::Error* release_error();
  ::kuksa::val::v2::Error* mutable_error();
  void set_allocated_error(::kuksa::val::v2::Error* error);
  private:
  const ::kuksa::val::v2::Error& _internal_error() const;
  ::kuksa::val::v2::Error* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::kuksa::val::v2::Error* error);
  ::kuksa::val::v2::Error* unsafe_arena_release_error();

  // @@protoc_insertion_point(class_scope:kuksa.val.v2.BatchActuateStreamResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::kuksa::val::v2::SignalID* signal_id_;
    ::kuksa::val::v2::Error* error_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kuksa_2fval_2fv2_2fval_2eproto;
};
// -------------------------------------------------------------------

class OpenProviderStreamRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kuksa.val.v2.OpenProviderStreamRequest) */ {
 public:
  inline OpenProviderStreamRequest() : OpenProviderStreamRequest(nullptr) {}
  ~OpenProviderStreamRequest() override;
  explicit PROTOBUF_CONSTEXPR OpenProviderStreamRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OpenProviderStreamRequest(const OpenProviderStreamRequest& from);
  OpenProviderStreamRequest(OpenProviderStreamRequest&& from) noexcept
    : OpenProviderStreamRequest() {
    *this = ::std::move(from);
  }

  inline OpenProviderStreamRequest& operator=(const OpenProviderStreamRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpenProviderStreamRequest& operator=(OpenProviderStreamRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpenProviderStreamRequest& default_instance() {
    return *internal_default_instance();
  }
  enum ActionCase {
    kProvideActuationRequest = 1,
    kPublishValuesRequest = 2,
    kBatchActuateStreamResponse = 3,
    ACTION_NOT_SET = 0,
  };

  static inline const OpenProviderStreamRequest* internal_default_instance() {
    return reinterpret_cast<const OpenProviderStreamRequest*>(
               &_OpenProviderStreamRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(OpenProviderStreamRequest& a, OpenProviderStreamRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(OpenProviderStreamRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpenProviderStreamRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpenProviderStreamRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OpenProviderStreamRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OpenProviderStreamRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OpenProviderStreamRequest& from) {
    OpenProviderStreamRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpenProviderStreamRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kuksa.val.v2.OpenProviderStreamRequest";
  }
  protected:
  explicit OpenProviderStreamRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProvideActuationRequestFieldNumber = 1,
    kPublishValuesRequestFieldNumber = 2,
    kBatchActuateStreamResponseFieldNumber = 3,
  };
  // .kuksa.val.v2.ProvideActuationRequest provide_actuation_request = 1;
  bool has_provide_actuation_request() const;
  private:
  bool _internal_has_provide_actuation_request() const;
  public:
  void clear_provide_actuation_request();
  const ::kuksa::val::v2::ProvideActuationRequest& provide_actuation_request() const;
  PROTOBUF_NODISCARD ::kuksa::val::v2::ProvideActuationRequest* release_provide_actuation_request();
  ::kuksa::val::v2::ProvideActuationRequest* mutable_provide_actuation_request();
  void set_allocated_provide_actuation_request(::kuksa::val::v2::ProvideActuationRequest* provide_actuation_request);
  private:
  const ::kuksa::val::v2::ProvideActuationRequest& _internal_provide_actuation_request() const;
  ::kuksa::val::v2::ProvideActuationRequest* _internal_mutable_provide_actuation_request();
  public:
  void unsafe_arena_set_allocated_provide_actuation_request(
      ::kuksa::val::v2::ProvideActuationRequest* provide_actuation_request);
  ::kuksa::val::v2::ProvideActuationRequest* unsafe_arena_release_provide_actuation_request();

  // .kuksa.val.v2.PublishValuesRequest publish_values_request = 2;
  bool has_publish_values_request() const;
  private:
  bool _internal_has_publish_values_request() const;
  public:
  void clear_publish_values_request();
  const ::kuksa::val::v2::PublishValuesRequest& publish_values_request() const;
  PROTOBUF_NODISCARD ::kuksa::val::v2::PublishValuesRequest* release_publish_values_request();
  ::kuksa::val::v2::PublishValuesRequest* mutable_publish_values_request();
  void set_allocated_publish_values_request(::kuksa::val::v2::PublishValuesRequest* publish_values_request);
  private:
  const ::kuksa::val::v2::PublishValuesRequest& _internal_publish_values_request() const;
  ::kuksa::val::v2::PublishValuesRequest* _internal_mutable_publish_values_request();
  public:
  void unsafe_arena_set_allocated_publish_values_request(
      ::kuksa::val::v2::PublishValuesRequest* publish_values_request);
  ::kuksa::val::v2::PublishValuesRequest* unsafe_arena_release_publish_values_request();

  // .kuksa.val.v2.BatchActuateStreamResponse batch_actuate_stream_response = 3;
  bool has_batch_actuate_stream_response() const;
  private:
  bool _internal_has_batch_actuate_stream_response() const;
  public:
  void clear_batch_actuate_stream_response();
  const ::kuksa::val::v2::BatchActuateStreamResponse& batch_actuate_stream_response() const;
  PROTOBUF_NODISCARD ::kuksa::val::v2::BatchActuateStreamResponse* release_batch_actuate_stream_response();
  ::kuksa::val::v2::BatchActuateStreamResponse* mutable_batch_actuate_stream_response();
  void set_allocated_batch_actuate_stream_response(::kuksa::val::v2::BatchActuateStreamResponse* batch_actuate_stream_response);
  private:
  const ::kuksa::val::v2::BatchActuateStreamResponse& _internal_batch_actuate_stream_response() const;
  ::kuksa::val::v2::BatchActuateStreamResponse* _internal_mutable_batch_actuate_stream_response();
  public:
  void unsafe_arena_set_allocated_batch_actuate_stream_response(
      ::kuksa::val::v2::BatchActuateStreamResponse* batch_actuate_stream_response);
  ::kuksa::val::v2::BatchActuateStreamResponse* unsafe_arena_release_batch_actuate_stream_response();

  void clear_action();
  ActionCase action_case() const;
  // @@protoc_insertion_point(class_scope:kuksa.val.v2.OpenProviderStreamRequest)
 private:
  class _Internal;
  void set_has_provide_actuation_request();
  void set_has_publish_values_request();
  void set_has_batch_actuate_stream_response();

  inline bool has_action() const;
  inline void clear_has_action();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ActionUnion {
      constexpr ActionUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::kuksa::val::v2::ProvideActuationRequest* provide_actuation_request_;
      ::kuksa::val::v2::PublishValuesRequest* publish_values_request_;
      ::kuksa::val::v2::BatchActuateStreamResponse* batch_actuate_stream_response_;
    } action_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kuksa_2fval_2fv2_2fval_2eproto;
};
// -------------------------------------------------------------------

class OpenProviderStreamResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kuksa.val.v2.OpenProviderStreamResponse) */ {
 public:
  inline OpenProviderStreamResponse() : OpenProviderStreamResponse(nullptr) {}
  ~OpenProviderStreamResponse() override;
  explicit PROTOBUF_CONSTEXPR OpenProviderStreamResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OpenProviderStreamResponse(const OpenProviderStreamResponse& from);
  OpenProviderStreamResponse(OpenProviderStreamResponse&& from) noexcept
    : OpenProviderStreamResponse() {
    *this = ::std::move(from);
  }

  inline OpenProviderStreamResponse& operator=(const OpenProviderStreamResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpenProviderStreamResponse& operator=(OpenProviderStreamResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpenProviderStreamResponse& default_instance() {
    return *internal_default_instance();
  }
  enum ActionCase {
    kProvideActuationResponse = 1,
    kPublishValuesResponse = 2,
    kBatchActuateStreamRequest = 3,
    ACTION_NOT_SET = 0,
  };

  static inline const OpenProviderStreamResponse* internal_default_instance() {
    return reinterpret_cast<const OpenProviderStreamResponse*>(
               &_OpenProviderStreamResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(OpenProviderStreamResponse& a, OpenProviderStreamResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(OpenProviderStreamResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpenProviderStreamResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpenProviderStreamResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OpenProviderStreamResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OpenProviderStreamResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OpenProviderStreamResponse& from) {
    OpenProviderStreamResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpenProviderStreamResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kuksa.val.v2.OpenProviderStreamResponse";
  }
  protected:
  explicit OpenProviderStreamResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProvideActuationResponseFieldNumber = 1,
    kPublishValuesResponseFieldNumber = 2,
    kBatchActuateStreamRequestFieldNumber = 3,
  };
  // .kuksa.val.v2.ProvideActuationResponse provide_actuation_response = 1;
  bool has_provide_actuation_response() const;
  private:
  bool _internal_has_provide_actuation_response() const;
  public:
  void clear_provide_actuation_response();
  const ::kuksa::val::v2::ProvideActuationResponse& provide_actuation_response() const;
  PROTOBUF_NODISCARD ::kuksa::val::v2::ProvideActuationResponse* release_provide_actuation_response();
  ::kuksa::val::v2::ProvideActuationResponse* mutable_provide_actuation_response();
  void set_allocated_provide_actuation_response(::kuksa::val::v2::ProvideActuationResponse* provide_actuation_response);
  private:
  const ::kuksa::val::v2::ProvideActuationResponse& _internal_provide_actuation_response() const;
  ::kuksa::val::v2::ProvideActuationResponse* _internal_mutable_provide_actuation_response();
  public:
  void unsafe_arena_set_allocated_provide_actuation_response(
      ::kuksa::val::v2::ProvideActuationResponse* provide_actuation_response);
  ::kuksa::val::v2::ProvideActuationResponse* unsafe_arena_release_provide_actuation_response();

  // .kuksa.val.v2.PublishValuesResponse publish_values_response = 2;
  bool has_publish_values_response() const;
  private:
  bool _internal_has_publish_values_response() const;
  public:
  void clear_publish_values_response();
  const ::kuksa::val::v2::PublishValuesResponse& publish_values_response() const;
  PROTOBUF_NODISCARD ::kuksa::val::v2::PublishValuesResponse* release_publish_values_response();
  ::kuksa::val::v2::PublishValuesResponse* mutable_publish_values_response();
  void set_allocated_publish_values_response(::kuksa::val::v2::PublishValuesResponse* publish_values_response);
  private:
  const ::kuksa::val::v2::PublishValuesResponse& _internal_publish_values_response() const;
  ::kuksa::val::v2::PublishValuesResponse* _internal_mutable_publish_values_response();
  public:
  void unsafe_arena_set_allocated_publish_values_response(
      ::kuksa::val::v2::PublishValuesResponse* publish_values_response);
  ::kuksa::val::v2::PublishValuesResponse* unsafe_arena_release_publish_values_response();

  // .kuksa.val.v2.BatchActuateStreamRequest batch_actuate_stream_request = 3;
  bool has_batch_actuate_stream_request() const;
  private:
  bool _internal_has_batch_actuate_stream_request() const;
  public:
  void clear_batch_actuate_stream_request();
  const ::kuksa::val::v2::BatchActuateStreamRequest& batch_actuate_stream_request() const;
  PROTOBUF_NODISCARD ::kuksa::val::v2::BatchActuateStreamRequest* release_batch_actuate_stream_request();
  ::kuksa::val::v2::BatchActuateStreamRequest* mutable_batch_actuate_stream_request();
  void set_allocated_batch_actuate_stream_request(::kuksa::val::v2::BatchActuateStreamRequest* batch_actuate_stream_request);
  private:
  const ::kuksa::val::v2::BatchActuateStreamRequest& _internal_batch_actuate_stream_request() const;
  ::kuksa::val::v2::BatchActuateStreamRequest* _internal_mutable_batch_actuate_stream_request();
  public:
  void unsafe_arena_set_allocated_batch_actuate_stream_request(
      ::kuksa::val::v2::BatchActuateStreamRequest* batch_actuate_stream_request);
  ::kuksa::val::v2::BatchActuateStreamRequest* unsafe_arena_release_batch_actuate_stream_request();

  void clear_action();
  ActionCase action_case() const;
  // @@protoc_insertion_point(class_scope:kuksa.val.v2.OpenProviderStreamResponse)
 private:
  class _Internal;
  void set_has_provide_actuation_response();
  void set_has_publish_values_response();
  void set_has_batch_actuate_stream_request();

  inline bool has_action() const;
  inline void clear_has_action();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ActionUnion {
      constexpr ActionUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::kuksa::val::v2::ProvideActuationResponse* provide_actuation_response_;
      ::kuksa::val::v2::PublishValuesResponse* publish_values_response_;
      ::kuksa::val::v2::BatchActuateStreamRequest* batch_actuate_stream_request_;
    } action_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kuksa_2fval_2fv2_2fval_2eproto;
};
// -------------------------------------------------------------------

class GetServerInfoRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:kuksa.val.v2.GetServerInfoRequest) */ {
 public:
  inline GetServerInfoRequest() : GetServerInfoRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GetServerInfoRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetServerInfoRequest(const GetServerInfoRequest& from);
  GetServerInfoRequest(GetServerInfoRequest&& from) noexcept
    : GetServerInfoRequest() {
    *this = ::std::move(from);
  }

  inline GetServerInfoRequest& operator=(const GetServerInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetServerInfoRequest& operator=(GetServerInfoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetServerInfoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetServerInfoRequest* internal_default_instance() {
    return reinterpret_cast<const GetServerInfoRequest*>(
               &_GetServerInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(GetServerInfoRequest& a, GetServerInfoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetServerInfoRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetServerInfoRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetServerInfoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetServerInfoRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetServerInfoRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetServerInfoRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kuksa.val.v2.GetServerInfoRequest";
  }
  protected:
  explicit GetServerInfoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:kuksa.val.v2.GetServerInfoRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_kuksa_2fval_2fv2_2fval_2eproto;
};
// -------------------------------------------------------------------

class GetServerInfoResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kuksa.val.v2.GetServerInfoResponse) */ {
 public:
  inline GetServerInfoResponse() : GetServerInfoResponse(nullptr) {}
  ~GetServerInfoResponse() override;
  explicit PROTOBUF_CONSTEXPR GetServerInfoResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetServerInfoResponse(const GetServerInfoResponse& from);
  GetServerInfoResponse(GetServerInfoResponse&& from) noexcept
    : GetServerInfoResponse() {
    *this = ::std::move(from);
  }

  inline GetServerInfoResponse& operator=(const GetServerInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetServerInfoResponse& operator=(GetServerInfoResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetServerInfoResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetServerInfoResponse* internal_default_instance() {
    return reinterpret_cast<const GetServerInfoResponse*>(
               &_GetServerInfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(GetServerInfoResponse& a, GetServerInfoResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetServerInfoResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetServerInfoResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetServerInfoResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetServerInfoResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetServerInfoResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetServerInfoResponse& from) {
    GetServerInfoResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetServerInfoResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kuksa.val.v2.GetServerInfoResponse";
  }
  protected:
  explicit GetServerInfoResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kVersionFieldNumber = 2,
    kCommitHashFieldNumber = 3,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string version = 2;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string commit_hash = 3;
  void clear_commit_hash();
  const std::string& commit_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_commit_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_commit_hash();
  PROTOBUF_NODISCARD std::string* release_commit_hash();
  void set_allocated_commit_hash(std::string* commit_hash);
  private:
  const std::string& _internal_commit_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_commit_hash(const std::string& value);
  std::string* _internal_mutable_commit_hash();
  public:

  // @@protoc_insertion_point(class_scope:kuksa.val.v2.GetServerInfoResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr commit_hash_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kuksa_2fval_2fv2_2fval_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// GetValueRequest

// .kuksa.val.v2.SignalID signal_id = 1;
inline bool GetValueRequest::_internal_has_signal_id() const {
  return this != internal_default_instance() && _impl_.signal_id_ != nullptr;
}
inline bool GetValueRequest::has_signal_id() const {
  return _internal_has_signal_id();
}
inline const ::kuksa::val::v2::SignalID& GetValueRequest::_internal_signal_id() const {
  const ::kuksa::val::v2::SignalID* p = _impl_.signal_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::kuksa::val::v2::SignalID&>(
      ::kuksa::val::v2::_SignalID_default_instance_);
}
inline const ::kuksa::val::v2::SignalID& GetValueRequest::signal_id() const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.GetValueRequest.signal_id)
  return _internal_signal_id();
}
inline void GetValueRequest::unsafe_arena_set_allocated_signal_id(
    ::kuksa::val::v2::SignalID* signal_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.signal_id_);
  }
  _impl_.signal_id_ = signal_id;
  if (signal_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kuksa.val.v2.GetValueRequest.signal_id)
}
inline ::kuksa::val::v2::SignalID* GetValueRequest::release_signal_id() {
  
  ::kuksa::val::v2::SignalID* temp = _impl_.signal_id_;
  _impl_.signal_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kuksa::val::v2::SignalID* GetValueRequest::unsafe_arena_release_signal_id() {
  // @@protoc_insertion_point(field_release:kuksa.val.v2.GetValueRequest.signal_id)
  
  ::kuksa::val::v2::SignalID* temp = _impl_.signal_id_;
  _impl_.signal_id_ = nullptr;
  return temp;
}
inline ::kuksa::val::v2::SignalID* GetValueRequest::_internal_mutable_signal_id() {
  
  if (_impl_.signal_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::kuksa::val::v2::SignalID>(GetArenaForAllocation());
    _impl_.signal_id_ = p;
  }
  return _impl_.signal_id_;
}
inline ::kuksa::val::v2::SignalID* GetValueRequest::mutable_signal_id() {
  ::kuksa::val::v2::SignalID* _msg = _internal_mutable_signal_id();
  // @@protoc_insertion_point(field_mutable:kuksa.val.v2.GetValueRequest.signal_id)
  return _msg;
}
inline void GetValueRequest::set_allocated_signal_id(::kuksa::val::v2::SignalID* signal_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.signal_id_);
  }
  if (signal_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(signal_id));
    if (message_arena != submessage_arena) {
      signal_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, signal_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.signal_id_ = signal_id;
  // @@protoc_insertion_point(field_set_allocated:kuksa.val.v2.GetValueRequest.signal_id)
}

// -------------------------------------------------------------------

// GetValueResponse

// .kuksa.val.v2.Datapoint data_point = 1;
inline bool GetValueResponse::_internal_has_data_point() const {
  return this != internal_default_instance() && _impl_.data_point_ != nullptr;
}
inline bool GetValueResponse::has_data_point() const {
  return _internal_has_data_point();
}
inline const ::kuksa::val::v2::Datapoint& GetValueResponse::_internal_data_point() const {
  const ::kuksa::val::v2::Datapoint* p = _impl_.data_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::kuksa::val::v2::Datapoint&>(
      ::kuksa::val::v2::_Datapoint_default_instance_);
}
inline const ::kuksa::val::v2::Datapoint& GetValueResponse::data_point() const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.GetValueResponse.data_point)
  return _internal_data_point();
}
inline void GetValueResponse::unsafe_arena_set_allocated_data_point(
    ::kuksa::val::v2::Datapoint* data_point) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_point_);
  }
  _impl_.data_point_ = data_point;
  if (data_point) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kuksa.val.v2.GetValueResponse.data_point)
}
inline ::kuksa::val::v2::Datapoint* GetValueResponse::release_data_point() {
  
  ::kuksa::val::v2::Datapoint* temp = _impl_.data_point_;
  _impl_.data_point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kuksa::val::v2::Datapoint* GetValueResponse::unsafe_arena_release_data_point() {
  // @@protoc_insertion_point(field_release:kuksa.val.v2.GetValueResponse.data_point)
  
  ::kuksa::val::v2::Datapoint* temp = _impl_.data_point_;
  _impl_.data_point_ = nullptr;
  return temp;
}
inline ::kuksa::val::v2::Datapoint* GetValueResponse::_internal_mutable_data_point() {
  
  if (_impl_.data_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::kuksa::val::v2::Datapoint>(GetArenaForAllocation());
    _impl_.data_point_ = p;
  }
  return _impl_.data_point_;
}
inline ::kuksa::val::v2::Datapoint* GetValueResponse::mutable_data_point() {
  ::kuksa::val::v2::Datapoint* _msg = _internal_mutable_data_point();
  // @@protoc_insertion_point(field_mutable:kuksa.val.v2.GetValueResponse.data_point)
  return _msg;
}
inline void GetValueResponse::set_allocated_data_point(::kuksa::val::v2::Datapoint* data_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_point_);
  }
  if (data_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_point));
    if (message_arena != submessage_arena) {
      data_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data_point, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_point_ = data_point;
  // @@protoc_insertion_point(field_set_allocated:kuksa.val.v2.GetValueResponse.data_point)
}

// -------------------------------------------------------------------

// GetValuesRequest

// repeated .kuksa.val.v2.SignalID signal_ids = 1;
inline int GetValuesRequest::_internal_signal_ids_size() const {
  return _impl_.signal_ids_.size();
}
inline int GetValuesRequest::signal_ids_size() const {
  return _internal_signal_ids_size();
}
inline ::kuksa::val::v2::SignalID* GetValuesRequest::mutable_signal_ids(int index) {
  // @@protoc_insertion_point(field_mutable:kuksa.val.v2.GetValuesRequest.signal_ids)
  return _impl_.signal_ids_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kuksa::val::v2::SignalID >*
GetValuesRequest::mutable_signal_ids() {
  // @@protoc_insertion_point(field_mutable_list:kuksa.val.v2.GetValuesRequest.signal_ids)
  return &_impl_.signal_ids_;
}
inline const ::kuksa::val::v2::SignalID& GetValuesRequest::_internal_signal_ids(int index) const {
  return _impl_.signal_ids_.Get(index);
}
inline const ::kuksa::val::v2::SignalID& GetValuesRequest::signal_ids(int index) const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.GetValuesRequest.signal_ids)
  return _internal_signal_ids(index);
}
inline ::kuksa::val::v2::SignalID* GetValuesRequest::_internal_add_signal_ids() {
  return _impl_.signal_ids_.Add();
}
inline ::kuksa::val::v2::SignalID* GetValuesRequest::add_signal_ids() {
  ::kuksa::val::v2::SignalID* _add = _internal_add_signal_ids();
  // @@protoc_insertion_point(field_add:kuksa.val.v2.GetValuesRequest.signal_ids)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kuksa::val::v2::SignalID >&
GetValuesRequest::signal_ids() const {
  // @@protoc_insertion_point(field_list:kuksa.val.v2.GetValuesRequest.signal_ids)
  return _impl_.signal_ids_;
}

// -------------------------------------------------------------------

// GetValuesResponse

// repeated .kuksa.val.v2.Datapoint data_points = 1;
inline int GetValuesResponse::_internal_data_points_size() const {
  return _impl_.data_points_.size();
}
inline int GetValuesResponse::data_points_size() const {
  return _internal_data_points_size();
}
inline ::kuksa::val::v2::Datapoint* GetValuesResponse::mutable_data_points(int index) {
  // @@protoc_insertion_point(field_mutable:kuksa.val.v2.GetValuesResponse.data_points)
  return _impl_.data_points_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kuksa::val::v2::Datapoint >*
GetValuesResponse::mutable_data_points() {
  // @@protoc_insertion_point(field_mutable_list:kuksa.val.v2.GetValuesResponse.data_points)
  return &_impl_.data_points_;
}
inline const ::kuksa::val::v2::Datapoint& GetValuesResponse::_internal_data_points(int index) const {
  return _impl_.data_points_.Get(index);
}
inline const ::kuksa::val::v2::Datapoint& GetValuesResponse::data_points(int index) const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.GetValuesResponse.data_points)
  return _internal_data_points(index);
}
inline ::kuksa::val::v2::Datapoint* GetValuesResponse::_internal_add_data_points() {
  return _impl_.data_points_.Add();
}
inline ::kuksa::val::v2::Datapoint* GetValuesResponse::add_data_points() {
  ::kuksa::val::v2::Datapoint* _add = _internal_add_data_points();
  // @@protoc_insertion_point(field_add:kuksa.val.v2.GetValuesResponse.data_points)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kuksa::val::v2::Datapoint >&
GetValuesResponse::data_points() const {
  // @@protoc_insertion_point(field_list:kuksa.val.v2.GetValuesResponse.data_points)
  return _impl_.data_points_;
}

// -------------------------------------------------------------------

// SubscribeRequest

// repeated string signal_paths = 1;
inline int SubscribeRequest::_internal_signal_paths_size() const {
  return _impl_.signal_paths_.size();
}
inline int SubscribeRequest::signal_paths_size() const {
  return _internal_signal_paths_size();
}
inline void SubscribeRequest::clear_signal_paths() {
  _impl_.signal_paths_.Clear();
}
inline std::string* SubscribeRequest::add_signal_paths() {
  std::string* _s = _internal_add_signal_paths();
  // @@protoc_insertion_point(field_add_mutable:kuksa.val.v2.SubscribeRequest.signal_paths)
  return _s;
}
inline const std::string& SubscribeRequest::_internal_signal_paths(int index) const {
  return _impl_.signal_paths_.Get(index);
}
inline const std::string& SubscribeRequest::signal_paths(int index) const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.SubscribeRequest.signal_paths)
  return _internal_signal_paths(index);
}
inline std::string* SubscribeRequest::mutable_signal_paths(int index) {
  // @@protoc_insertion_point(field_mutable:kuksa.val.v2.SubscribeRequest.signal_paths)
  return _impl_.signal_paths_.Mutable(index);
}
inline void SubscribeRequest::set_signal_paths(int index, const std::string& value) {
  _impl_.signal_paths_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:kuksa.val.v2.SubscribeRequest.signal_paths)
}
inline void SubscribeRequest::set_signal_paths(int index, std::string&& value) {
  _impl_.signal_paths_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:kuksa.val.v2.SubscribeRequest.signal_paths)
}
inline void SubscribeRequest::set_signal_paths(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.signal_paths_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:kuksa.val.v2.SubscribeRequest.signal_paths)
}
inline void SubscribeRequest::set_signal_paths(int index, const char* value, size_t size) {
  _impl_.signal_paths_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kuksa.val.v2.SubscribeRequest.signal_paths)
}
inline std::string* SubscribeRequest::_internal_add_signal_paths() {
  return _impl_.signal_paths_.Add();
}
inline void SubscribeRequest::add_signal_paths(const std::string& value) {
  _impl_.signal_paths_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:kuksa.val.v2.SubscribeRequest.signal_paths)
}
inline void SubscribeRequest::add_signal_paths(std::string&& value) {
  _impl_.signal_paths_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:kuksa.val.v2.SubscribeRequest.signal_paths)
}
inline void SubscribeRequest::add_signal_paths(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.signal_paths_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:kuksa.val.v2.SubscribeRequest.signal_paths)
}
inline void SubscribeRequest::add_signal_paths(const char* value, size_t size) {
  _impl_.signal_paths_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:kuksa.val.v2.SubscribeRequest.signal_paths)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SubscribeRequest::signal_paths() const {
  // @@protoc_insertion_point(field_list:kuksa.val.v2.SubscribeRequest.signal_paths)
  return _impl_.signal_paths_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SubscribeRequest::mutable_signal_paths() {
  // @@protoc_insertion_point(field_mutable_list:kuksa.val.v2.SubscribeRequest.signal_paths)
  return &_impl_.signal_paths_;
}

// uint32 buffer_size = 2;
inline void SubscribeRequest::clear_buffer_size() {
  _impl_.buffer_size_ = 0u;
}
inline uint32_t SubscribeRequest::_internal_buffer_size() const {
  return _impl_.buffer_size_;
}
inline uint32_t SubscribeRequest::buffer_size() const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.SubscribeRequest.buffer_size)
  return _internal_buffer_size();
}
inline void SubscribeRequest::_internal_set_buffer_size(uint32_t value) {
  
  _impl_.buffer_size_ = value;
}
inline void SubscribeRequest::set_buffer_size(uint32_t value) {
  _internal_set_buffer_size(value);
  // @@protoc_insertion_point(field_set:kuksa.val.v2.SubscribeRequest.buffer_size)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SubscribeResponse

// map<string, .kuksa.val.v2.Datapoint> entries = 1;
inline int SubscribeResponse::_internal_entries_size() const {
  return _impl_.entries_.size();
}
inline int SubscribeResponse::entries_size() const {
  return _internal_entries_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::kuksa::val::v2::Datapoint >&
SubscribeResponse::_internal_entries() const {
  return _impl_.entries_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::kuksa::val::v2::Datapoint >&
SubscribeResponse::entries() const {
  // @@protoc_insertion_point(field_map:kuksa.val.v2.SubscribeResponse.entries)
  return _internal_entries();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::kuksa::val::v2::Datapoint >*
SubscribeResponse::_internal_mutable_entries() {
  return _impl_.entries_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::kuksa::val::v2::Datapoint >*
SubscribeResponse::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_map:kuksa.val.v2.SubscribeResponse.entries)
  return _internal_mutable_entries();
}

// -------------------------------------------------------------------

// SubscribeByIdRequest

// repeated int32 signal_ids = 1;
inline int SubscribeByIdRequest::_internal_signal_ids_size() const {
  return _impl_.signal_ids_.size();
}
inline int SubscribeByIdRequest::signal_ids_size() const {
  return _internal_signal_ids_size();
}
inline void SubscribeByIdRequest::clear_signal_ids() {
  _impl_.signal_ids_.Clear();
}
inline int32_t SubscribeByIdRequest::_internal_signal_ids(int index) const {
  return _impl_.signal_ids_.Get(index);
}
inline int32_t SubscribeByIdRequest::signal_ids(int index) const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.SubscribeByIdRequest.signal_ids)
  return _internal_signal_ids(index);
}
inline void SubscribeByIdRequest::set_signal_ids(int index, int32_t value) {
  _impl_.signal_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:kuksa.val.v2.SubscribeByIdRequest.signal_ids)
}
inline void SubscribeByIdRequest::_internal_add_signal_ids(int32_t value) {
  _impl_.signal_ids_.Add(value);
}
inline void SubscribeByIdRequest::add_signal_ids(int32_t value) {
  _internal_add_signal_ids(value);
  // @@protoc_insertion_point(field_add:kuksa.val.v2.SubscribeByIdRequest.signal_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
SubscribeByIdRequest::_internal_signal_ids() const {
  return _impl_.signal_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
SubscribeByIdRequest::signal_ids() const {
  // @@protoc_insertion_point(field_list:kuksa.val.v2.SubscribeByIdRequest.signal_ids)
  return _internal_signal_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
SubscribeByIdRequest::_internal_mutable_signal_ids() {
  return &_impl_.signal_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
SubscribeByIdRequest::mutable_signal_ids() {
  // @@protoc_insertion_point(field_mutable_list:kuksa.val.v2.SubscribeByIdRequest.signal_ids)
  return _internal_mutable_signal_ids();
}

// uint32 buffer_size = 2;
inline void SubscribeByIdRequest::clear_buffer_size() {
  _impl_.buffer_size_ = 0u;
}
inline uint32_t SubscribeByIdRequest::_internal_buffer_size() const {
  return _impl_.buffer_size_;
}
inline uint32_t SubscribeByIdRequest::buffer_size() const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.SubscribeByIdRequest.buffer_size)
  return _internal_buffer_size();
}
inline void SubscribeByIdRequest::_internal_set_buffer_size(uint32_t value) {
  
  _impl_.buffer_size_ = value;
}
inline void SubscribeByIdRequest::set_buffer_size(uint32_t value) {
  _internal_set_buffer_size(value);
  // @@protoc_insertion_point(field_set:kuksa.val.v2.SubscribeByIdRequest.buffer_size)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SubscribeByIdResponse

// map<int32, .kuksa.val.v2.Datapoint> entries = 1;
inline int SubscribeByIdResponse::_internal_entries_size() const {
  return _impl_.entries_.size();
}
inline int SubscribeByIdResponse::entries_size() const {
  return _internal_entries_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::kuksa::val::v2::Datapoint >&
SubscribeByIdResponse::_internal_entries() const {
  return _impl_.entries_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::kuksa::val::v2::Datapoint >&
SubscribeByIdResponse::entries() const {
  // @@protoc_insertion_point(field_map:kuksa.val.v2.SubscribeByIdResponse.entries)
  return _internal_entries();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::kuksa::val::v2::Datapoint >*
SubscribeByIdResponse::_internal_mutable_entries() {
  return _impl_.entries_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::kuksa::val::v2::Datapoint >*
SubscribeByIdResponse::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_map:kuksa.val.v2.SubscribeByIdResponse.entries)
  return _internal_mutable_entries();
}

// -------------------------------------------------------------------

// ActuateRequest

// .kuksa.val.v2.SignalID signal_id = 1;
inline bool ActuateRequest::_internal_has_signal_id() const {
  return this != internal_default_instance() && _impl_.signal_id_ != nullptr;
}
inline bool ActuateRequest::has_signal_id() const {
  return _internal_has_signal_id();
}
inline const ::kuksa::val::v2::SignalID& ActuateRequest::_internal_signal_id() const {
  const ::kuksa::val::v2::SignalID* p = _impl_.signal_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::kuksa::val::v2::SignalID&>(
      ::kuksa::val::v2::_SignalID_default_instance_);
}
inline const ::kuksa::val::v2::SignalID& ActuateRequest::signal_id() const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.ActuateRequest.signal_id)
  return _internal_signal_id();
}
inline void ActuateRequest::unsafe_arena_set_allocated_signal_id(
    ::kuksa::val::v2::SignalID* signal_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.signal_id_);
  }
  _impl_.signal_id_ = signal_id;
  if (signal_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kuksa.val.v2.ActuateRequest.signal_id)
}
inline ::kuksa::val::v2::SignalID* ActuateRequest::release_signal_id() {
  
  ::kuksa::val::v2::SignalID* temp = _impl_.signal_id_;
  _impl_.signal_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kuksa::val::v2::SignalID* ActuateRequest::unsafe_arena_release_signal_id() {
  // @@protoc_insertion_point(field_release:kuksa.val.v2.ActuateRequest.signal_id)
  
  ::kuksa::val::v2::SignalID* temp = _impl_.signal_id_;
  _impl_.signal_id_ = nullptr;
  return temp;
}
inline ::kuksa::val::v2::SignalID* ActuateRequest::_internal_mutable_signal_id() {
  
  if (_impl_.signal_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::kuksa::val::v2::SignalID>(GetArenaForAllocation());
    _impl_.signal_id_ = p;
  }
  return _impl_.signal_id_;
}
inline ::kuksa::val::v2::SignalID* ActuateRequest::mutable_signal_id() {
  ::kuksa::val::v2::SignalID* _msg = _internal_mutable_signal_id();
  // @@protoc_insertion_point(field_mutable:kuksa.val.v2.ActuateRequest.signal_id)
  return _msg;
}
inline void ActuateRequest::set_allocated_signal_id(::kuksa::val::v2::SignalID* signal_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.signal_id_);
  }
  if (signal_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(signal_id));
    if (message_arena != submessage_arena) {
      signal_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, signal_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.signal_id_ = signal_id;
  // @@protoc_insertion_point(field_set_allocated:kuksa.val.v2.ActuateRequest.signal_id)
}

// .kuksa.val.v2.Value value = 2;
inline bool ActuateRequest::_internal_has_value() const {
  return this != internal_default_instance() && _impl_.value_ != nullptr;
}
inline bool ActuateRequest::has_value() const {
  return _internal_has_value();
}
inline const ::kuksa::val::v2::Value& ActuateRequest::_internal_value() const {
  const ::kuksa::val::v2::Value* p = _impl_.value_;
  return p != nullptr ? *p : reinterpret_cast<const ::kuksa::val::v2::Value&>(
      ::kuksa::val::v2::_Value_default_instance_);
}
inline const ::kuksa::val::v2::Value& ActuateRequest::value() const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.ActuateRequest.value)
  return _internal_value();
}
inline void ActuateRequest::unsafe_arena_set_allocated_value(
    ::kuksa::val::v2::Value* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.value_);
  }
  _impl_.value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kuksa.val.v2.ActuateRequest.value)
}
inline ::kuksa::val::v2::Value* ActuateRequest::release_value() {
  
  ::kuksa::val::v2::Value* temp = _impl_.value_;
  _impl_.value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kuksa::val::v2::Value* ActuateRequest::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:kuksa.val.v2.ActuateRequest.value)
  
  ::kuksa::val::v2::Value* temp = _impl_.value_;
  _impl_.value_ = nullptr;
  return temp;
}
inline ::kuksa::val::v2::Value* ActuateRequest::_internal_mutable_value() {
  
  if (_impl_.value_ == nullptr) {
    auto* p = CreateMaybeMessage<::kuksa::val::v2::Value>(GetArenaForAllocation());
    _impl_.value_ = p;
  }
  return _impl_.value_;
}
inline ::kuksa::val::v2::Value* ActuateRequest::mutable_value() {
  ::kuksa::val::v2::Value* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:kuksa.val.v2.ActuateRequest.value)
  return _msg;
}
inline void ActuateRequest::set_allocated_value(::kuksa::val::v2::Value* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.value_);
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.value_ = value;
  // @@protoc_insertion_point(field_set_allocated:kuksa.val.v2.ActuateRequest.value)
}

// -------------------------------------------------------------------

// ActuateResponse

// -------------------------------------------------------------------

// BatchActuateRequest

// repeated .kuksa.val.v2.ActuateRequest actuate_requests = 1;
inline int BatchActuateRequest::_internal_actuate_requests_size() const {
  return _impl_.actuate_requests_.size();
}
inline int BatchActuateRequest::actuate_requests_size() const {
  return _internal_actuate_requests_size();
}
inline void BatchActuateRequest::clear_actuate_requests() {
  _impl_.actuate_requests_.Clear();
}
inline ::kuksa::val::v2::ActuateRequest* BatchActuateRequest::mutable_actuate_requests(int index) {
  // @@protoc_insertion_point(field_mutable:kuksa.val.v2.BatchActuateRequest.actuate_requests)
  return _impl_.actuate_requests_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kuksa::val::v2::ActuateRequest >*
BatchActuateRequest::mutable_actuate_requests() {
  // @@protoc_insertion_point(field_mutable_list:kuksa.val.v2.BatchActuateRequest.actuate_requests)
  return &_impl_.actuate_requests_;
}
inline const ::kuksa::val::v2::ActuateRequest& BatchActuateRequest::_internal_actuate_requests(int index) const {
  return _impl_.actuate_requests_.Get(index);
}
inline const ::kuksa::val::v2::ActuateRequest& BatchActuateRequest::actuate_requests(int index) const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.BatchActuateRequest.actuate_requests)
  return _internal_actuate_requests(index);
}
inline ::kuksa::val::v2::ActuateRequest* BatchActuateRequest::_internal_add_actuate_requests() {
  return _impl_.actuate_requests_.Add();
}
inline ::kuksa::val::v2::ActuateRequest* BatchActuateRequest::add_actuate_requests() {
  ::kuksa::val::v2::ActuateRequest* _add = _internal_add_actuate_requests();
  // @@protoc_insertion_point(field_add:kuksa.val.v2.BatchActuateRequest.actuate_requests)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kuksa::val::v2::ActuateRequest >&
BatchActuateRequest::actuate_requests() const {
  // @@protoc_insertion_point(field_list:kuksa.val.v2.BatchActuateRequest.actuate_requests)
  return _impl_.actuate_requests_;
}

// -------------------------------------------------------------------

// BatchActuateResponse

// -------------------------------------------------------------------

// ListMetadataRequest

// string root = 1;
inline void ListMetadataRequest::clear_root() {
  _impl_.root_.ClearToEmpty();
}
inline const std::string& ListMetadataRequest::root() const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.ListMetadataRequest.root)
  return _internal_root();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListMetadataRequest::set_root(ArgT0&& arg0, ArgT... args) {
 
 _impl_.root_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kuksa.val.v2.ListMetadataRequest.root)
}
inline std::string* ListMetadataRequest::mutable_root() {
  std::string* _s = _internal_mutable_root();
  // @@protoc_insertion_point(field_mutable:kuksa.val.v2.ListMetadataRequest.root)
  return _s;
}
inline const std::string& ListMetadataRequest::_internal_root() const {
  return _impl_.root_.Get();
}
inline void ListMetadataRequest::_internal_set_root(const std::string& value) {
  
  _impl_.root_.Set(value, GetArenaForAllocation());
}
inline std::string* ListMetadataRequest::_internal_mutable_root() {
  
  return _impl_.root_.Mutable(GetArenaForAllocation());
}
inline std::string* ListMetadataRequest::release_root() {
  // @@protoc_insertion_point(field_release:kuksa.val.v2.ListMetadataRequest.root)
  return _impl_.root_.Release();
}
inline void ListMetadataRequest::set_allocated_root(std::string* root) {
  if (root != nullptr) {
    
  } else {
    
  }
  _impl_.root_.SetAllocated(root, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.root_.IsDefault()) {
    _impl_.root_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kuksa.val.v2.ListMetadataRequest.root)
}

// string filter = 2;
inline void ListMetadataRequest::clear_filter() {
  _impl_.filter_.ClearToEmpty();
}
inline const std::string& ListMetadataRequest::filter() const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.ListMetadataRequest.filter)
  return _internal_filter();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListMetadataRequest::set_filter(ArgT0&& arg0, ArgT... args) {
 
 _impl_.filter_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kuksa.val.v2.ListMetadataRequest.filter)
}
inline std::string* ListMetadataRequest::mutable_filter() {
  std::string* _s = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:kuksa.val.v2.ListMetadataRequest.filter)
  return _s;
}
inline const std::string& ListMetadataRequest::_internal_filter() const {
  return _impl_.filter_.Get();
}
inline void ListMetadataRequest::_internal_set_filter(const std::string& value) {
  
  _impl_.filter_.Set(value, GetArenaForAllocation());
}
inline std::string* ListMetadataRequest::_internal_mutable_filter() {
  
  return _impl_.filter_.Mutable(GetArenaForAllocation());
}
inline std::string* ListMetadataRequest::release_filter() {
  // @@protoc_insertion_point(field_release:kuksa.val.v2.ListMetadataRequest.filter)
  return _impl_.filter_.Release();
}
inline void ListMetadataRequest::set_allocated_filter(std::string* filter) {
  if (filter != nullptr) {
    
  } else {
    
  }
  _impl_.filter_.SetAllocated(filter, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filter_.IsDefault()) {
    _impl_.filter_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kuksa.val.v2.ListMetadataRequest.filter)
}

// -------------------------------------------------------------------

// ListMetadataResponse

// repeated .kuksa.val.v2.Metadata metadata = 1;
inline int ListMetadataResponse::_internal_metadata_size() const {
  return _impl_.metadata_.size();
}
inline int ListMetadataResponse::metadata_size() const {
  return _internal_metadata_size();
}
inline ::kuksa::val::v2::Metadata* ListMetadataResponse::mutable_metadata(int index) {
  // @@protoc_insertion_point(field_mutable:kuksa.val.v2.ListMetadataResponse.metadata)
  return _impl_.metadata_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kuksa::val::v2::Metadata >*
ListMetadataResponse::mutable_metadata() {
  // @@protoc_insertion_point(field_mutable_list:kuksa.val.v2.ListMetadataResponse.metadata)
  return &_impl_.metadata_;
}
inline const ::kuksa::val::v2::Metadata& ListMetadataResponse::_internal_metadata(int index) const {
  return _impl_.metadata_.Get(index);
}
inline const ::kuksa::val::v2::Metadata& ListMetadataResponse::metadata(int index) const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.ListMetadataResponse.metadata)
  return _internal_metadata(index);
}
inline ::kuksa::val::v2::Metadata* ListMetadataResponse::_internal_add_metadata() {
  return _impl_.metadata_.Add();
}
inline ::kuksa::val::v2::Metadata* ListMetadataResponse::add_metadata() {
  ::kuksa::val::v2::Metadata* _add = _internal_add_metadata();
  // @@protoc_insertion_point(field_add:kuksa.val.v2.ListMetadataResponse.metadata)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kuksa::val::v2::Metadata >&
ListMetadataResponse::metadata() const {
  // @@protoc_insertion_point(field_list:kuksa.val.v2.ListMetadataResponse.metadata)
  return _impl_.metadata_;
}

// -------------------------------------------------------------------

// PublishValueRequest

// .kuksa.val.v2.SignalID signal_id = 1;
inline bool PublishValueRequest::_internal_has_signal_id() const {
  return this != internal_default_instance() && _impl_.signal_id_ != nullptr;
}
inline bool PublishValueRequest::has_signal_id() const {
  return _internal_has_signal_id();
}
inline const ::kuksa::val::v2::SignalID& PublishValueRequest::_internal_signal_id() const {
  const ::kuksa::val::v2::SignalID* p = _impl_.signal_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::kuksa::val::v2::SignalID&>(
      ::kuksa::val::v2::_SignalID_default_instance_);
}
inline const ::kuksa::val::v2::SignalID& PublishValueRequest::signal_id() const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.PublishValueRequest.signal_id)
  return _internal_signal_id();
}
inline void PublishValueRequest::unsafe_arena_set_allocated_signal_id(
    ::kuksa::val::v2::SignalID* signal_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.signal_id_);
  }
  _impl_.signal_id_ = signal_id;
  if (signal_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kuksa.val.v2.PublishValueRequest.signal_id)
}
inline ::kuksa::val::v2::SignalID* PublishValueRequest::release_signal_id() {
  
  ::kuksa::val::v2::SignalID* temp = _impl_.signal_id_;
  _impl_.signal_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kuksa::val::v2::SignalID* PublishValueRequest::unsafe_arena_release_signal_id() {
  // @@protoc_insertion_point(field_release:kuksa.val.v2.PublishValueRequest.signal_id)
  
  ::kuksa::val::v2::SignalID* temp = _impl_.signal_id_;
  _impl_.signal_id_ = nullptr;
  return temp;
}
inline ::kuksa::val::v2::SignalID* PublishValueRequest::_internal_mutable_signal_id() {
  
  if (_impl_.signal_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::kuksa::val::v2::SignalID>(GetArenaForAllocation());
    _impl_.signal_id_ = p;
  }
  return _impl_.signal_id_;
}
inline ::kuksa::val::v2::SignalID* PublishValueRequest::mutable_signal_id() {
  ::kuksa::val::v2::SignalID* _msg = _internal_mutable_signal_id();
  // @@protoc_insertion_point(field_mutable:kuksa.val.v2.PublishValueRequest.signal_id)
  return _msg;
}
inline void PublishValueRequest::set_allocated_signal_id(::kuksa::val::v2::SignalID* signal_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.signal_id_);
  }
  if (signal_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(signal_id));
    if (message_arena != submessage_arena) {
      signal_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, signal_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.signal_id_ = signal_id;
  // @@protoc_insertion_point(field_set_allocated:kuksa.val.v2.PublishValueRequest.signal_id)
}

// .kuksa.val.v2.Datapoint data_point = 2;
inline bool PublishValueRequest::_internal_has_data_point() const {
  return this != internal_default_instance() && _impl_.data_point_ != nullptr;
}
inline bool PublishValueRequest::has_data_point() const {
  return _internal_has_data_point();
}
inline const ::kuksa::val::v2::Datapoint& PublishValueRequest::_internal_data_point() const {
  const ::kuksa::val::v2::Datapoint* p = _impl_.data_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::kuksa::val::v2::Datapoint&>(
      ::kuksa::val::v2::_Datapoint_default_instance_);
}
inline const ::kuksa::val::v2::Datapoint& PublishValueRequest::data_point() const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.PublishValueRequest.data_point)
  return _internal_data_point();
}
inline void PublishValueRequest::unsafe_arena_set_allocated_data_point(
    ::kuksa::val::v2::Datapoint* data_point) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_point_);
  }
  _impl_.data_point_ = data_point;
  if (data_point) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kuksa.val.v2.PublishValueRequest.data_point)
}
inline ::kuksa::val::v2::Datapoint* PublishValueRequest::release_data_point() {
  
  ::kuksa::val::v2::Datapoint* temp = _impl_.data_point_;
  _impl_.data_point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kuksa::val::v2::Datapoint* PublishValueRequest::unsafe_arena_release_data_point() {
  // @@protoc_insertion_point(field_release:kuksa.val.v2.PublishValueRequest.data_point)
  
  ::kuksa::val::v2::Datapoint* temp = _impl_.data_point_;
  _impl_.data_point_ = nullptr;
  return temp;
}
inline ::kuksa::val::v2::Datapoint* PublishValueRequest::_internal_mutable_data_point() {
  
  if (_impl_.data_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::kuksa::val::v2::Datapoint>(GetArenaForAllocation());
    _impl_.data_point_ = p;
  }
  return _impl_.data_point_;
}
inline ::kuksa::val::v2::Datapoint* PublishValueRequest::mutable_data_point() {
  ::kuksa::val::v2::Datapoint* _msg = _internal_mutable_data_point();
  // @@protoc_insertion_point(field_mutable:kuksa.val.v2.PublishValueRequest.data_point)
  return _msg;
}
inline void PublishValueRequest::set_allocated_data_point(::kuksa::val::v2::Datapoint* data_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_point_);
  }
  if (data_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_point));
    if (message_arena != submessage_arena) {
      data_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data_point, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_point_ = data_point;
  // @@protoc_insertion_point(field_set_allocated:kuksa.val.v2.PublishValueRequest.data_point)
}

// -------------------------------------------------------------------

// PublishValueResponse

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// PublishValuesRequest

// int32 request_id = 1;
inline void PublishValuesRequest::clear_request_id() {
  _impl_.request_id_ = 0;
}
inline int32_t PublishValuesRequest::_internal_request_id() const {
  return _impl_.request_id_;
}
inline int32_t PublishValuesRequest::request_id() const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.PublishValuesRequest.request_id)
  return _internal_request_id();
}
inline void PublishValuesRequest::_internal_set_request_id(int32_t value) {
  
  _impl_.request_id_ = value;
}
inline void PublishValuesRequest::set_request_id(int32_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:kuksa.val.v2.PublishValuesRequest.request_id)
}

// map<int32, .kuksa.val.v2.Datapoint> data_points = 2;
inline int PublishValuesRequest::_internal_data_points_size() const {
  return _impl_.data_points_.size();
}
inline int PublishValuesRequest::data_points_size() const {
  return _internal_data_points_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::kuksa::val::v2::Datapoint >&
PublishValuesRequest::_internal_data_points() const {
  return _impl_.data_points_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::kuksa::val::v2::Datapoint >&
PublishValuesRequest::data_points() const {
  // @@protoc_insertion_point(field_map:kuksa.val.v2.PublishValuesRequest.data_points)
  return _internal_data_points();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::kuksa::val::v2::Datapoint >*
PublishValuesRequest::_internal_mutable_data_points() {
  return _impl_.data_points_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::kuksa::val::v2::Datapoint >*
PublishValuesRequest::mutable_data_points() {
  // @@protoc_insertion_point(field_mutable_map:kuksa.val.v2.PublishValuesRequest.data_points)
  return _internal_mutable_data_points();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// PublishValuesResponse

// int32 request_id = 1;
inline void PublishValuesResponse::clear_request_id() {
  _impl_.request_id_ = 0;
}
inline int32_t PublishValuesResponse::_internal_request_id() const {
  return _impl_.request_id_;
}
inline int32_t PublishValuesResponse::request_id() const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.PublishValuesResponse.request_id)
  return _internal_request_id();
}
inline void PublishValuesResponse::_internal_set_request_id(int32_t value) {
  
  _impl_.request_id_ = value;
}
inline void PublishValuesResponse::set_request_id(int32_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:kuksa.val.v2.PublishValuesResponse.request_id)
}

// map<int32, .kuksa.val.v2.Error> status = 2;
inline int PublishValuesResponse::_internal_status_size() const {
  return _impl_.status_.size();
}
inline int PublishValuesResponse::status_size() const {
  return _internal_status_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::kuksa::val::v2::Error >&
PublishValuesResponse::_internal_status() const {
  return _impl_.status_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::kuksa::val::v2::Error >&
PublishValuesResponse::status() const {
  // @@protoc_insertion_point(field_map:kuksa.val.v2.PublishValuesResponse.status)
  return _internal_status();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::kuksa::val::v2::Error >*
PublishValuesResponse::_internal_mutable_status() {
  return _impl_.status_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::kuksa::val::v2::Error >*
PublishValuesResponse::mutable_status() {
  // @@protoc_insertion_point(field_mutable_map:kuksa.val.v2.PublishValuesResponse.status)
  return _internal_mutable_status();
}

// -------------------------------------------------------------------

// ProvideActuationRequest

// repeated .kuksa.val.v2.SignalID actuator_identifiers = 1;
inline int ProvideActuationRequest::_internal_actuator_identifiers_size() const {
  return _impl_.actuator_identifiers_.size();
}
inline int ProvideActuationRequest::actuator_identifiers_size() const {
  return _internal_actuator_identifiers_size();
}
inline ::kuksa::val::v2::SignalID* ProvideActuationRequest::mutable_actuator_identifiers(int index) {
  // @@protoc_insertion_point(field_mutable:kuksa.val.v2.ProvideActuationRequest.actuator_identifiers)
  return _impl_.actuator_identifiers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kuksa::val::v2::SignalID >*
ProvideActuationRequest::mutable_actuator_identifiers() {
  // @@protoc_insertion_point(field_mutable_list:kuksa.val.v2.ProvideActuationRequest.actuator_identifiers)
  return &_impl_.actuator_identifiers_;
}
inline const ::kuksa::val::v2::SignalID& ProvideActuationRequest::_internal_actuator_identifiers(int index) const {
  return _impl_.actuator_identifiers_.Get(index);
}
inline const ::kuksa::val::v2::SignalID& ProvideActuationRequest::actuator_identifiers(int index) const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.ProvideActuationRequest.actuator_identifiers)
  return _internal_actuator_identifiers(index);
}
inline ::kuksa::val::v2::SignalID* ProvideActuationRequest::_internal_add_actuator_identifiers() {
  return _impl_.actuator_identifiers_.Add();
}
inline ::kuksa::val::v2::SignalID* ProvideActuationRequest::add_actuator_identifiers() {
  ::kuksa::val::v2::SignalID* _add = _internal_add_actuator_identifiers();
  // @@protoc_insertion_point(field_add:kuksa.val.v2.ProvideActuationRequest.actuator_identifiers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kuksa::val::v2::SignalID >&
ProvideActuationRequest::actuator_identifiers() const {
  // @@protoc_insertion_point(field_list:kuksa.val.v2.ProvideActuationRequest.actuator_identifiers)
  return _impl_.actuator_identifiers_;
}

// -------------------------------------------------------------------

// ProvideActuationResponse

// -------------------------------------------------------------------

// BatchActuateStreamRequest

// repeated .kuksa.val.v2.ActuateRequest actuate_requests = 1;
inline int BatchActuateStreamRequest::_internal_actuate_requests_size() const {
  return _impl_.actuate_requests_.size();
}
inline int BatchActuateStreamRequest::actuate_requests_size() const {
  return _internal_actuate_requests_size();
}
inline void BatchActuateStreamRequest::clear_actuate_requests() {
  _impl_.actuate_requests_.Clear();
}
inline ::kuksa::val::v2::ActuateRequest* BatchActuateStreamRequest::mutable_actuate_requests(int index) {
  // @@protoc_insertion_point(field_mutable:kuksa.val.v2.BatchActuateStreamRequest.actuate_requests)
  return _impl_.actuate_requests_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kuksa::val::v2::ActuateRequest >*
BatchActuateStreamRequest::mutable_actuate_requests() {
  // @@protoc_insertion_point(field_mutable_list:kuksa.val.v2.BatchActuateStreamRequest.actuate_requests)
  return &_impl_.actuate_requests_;
}
inline const ::kuksa::val::v2::ActuateRequest& BatchActuateStreamRequest::_internal_actuate_requests(int index) const {
  return _impl_.actuate_requests_.Get(index);
}
inline const ::kuksa::val::v2::ActuateRequest& BatchActuateStreamRequest::actuate_requests(int index) const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.BatchActuateStreamRequest.actuate_requests)
  return _internal_actuate_requests(index);
}
inline ::kuksa::val::v2::ActuateRequest* BatchActuateStreamRequest::_internal_add_actuate_requests() {
  return _impl_.actuate_requests_.Add();
}
inline ::kuksa::val::v2::ActuateRequest* BatchActuateStreamRequest::add_actuate_requests() {
  ::kuksa::val::v2::ActuateRequest* _add = _internal_add_actuate_requests();
  // @@protoc_insertion_point(field_add:kuksa.val.v2.BatchActuateStreamRequest.actuate_requests)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kuksa::val::v2::ActuateRequest >&
BatchActuateStreamRequest::actuate_requests() const {
  // @@protoc_insertion_point(field_list:kuksa.val.v2.BatchActuateStreamRequest.actuate_requests)
  return _impl_.actuate_requests_;
}

// -------------------------------------------------------------------

// BatchActuateStreamResponse

// .kuksa.val.v2.SignalID signal_id = 1;
inline bool BatchActuateStreamResponse::_internal_has_signal_id() const {
  return this != internal_default_instance() && _impl_.signal_id_ != nullptr;
}
inline bool BatchActuateStreamResponse::has_signal_id() const {
  return _internal_has_signal_id();
}
inline const ::kuksa::val::v2::SignalID& BatchActuateStreamResponse::_internal_signal_id() const {
  const ::kuksa::val::v2::SignalID* p = _impl_.signal_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::kuksa::val::v2::SignalID&>(
      ::kuksa::val::v2::_SignalID_default_instance_);
}
inline const ::kuksa::val::v2::SignalID& BatchActuateStreamResponse::signal_id() const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.BatchActuateStreamResponse.signal_id)
  return _internal_signal_id();
}
inline void BatchActuateStreamResponse::unsafe_arena_set_allocated_signal_id(
    ::kuksa::val::v2::SignalID* signal_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.signal_id_);
  }
  _impl_.signal_id_ = signal_id;
  if (signal_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kuksa.val.v2.BatchActuateStreamResponse.signal_id)
}
inline ::kuksa::val::v2::SignalID* BatchActuateStreamResponse::release_signal_id() {
  
  ::kuksa::val::v2::SignalID* temp = _impl_.signal_id_;
  _impl_.signal_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kuksa::val::v2::SignalID* BatchActuateStreamResponse::unsafe_arena_release_signal_id() {
  // @@protoc_insertion_point(field_release:kuksa.val.v2.BatchActuateStreamResponse.signal_id)
  
  ::kuksa::val::v2::SignalID* temp = _impl_.signal_id_;
  _impl_.signal_id_ = nullptr;
  return temp;
}
inline ::kuksa::val::v2::SignalID* BatchActuateStreamResponse::_internal_mutable_signal_id() {
  
  if (_impl_.signal_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::kuksa::val::v2::SignalID>(GetArenaForAllocation());
    _impl_.signal_id_ = p;
  }
  return _impl_.signal_id_;
}
inline ::kuksa::val::v2::SignalID* BatchActuateStreamResponse::mutable_signal_id() {
  ::kuksa::val::v2::SignalID* _msg = _internal_mutable_signal_id();
  // @@protoc_insertion_point(field_mutable:kuksa.val.v2.BatchActuateStreamResponse.signal_id)
  return _msg;
}
inline void BatchActuateStreamResponse::set_allocated_signal_id(::kuksa::val::v2::SignalID* signal_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.signal_id_);
  }
  if (signal_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(signal_id));
    if (message_arena != submessage_arena) {
      signal_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, signal_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.signal_id_ = signal_id;
  // @@protoc_insertion_point(field_set_allocated:kuksa.val.v2.BatchActuateStreamResponse.signal_id)
}

// .kuksa.val.v2.Error error = 2;
inline bool BatchActuateStreamResponse::_internal_has_error() const {
  return this != internal_default_instance() && _impl_.error_ != nullptr;
}
inline bool BatchActuateStreamResponse::has_error() const {
  return _internal_has_error();
}
inline const ::kuksa::val::v2::Error& BatchActuateStreamResponse::_internal_error() const {
  const ::kuksa::val::v2::Error* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::kuksa::val::v2::Error&>(
      ::kuksa::val::v2::_Error_default_instance_);
}
inline const ::kuksa::val::v2::Error& BatchActuateStreamResponse::error() const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.BatchActuateStreamResponse.error)
  return _internal_error();
}
inline void BatchActuateStreamResponse::unsafe_arena_set_allocated_error(
    ::kuksa::val::v2::Error* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = error;
  if (error) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kuksa.val.v2.BatchActuateStreamResponse.error)
}
inline ::kuksa::val::v2::Error* BatchActuateStreamResponse::release_error() {
  
  ::kuksa::val::v2::Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kuksa::val::v2::Error* BatchActuateStreamResponse::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:kuksa.val.v2.BatchActuateStreamResponse.error)
  
  ::kuksa::val::v2::Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::kuksa::val::v2::Error* BatchActuateStreamResponse::_internal_mutable_error() {
  
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::kuksa::val::v2::Error>(GetArenaForAllocation());
    _impl_.error_ = p;
  }
  return _impl_.error_;
}
inline ::kuksa::val::v2::Error* BatchActuateStreamResponse::mutable_error() {
  ::kuksa::val::v2::Error* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:kuksa.val.v2.BatchActuateStreamResponse.error)
  return _msg;
}
inline void BatchActuateStreamResponse::set_allocated_error(::kuksa::val::v2::Error* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(error));
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.error_ = error;
  // @@protoc_insertion_point(field_set_allocated:kuksa.val.v2.BatchActuateStreamResponse.error)
}

// -------------------------------------------------------------------

// OpenProviderStreamRequest

// .kuksa.val.v2.ProvideActuationRequest provide_actuation_request = 1;
inline bool OpenProviderStreamRequest::_internal_has_provide_actuation_request() const {
  return action_case() == kProvideActuationRequest;
}
inline bool OpenProviderStreamRequest::has_provide_actuation_request() const {
  return _internal_has_provide_actuation_request();
}
inline void OpenProviderStreamRequest::set_has_provide_actuation_request() {
  _impl_._oneof_case_[0] = kProvideActuationRequest;
}
inline void OpenProviderStreamRequest::clear_provide_actuation_request() {
  if (_internal_has_provide_actuation_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.provide_actuation_request_;
    }
    clear_has_action();
  }
}
inline ::kuksa::val::v2::ProvideActuationRequest* OpenProviderStreamRequest::release_provide_actuation_request() {
  // @@protoc_insertion_point(field_release:kuksa.val.v2.OpenProviderStreamRequest.provide_actuation_request)
  if (_internal_has_provide_actuation_request()) {
    clear_has_action();
    ::kuksa::val::v2::ProvideActuationRequest* temp = _impl_.action_.provide_actuation_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.provide_actuation_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kuksa::val::v2::ProvideActuationRequest& OpenProviderStreamRequest::_internal_provide_actuation_request() const {
  return _internal_has_provide_actuation_request()
      ? *_impl_.action_.provide_actuation_request_
      : reinterpret_cast< ::kuksa::val::v2::ProvideActuationRequest&>(::kuksa::val::v2::_ProvideActuationRequest_default_instance_);
}
inline const ::kuksa::val::v2::ProvideActuationRequest& OpenProviderStreamRequest::provide_actuation_request() const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.OpenProviderStreamRequest.provide_actuation_request)
  return _internal_provide_actuation_request();
}
inline ::kuksa::val::v2::ProvideActuationRequest* OpenProviderStreamRequest::unsafe_arena_release_provide_actuation_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kuksa.val.v2.OpenProviderStreamRequest.provide_actuation_request)
  if (_internal_has_provide_actuation_request()) {
    clear_has_action();
    ::kuksa::val::v2::ProvideActuationRequest* temp = _impl_.action_.provide_actuation_request_;
    _impl_.action_.provide_actuation_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void OpenProviderStreamRequest::unsafe_arena_set_allocated_provide_actuation_request(::kuksa::val::v2::ProvideActuationRequest* provide_actuation_request) {
  clear_action();
  if (provide_actuation_request) {
    set_has_provide_actuation_request();
    _impl_.action_.provide_actuation_request_ = provide_actuation_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kuksa.val.v2.OpenProviderStreamRequest.provide_actuation_request)
}
inline ::kuksa::val::v2::ProvideActuationRequest* OpenProviderStreamRequest::_internal_mutable_provide_actuation_request() {
  if (!_internal_has_provide_actuation_request()) {
    clear_action();
    set_has_provide_actuation_request();
    _impl_.action_.provide_actuation_request_ = CreateMaybeMessage< ::kuksa::val::v2::ProvideActuationRequest >(GetArenaForAllocation());
  }
  return _impl_.action_.provide_actuation_request_;
}
inline ::kuksa::val::v2::ProvideActuationRequest* OpenProviderStreamRequest::mutable_provide_actuation_request() {
  ::kuksa::val::v2::ProvideActuationRequest* _msg = _internal_mutable_provide_actuation_request();
  // @@protoc_insertion_point(field_mutable:kuksa.val.v2.OpenProviderStreamRequest.provide_actuation_request)
  return _msg;
}

// .kuksa.val.v2.PublishValuesRequest publish_values_request = 2;
inline bool OpenProviderStreamRequest::_internal_has_publish_values_request() const {
  return action_case() == kPublishValuesRequest;
}
inline bool OpenProviderStreamRequest::has_publish_values_request() const {
  return _internal_has_publish_values_request();
}
inline void OpenProviderStreamRequest::set_has_publish_values_request() {
  _impl_._oneof_case_[0] = kPublishValuesRequest;
}
inline void OpenProviderStreamRequest::clear_publish_values_request() {
  if (_internal_has_publish_values_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.publish_values_request_;
    }
    clear_has_action();
  }
}
inline ::kuksa::val::v2::PublishValuesRequest* OpenProviderStreamRequest::release_publish_values_request() {
  // @@protoc_insertion_point(field_release:kuksa.val.v2.OpenProviderStreamRequest.publish_values_request)
  if (_internal_has_publish_values_request()) {
    clear_has_action();
    ::kuksa::val::v2::PublishValuesRequest* temp = _impl_.action_.publish_values_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.publish_values_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kuksa::val::v2::PublishValuesRequest& OpenProviderStreamRequest::_internal_publish_values_request() const {
  return _internal_has_publish_values_request()
      ? *_impl_.action_.publish_values_request_
      : reinterpret_cast< ::kuksa::val::v2::PublishValuesRequest&>(::kuksa::val::v2::_PublishValuesRequest_default_instance_);
}
inline const ::kuksa::val::v2::PublishValuesRequest& OpenProviderStreamRequest::publish_values_request() const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.OpenProviderStreamRequest.publish_values_request)
  return _internal_publish_values_request();
}
inline ::kuksa::val::v2::PublishValuesRequest* OpenProviderStreamRequest::unsafe_arena_release_publish_values_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kuksa.val.v2.OpenProviderStreamRequest.publish_values_request)
  if (_internal_has_publish_values_request()) {
    clear_has_action();
    ::kuksa::val::v2::PublishValuesRequest* temp = _impl_.action_.publish_values_request_;
    _impl_.action_.publish_values_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void OpenProviderStreamRequest::unsafe_arena_set_allocated_publish_values_request(::kuksa::val::v2::PublishValuesRequest* publish_values_request) {
  clear_action();
  if (publish_values_request) {
    set_has_publish_values_request();
    _impl_.action_.publish_values_request_ = publish_values_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kuksa.val.v2.OpenProviderStreamRequest.publish_values_request)
}
inline ::kuksa::val::v2::PublishValuesRequest* OpenProviderStreamRequest::_internal_mutable_publish_values_request() {
  if (!_internal_has_publish_values_request()) {
    clear_action();
    set_has_publish_values_request();
    _impl_.action_.publish_values_request_ = CreateMaybeMessage< ::kuksa::val::v2::PublishValuesRequest >(GetArenaForAllocation());
  }
  return _impl_.action_.publish_values_request_;
}
inline ::kuksa::val::v2::PublishValuesRequest* OpenProviderStreamRequest::mutable_publish_values_request() {
  ::kuksa::val::v2::PublishValuesRequest* _msg = _internal_mutable_publish_values_request();
  // @@protoc_insertion_point(field_mutable:kuksa.val.v2.OpenProviderStreamRequest.publish_values_request)
  return _msg;
}

// .kuksa.val.v2.BatchActuateStreamResponse batch_actuate_stream_response = 3;
inline bool OpenProviderStreamRequest::_internal_has_batch_actuate_stream_response() const {
  return action_case() == kBatchActuateStreamResponse;
}
inline bool OpenProviderStreamRequest::has_batch_actuate_stream_response() const {
  return _internal_has_batch_actuate_stream_response();
}
inline void OpenProviderStreamRequest::set_has_batch_actuate_stream_response() {
  _impl_._oneof_case_[0] = kBatchActuateStreamResponse;
}
inline void OpenProviderStreamRequest::clear_batch_actuate_stream_response() {
  if (_internal_has_batch_actuate_stream_response()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.batch_actuate_stream_response_;
    }
    clear_has_action();
  }
}
inline ::kuksa::val::v2::BatchActuateStreamResponse* OpenProviderStreamRequest::release_batch_actuate_stream_response() {
  // @@protoc_insertion_point(field_release:kuksa.val.v2.OpenProviderStreamRequest.batch_actuate_stream_response)
  if (_internal_has_batch_actuate_stream_response()) {
    clear_has_action();
    ::kuksa::val::v2::BatchActuateStreamResponse* temp = _impl_.action_.batch_actuate_stream_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.batch_actuate_stream_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kuksa::val::v2::BatchActuateStreamResponse& OpenProviderStreamRequest::_internal_batch_actuate_stream_response() const {
  return _internal_has_batch_actuate_stream_response()
      ? *_impl_.action_.batch_actuate_stream_response_
      : reinterpret_cast< ::kuksa::val::v2::BatchActuateStreamResponse&>(::kuksa::val::v2::_BatchActuateStreamResponse_default_instance_);
}
inline const ::kuksa::val::v2::BatchActuateStreamResponse& OpenProviderStreamRequest::batch_actuate_stream_response() const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.OpenProviderStreamRequest.batch_actuate_stream_response)
  return _internal_batch_actuate_stream_response();
}
inline ::kuksa::val::v2::BatchActuateStreamResponse* OpenProviderStreamRequest::unsafe_arena_release_batch_actuate_stream_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kuksa.val.v2.OpenProviderStreamRequest.batch_actuate_stream_response)
  if (_internal_has_batch_actuate_stream_response()) {
    clear_has_action();
    ::kuksa::val::v2::BatchActuateStreamResponse* temp = _impl_.action_.batch_actuate_stream_response_;
    _impl_.action_.batch_actuate_stream_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void OpenProviderStreamRequest::unsafe_arena_set_allocated_batch_actuate_stream_response(::kuksa::val::v2::BatchActuateStreamResponse* batch_actuate_stream_response) {
  clear_action();
  if (batch_actuate_stream_response) {
    set_has_batch_actuate_stream_response();
    _impl_.action_.batch_actuate_stream_response_ = batch_actuate_stream_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kuksa.val.v2.OpenProviderStreamRequest.batch_actuate_stream_response)
}
inline ::kuksa::val::v2::BatchActuateStreamResponse* OpenProviderStreamRequest::_internal_mutable_batch_actuate_stream_response() {
  if (!_internal_has_batch_actuate_stream_response()) {
    clear_action();
    set_has_batch_actuate_stream_response();
    _impl_.action_.batch_actuate_stream_response_ = CreateMaybeMessage< ::kuksa::val::v2::BatchActuateStreamResponse >(GetArenaForAllocation());
  }
  return _impl_.action_.batch_actuate_stream_response_;
}
inline ::kuksa::val::v2::BatchActuateStreamResponse* OpenProviderStreamRequest::mutable_batch_actuate_stream_response() {
  ::kuksa::val::v2::BatchActuateStreamResponse* _msg = _internal_mutable_batch_actuate_stream_response();
  // @@protoc_insertion_point(field_mutable:kuksa.val.v2.OpenProviderStreamRequest.batch_actuate_stream_response)
  return _msg;
}

inline bool OpenProviderStreamRequest::has_action() const {
  return action_case() != ACTION_NOT_SET;
}
inline void OpenProviderStreamRequest::clear_has_action() {
  _impl_._oneof_case_[0] = ACTION_NOT_SET;
}
inline OpenProviderStreamRequest::ActionCase OpenProviderStreamRequest::action_case() const {
  return OpenProviderStreamRequest::ActionCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// OpenProviderStreamResponse

// .kuksa.val.v2.ProvideActuationResponse provide_actuation_response = 1;
inline bool OpenProviderStreamResponse::_internal_has_provide_actuation_response() const {
  return action_case() == kProvideActuationResponse;
}
inline bool OpenProviderStreamResponse::has_provide_actuation_response() const {
  return _internal_has_provide_actuation_response();
}
inline void OpenProviderStreamResponse::set_has_provide_actuation_response() {
  _impl_._oneof_case_[0] = kProvideActuationResponse;
}
inline void OpenProviderStreamResponse::clear_provide_actuation_response() {
  if (_internal_has_provide_actuation_response()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.provide_actuation_response_;
    }
    clear_has_action();
  }
}
inline ::kuksa::val::v2::ProvideActuationResponse* OpenProviderStreamResponse::release_provide_actuation_response() {
  // @@protoc_insertion_point(field_release:kuksa.val.v2.OpenProviderStreamResponse.provide_actuation_response)
  if (_internal_has_provide_actuation_response()) {
    clear_has_action();
    ::kuksa::val::v2::ProvideActuationResponse* temp = _impl_.action_.provide_actuation_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.provide_actuation_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kuksa::val::v2::ProvideActuationResponse& OpenProviderStreamResponse::_internal_provide_actuation_response() const {
  return _internal_has_provide_actuation_response()
      ? *_impl_.action_.provide_actuation_response_
      : reinterpret_cast< ::kuksa::val::v2::ProvideActuationResponse&>(::kuksa::val::v2::_ProvideActuationResponse_default_instance_);
}
inline const ::kuksa::val::v2::ProvideActuationResponse& OpenProviderStreamResponse::provide_actuation_response() const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.OpenProviderStreamResponse.provide_actuation_response)
  return _internal_provide_actuation_response();
}
inline ::kuksa::val::v2::ProvideActuationResponse* OpenProviderStreamResponse::unsafe_arena_release_provide_actuation_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kuksa.val.v2.OpenProviderStreamResponse.provide_actuation_response)
  if (_internal_has_provide_actuation_response()) {
    clear_has_action();
    ::kuksa::val::v2::ProvideActuationResponse* temp = _impl_.action_.provide_actuation_response_;
    _impl_.action_.provide_actuation_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void OpenProviderStreamResponse::unsafe_arena_set_allocated_provide_actuation_response(::kuksa::val::v2::ProvideActuationResponse* provide_actuation_response) {
  clear_action();
  if (provide_actuation_response) {
    set_has_provide_actuation_response();
    _impl_.action_.provide_actuation_response_ = provide_actuation_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kuksa.val.v2.OpenProviderStreamResponse.provide_actuation_response)
}
inline ::kuksa::val::v2::ProvideActuationResponse* OpenProviderStreamResponse::_internal_mutable_provide_actuation_response() {
  if (!_internal_has_provide_actuation_response()) {
    clear_action();
    set_has_provide_actuation_response();
    _impl_.action_.provide_actuation_response_ = CreateMaybeMessage< ::kuksa::val::v2::ProvideActuationResponse >(GetArenaForAllocation());
  }
  return _impl_.action_.provide_actuation_response_;
}
inline ::kuksa::val::v2::ProvideActuationResponse* OpenProviderStreamResponse::mutable_provide_actuation_response() {
  ::kuksa::val::v2::ProvideActuationResponse* _msg = _internal_mutable_provide_actuation_response();
  // @@protoc_insertion_point(field_mutable:kuksa.val.v2.OpenProviderStreamResponse.provide_actuation_response)
  return _msg;
}

// .kuksa.val.v2.PublishValuesResponse publish_values_response = 2;
inline bool OpenProviderStreamResponse::_internal_has_publish_values_response() const {
  return action_case() == kPublishValuesResponse;
}
inline bool OpenProviderStreamResponse::has_publish_values_response() const {
  return _internal_has_publish_values_response();
}
inline void OpenProviderStreamResponse::set_has_publish_values_response() {
  _impl_._oneof_case_[0] = kPublishValuesResponse;
}
inline void OpenProviderStreamResponse::clear_publish_values_response() {
  if (_internal_has_publish_values_response()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.publish_values_response_;
    }
    clear_has_action();
  }
}
inline ::kuksa::val::v2::PublishValuesResponse* OpenProviderStreamResponse::release_publish_values_response() {
  // @@protoc_insertion_point(field_release:kuksa.val.v2.OpenProviderStreamResponse.publish_values_response)
  if (_internal_has_publish_values_response()) {
    clear_has_action();
    ::kuksa::val::v2::PublishValuesResponse* temp = _impl_.action_.publish_values_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.publish_values_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kuksa::val::v2::PublishValuesResponse& OpenProviderStreamResponse::_internal_publish_values_response() const {
  return _internal_has_publish_values_response()
      ? *_impl_.action_.publish_values_response_
      : reinterpret_cast< ::kuksa::val::v2::PublishValuesResponse&>(::kuksa::val::v2::_PublishValuesResponse_default_instance_);
}
inline const ::kuksa::val::v2::PublishValuesResponse& OpenProviderStreamResponse::publish_values_response() const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.OpenProviderStreamResponse.publish_values_response)
  return _internal_publish_values_response();
}
inline ::kuksa::val::v2::PublishValuesResponse* OpenProviderStreamResponse::unsafe_arena_release_publish_values_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kuksa.val.v2.OpenProviderStreamResponse.publish_values_response)
  if (_internal_has_publish_values_response()) {
    clear_has_action();
    ::kuksa::val::v2::PublishValuesResponse* temp = _impl_.action_.publish_values_response_;
    _impl_.action_.publish_values_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void OpenProviderStreamResponse::unsafe_arena_set_allocated_publish_values_response(::kuksa::val::v2::PublishValuesResponse* publish_values_response) {
  clear_action();
  if (publish_values_response) {
    set_has_publish_values_response();
    _impl_.action_.publish_values_response_ = publish_values_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kuksa.val.v2.OpenProviderStreamResponse.publish_values_response)
}
inline ::kuksa::val::v2::PublishValuesResponse* OpenProviderStreamResponse::_internal_mutable_publish_values_response() {
  if (!_internal_has_publish_values_response()) {
    clear_action();
    set_has_publish_values_response();
    _impl_.action_.publish_values_response_ = CreateMaybeMessage< ::kuksa::val::v2::PublishValuesResponse >(GetArenaForAllocation());
  }
  return _impl_.action_.publish_values_response_;
}
inline ::kuksa::val::v2::PublishValuesResponse* OpenProviderStreamResponse::mutable_publish_values_response() {
  ::kuksa::val::v2::PublishValuesResponse* _msg = _internal_mutable_publish_values_response();
  // @@protoc_insertion_point(field_mutable:kuksa.val.v2.OpenProviderStreamResponse.publish_values_response)
  return _msg;
}

// .kuksa.val.v2.BatchActuateStreamRequest batch_actuate_stream_request = 3;
inline bool OpenProviderStreamResponse::_internal_has_batch_actuate_stream_request() const {
  return action_case() == kBatchActuateStreamRequest;
}
inline bool OpenProviderStreamResponse::has_batch_actuate_stream_request() const {
  return _internal_has_batch_actuate_stream_request();
}
inline void OpenProviderStreamResponse::set_has_batch_actuate_stream_request() {
  _impl_._oneof_case_[0] = kBatchActuateStreamRequest;
}
inline void OpenProviderStreamResponse::clear_batch_actuate_stream_request() {
  if (_internal_has_batch_actuate_stream_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.action_.batch_actuate_stream_request_;
    }
    clear_has_action();
  }
}
inline ::kuksa::val::v2::BatchActuateStreamRequest* OpenProviderStreamResponse::release_batch_actuate_stream_request() {
  // @@protoc_insertion_point(field_release:kuksa.val.v2.OpenProviderStreamResponse.batch_actuate_stream_request)
  if (_internal_has_batch_actuate_stream_request()) {
    clear_has_action();
    ::kuksa::val::v2::BatchActuateStreamRequest* temp = _impl_.action_.batch_actuate_stream_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.action_.batch_actuate_stream_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kuksa::val::v2::BatchActuateStreamRequest& OpenProviderStreamResponse::_internal_batch_actuate_stream_request() const {
  return _internal_has_batch_actuate_stream_request()
      ? *_impl_.action_.batch_actuate_stream_request_
      : reinterpret_cast< ::kuksa::val::v2::BatchActuateStreamRequest&>(::kuksa::val::v2::_BatchActuateStreamRequest_default_instance_);
}
inline const ::kuksa::val::v2::BatchActuateStreamRequest& OpenProviderStreamResponse::batch_actuate_stream_request() const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.OpenProviderStreamResponse.batch_actuate_stream_request)
  return _internal_batch_actuate_stream_request();
}
inline ::kuksa::val::v2::BatchActuateStreamRequest* OpenProviderStreamResponse::unsafe_arena_release_batch_actuate_stream_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kuksa.val.v2.OpenProviderStreamResponse.batch_actuate_stream_request)
  if (_internal_has_batch_actuate_stream_request()) {
    clear_has_action();
    ::kuksa::val::v2::BatchActuateStreamRequest* temp = _impl_.action_.batch_actuate_stream_request_;
    _impl_.action_.batch_actuate_stream_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void OpenProviderStreamResponse::unsafe_arena_set_allocated_batch_actuate_stream_request(::kuksa::val::v2::BatchActuateStreamRequest* batch_actuate_stream_request) {
  clear_action();
  if (batch_actuate_stream_request) {
    set_has_batch_actuate_stream_request();
    _impl_.action_.batch_actuate_stream_request_ = batch_actuate_stream_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kuksa.val.v2.OpenProviderStreamResponse.batch_actuate_stream_request)
}
inline ::kuksa::val::v2::BatchActuateStreamRequest* OpenProviderStreamResponse::_internal_mutable_batch_actuate_stream_request() {
  if (!_internal_has_batch_actuate_stream_request()) {
    clear_action();
    set_has_batch_actuate_stream_request();
    _impl_.action_.batch_actuate_stream_request_ = CreateMaybeMessage< ::kuksa::val::v2::BatchActuateStreamRequest >(GetArenaForAllocation());
  }
  return _impl_.action_.batch_actuate_stream_request_;
}
inline ::kuksa::val::v2::BatchActuateStreamRequest* OpenProviderStreamResponse::mutable_batch_actuate_stream_request() {
  ::kuksa::val::v2::BatchActuateStreamRequest* _msg = _internal_mutable_batch_actuate_stream_request();
  // @@protoc_insertion_point(field_mutable:kuksa.val.v2.OpenProviderStreamResponse.batch_actuate_stream_request)
  return _msg;
}

inline bool OpenProviderStreamResponse::has_action() const {
  return action_case() != ACTION_NOT_SET;
}
inline void OpenProviderStreamResponse::clear_has_action() {
  _impl_._oneof_case_[0] = ACTION_NOT_SET;
}
inline OpenProviderStreamResponse::ActionCase OpenProviderStreamResponse::action_case() const {
  return OpenProviderStreamResponse::ActionCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// GetServerInfoRequest

// -------------------------------------------------------------------

// GetServerInfoResponse

// string name = 1;
inline void GetServerInfoResponse::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& GetServerInfoResponse::name() const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.GetServerInfoResponse.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetServerInfoResponse::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kuksa.val.v2.GetServerInfoResponse.name)
}
inline std::string* GetServerInfoResponse::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:kuksa.val.v2.GetServerInfoResponse.name)
  return _s;
}
inline const std::string& GetServerInfoResponse::_internal_name() const {
  return _impl_.name_.Get();
}
inline void GetServerInfoResponse::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* GetServerInfoResponse::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* GetServerInfoResponse::release_name() {
  // @@protoc_insertion_point(field_release:kuksa.val.v2.GetServerInfoResponse.name)
  return _impl_.name_.Release();
}
inline void GetServerInfoResponse::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kuksa.val.v2.GetServerInfoResponse.name)
}

// string version = 2;
inline void GetServerInfoResponse::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& GetServerInfoResponse::version() const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.GetServerInfoResponse.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetServerInfoResponse::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kuksa.val.v2.GetServerInfoResponse.version)
}
inline std::string* GetServerInfoResponse::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:kuksa.val.v2.GetServerInfoResponse.version)
  return _s;
}
inline const std::string& GetServerInfoResponse::_internal_version() const {
  return _impl_.version_.Get();
}
inline void GetServerInfoResponse::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* GetServerInfoResponse::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* GetServerInfoResponse::release_version() {
  // @@protoc_insertion_point(field_release:kuksa.val.v2.GetServerInfoResponse.version)
  return _impl_.version_.Release();
}
inline void GetServerInfoResponse::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kuksa.val.v2.GetServerInfoResponse.version)
}

// string commit_hash = 3;
inline void GetServerInfoResponse::clear_commit_hash() {
  _impl_.commit_hash_.ClearToEmpty();
}
inline const std::string& GetServerInfoResponse::commit_hash() const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.GetServerInfoResponse.commit_hash)
  return _internal_commit_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetServerInfoResponse::set_commit_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.commit_hash_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kuksa.val.v2.GetServerInfoResponse.commit_hash)
}
inline std::string* GetServerInfoResponse::mutable_commit_hash() {
  std::string* _s = _internal_mutable_commit_hash();
  // @@protoc_insertion_point(field_mutable:kuksa.val.v2.GetServerInfoResponse.commit_hash)
  return _s;
}
inline const std::string& GetServerInfoResponse::_internal_commit_hash() const {
  return _impl_.commit_hash_.Get();
}
inline void GetServerInfoResponse::_internal_set_commit_hash(const std::string& value) {
  
  _impl_.commit_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* GetServerInfoResponse::_internal_mutable_commit_hash() {
  
  return _impl_.commit_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* GetServerInfoResponse::release_commit_hash() {
  // @@protoc_insertion_point(field_release:kuksa.val.v2.GetServerInfoResponse.commit_hash)
  return _impl_.commit_hash_.Release();
}
inline void GetServerInfoResponse::set_allocated_commit_hash(std::string* commit_hash) {
  if (commit_hash != nullptr) {
    
  } else {
    
  }
  _impl_.commit_hash_.SetAllocated(commit_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.commit_hash_.IsDefault()) {
    _impl_.commit_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kuksa.val.v2.GetServerInfoResponse.commit_hash)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v2
}  // namespace val
}  // namespace kuksa

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_kuksa_2fval_2fv2_2fval_2eproto
