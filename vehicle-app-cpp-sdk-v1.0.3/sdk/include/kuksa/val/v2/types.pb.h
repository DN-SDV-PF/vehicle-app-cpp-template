// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: kuksa/val/v2/types.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_kuksa_2fval_2fv2_2ftypes_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_kuksa_2fval_2fv2_2ftypes_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_kuksa_2fval_2fv2_2ftypes_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_kuksa_2fval_2fv2_2ftypes_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_kuksa_2fval_2fv2_2ftypes_2eproto;
namespace kuksa {
namespace val {
namespace v2 {
class BoolArray;
struct BoolArrayDefaultTypeInternal;
extern BoolArrayDefaultTypeInternal _BoolArray_default_instance_;
class Datapoint;
struct DatapointDefaultTypeInternal;
extern DatapointDefaultTypeInternal _Datapoint_default_instance_;
class DoubleArray;
struct DoubleArrayDefaultTypeInternal;
extern DoubleArrayDefaultTypeInternal _DoubleArray_default_instance_;
class Error;
struct ErrorDefaultTypeInternal;
extern ErrorDefaultTypeInternal _Error_default_instance_;
class FloatArray;
struct FloatArrayDefaultTypeInternal;
extern FloatArrayDefaultTypeInternal _FloatArray_default_instance_;
class Int32Array;
struct Int32ArrayDefaultTypeInternal;
extern Int32ArrayDefaultTypeInternal _Int32Array_default_instance_;
class Int64Array;
struct Int64ArrayDefaultTypeInternal;
extern Int64ArrayDefaultTypeInternal _Int64Array_default_instance_;
class Metadata;
struct MetadataDefaultTypeInternal;
extern MetadataDefaultTypeInternal _Metadata_default_instance_;
class SignalID;
struct SignalIDDefaultTypeInternal;
extern SignalIDDefaultTypeInternal _SignalID_default_instance_;
class StringArray;
struct StringArrayDefaultTypeInternal;
extern StringArrayDefaultTypeInternal _StringArray_default_instance_;
class Uint32Array;
struct Uint32ArrayDefaultTypeInternal;
extern Uint32ArrayDefaultTypeInternal _Uint32Array_default_instance_;
class Uint64Array;
struct Uint64ArrayDefaultTypeInternal;
extern Uint64ArrayDefaultTypeInternal _Uint64Array_default_instance_;
class Value;
struct ValueDefaultTypeInternal;
extern ValueDefaultTypeInternal _Value_default_instance_;
}  // namespace v2
}  // namespace val
}  // namespace kuksa
PROTOBUF_NAMESPACE_OPEN
template<> ::kuksa::val::v2::BoolArray* Arena::CreateMaybeMessage<::kuksa::val::v2::BoolArray>(Arena*);
template<> ::kuksa::val::v2::Datapoint* Arena::CreateMaybeMessage<::kuksa::val::v2::Datapoint>(Arena*);
template<> ::kuksa::val::v2::DoubleArray* Arena::CreateMaybeMessage<::kuksa::val::v2::DoubleArray>(Arena*);
template<> ::kuksa::val::v2::Error* Arena::CreateMaybeMessage<::kuksa::val::v2::Error>(Arena*);
template<> ::kuksa::val::v2::FloatArray* Arena::CreateMaybeMessage<::kuksa::val::v2::FloatArray>(Arena*);
template<> ::kuksa::val::v2::Int32Array* Arena::CreateMaybeMessage<::kuksa::val::v2::Int32Array>(Arena*);
template<> ::kuksa::val::v2::Int64Array* Arena::CreateMaybeMessage<::kuksa::val::v2::Int64Array>(Arena*);
template<> ::kuksa::val::v2::Metadata* Arena::CreateMaybeMessage<::kuksa::val::v2::Metadata>(Arena*);
template<> ::kuksa::val::v2::SignalID* Arena::CreateMaybeMessage<::kuksa::val::v2::SignalID>(Arena*);
template<> ::kuksa::val::v2::StringArray* Arena::CreateMaybeMessage<::kuksa::val::v2::StringArray>(Arena*);
template<> ::kuksa::val::v2::Uint32Array* Arena::CreateMaybeMessage<::kuksa::val::v2::Uint32Array>(Arena*);
template<> ::kuksa::val::v2::Uint64Array* Arena::CreateMaybeMessage<::kuksa::val::v2::Uint64Array>(Arena*);
template<> ::kuksa::val::v2::Value* Arena::CreateMaybeMessage<::kuksa::val::v2::Value>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace kuksa {
namespace val {
namespace v2 {

enum ErrorCode : int {
  ERROR_CODE_UNSPECIFIED = 0,
  ERROR_CODE_OK = 1,
  ERROR_CODE_INVALID_ARGUMENT = 2,
  ERROR_CODE_NOT_FOUND = 3,
  ERROR_CODE_PERMISSION_DENIED = 4,
  ErrorCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ErrorCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ErrorCode_IsValid(int value);
constexpr ErrorCode ErrorCode_MIN = ERROR_CODE_UNSPECIFIED;
constexpr ErrorCode ErrorCode_MAX = ERROR_CODE_PERMISSION_DENIED;
constexpr int ErrorCode_ARRAYSIZE = ErrorCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ErrorCode_descriptor();
template<typename T>
inline const std::string& ErrorCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ErrorCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ErrorCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ErrorCode_descriptor(), enum_t_value);
}
inline bool ErrorCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ErrorCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ErrorCode>(
    ErrorCode_descriptor(), name, value);
}
enum DataType : int {
  DATA_TYPE_UNSPECIFIED = 0,
  DATA_TYPE_STRING = 1,
  DATA_TYPE_BOOLEAN = 2,
  DATA_TYPE_INT8 = 3,
  DATA_TYPE_INT16 = 4,
  DATA_TYPE_INT32 = 5,
  DATA_TYPE_INT64 = 6,
  DATA_TYPE_UINT8 = 7,
  DATA_TYPE_UINT16 = 8,
  DATA_TYPE_UINT32 = 9,
  DATA_TYPE_UINT64 = 10,
  DATA_TYPE_FLOAT = 11,
  DATA_TYPE_DOUBLE = 12,
  DATA_TYPE_TIMESTAMP = 13,
  DATA_TYPE_STRING_ARRAY = 20,
  DATA_TYPE_BOOLEAN_ARRAY = 21,
  DATA_TYPE_INT8_ARRAY = 22,
  DATA_TYPE_INT16_ARRAY = 23,
  DATA_TYPE_INT32_ARRAY = 24,
  DATA_TYPE_INT64_ARRAY = 25,
  DATA_TYPE_UINT8_ARRAY = 26,
  DATA_TYPE_UINT16_ARRAY = 27,
  DATA_TYPE_UINT32_ARRAY = 28,
  DATA_TYPE_UINT64_ARRAY = 29,
  DATA_TYPE_FLOAT_ARRAY = 30,
  DATA_TYPE_DOUBLE_ARRAY = 31,
  DATA_TYPE_TIMESTAMP_ARRAY = 32,
  DataType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DataType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DataType_IsValid(int value);
constexpr DataType DataType_MIN = DATA_TYPE_UNSPECIFIED;
constexpr DataType DataType_MAX = DATA_TYPE_TIMESTAMP_ARRAY;
constexpr int DataType_ARRAYSIZE = DataType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DataType_descriptor();
template<typename T>
inline const std::string& DataType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DataType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DataType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DataType_descriptor(), enum_t_value);
}
inline bool DataType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DataType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DataType>(
    DataType_descriptor(), name, value);
}
enum EntryType : int {
  ENTRY_TYPE_UNSPECIFIED = 0,
  ENTRY_TYPE_ATTRIBUTE = 1,
  ENTRY_TYPE_SENSOR = 2,
  ENTRY_TYPE_ACTUATOR = 3,
  EntryType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EntryType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EntryType_IsValid(int value);
constexpr EntryType EntryType_MIN = ENTRY_TYPE_UNSPECIFIED;
constexpr EntryType EntryType_MAX = ENTRY_TYPE_ACTUATOR;
constexpr int EntryType_ARRAYSIZE = EntryType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EntryType_descriptor();
template<typename T>
inline const std::string& EntryType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EntryType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EntryType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EntryType_descriptor(), enum_t_value);
}
inline bool EntryType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EntryType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EntryType>(
    EntryType_descriptor(), name, value);
}
// ===================================================================

class Datapoint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kuksa.val.v2.Datapoint) */ {
 public:
  inline Datapoint() : Datapoint(nullptr) {}
  ~Datapoint() override;
  explicit PROTOBUF_CONSTEXPR Datapoint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Datapoint(const Datapoint& from);
  Datapoint(Datapoint&& from) noexcept
    : Datapoint() {
    *this = ::std::move(from);
  }

  inline Datapoint& operator=(const Datapoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline Datapoint& operator=(Datapoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Datapoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const Datapoint* internal_default_instance() {
    return reinterpret_cast<const Datapoint*>(
               &_Datapoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Datapoint& a, Datapoint& b) {
    a.Swap(&b);
  }
  inline void Swap(Datapoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Datapoint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Datapoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Datapoint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Datapoint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Datapoint& from) {
    Datapoint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Datapoint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kuksa.val.v2.Datapoint";
  }
  protected:
  explicit Datapoint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // .google.protobuf.Timestamp timestamp = 1;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // .kuksa.val.v2.Value value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::kuksa::val::v2::Value& value() const;
  PROTOBUF_NODISCARD ::kuksa::val::v2::Value* release_value();
  ::kuksa::val::v2::Value* mutable_value();
  void set_allocated_value(::kuksa::val::v2::Value* value);
  private:
  const ::kuksa::val::v2::Value& _internal_value() const;
  ::kuksa::val::v2::Value* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::kuksa::val::v2::Value* value);
  ::kuksa::val::v2::Value* unsafe_arena_release_value();

  // @@protoc_insertion_point(class_scope:kuksa.val.v2.Datapoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
    ::kuksa::val::v2::Value* value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kuksa_2fval_2fv2_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class Value final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kuksa.val.v2.Value) */ {
 public:
  inline Value() : Value(nullptr) {}
  ~Value() override;
  explicit PROTOBUF_CONSTEXPR Value(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Value(const Value& from);
  Value(Value&& from) noexcept
    : Value() {
    *this = ::std::move(from);
  }

  inline Value& operator=(const Value& from) {
    CopyFrom(from);
    return *this;
  }
  inline Value& operator=(Value&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Value& default_instance() {
    return *internal_default_instance();
  }
  enum TypedValueCase {
    kString = 11,
    kBool = 12,
    kInt32 = 13,
    kInt64 = 14,
    kUint32 = 15,
    kUint64 = 16,
    kFloat = 17,
    kDouble = 18,
    kStringArray = 21,
    kBoolArray = 22,
    kInt32Array = 23,
    kInt64Array = 24,
    kUint32Array = 25,
    kUint64Array = 26,
    kFloatArray = 27,
    kDoubleArray = 28,
    TYPED_VALUE_NOT_SET = 0,
  };

  static inline const Value* internal_default_instance() {
    return reinterpret_cast<const Value*>(
               &_Value_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Value& a, Value& b) {
    a.Swap(&b);
  }
  inline void Swap(Value* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Value* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Value* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Value>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Value& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Value& from) {
    Value::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Value* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kuksa.val.v2.Value";
  }
  protected:
  explicit Value(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStringFieldNumber = 11,
    kBoolFieldNumber = 12,
    kInt32FieldNumber = 13,
    kInt64FieldNumber = 14,
    kUint32FieldNumber = 15,
    kUint64FieldNumber = 16,
    kFloatFieldNumber = 17,
    kDoubleFieldNumber = 18,
    kStringArrayFieldNumber = 21,
    kBoolArrayFieldNumber = 22,
    kInt32ArrayFieldNumber = 23,
    kInt64ArrayFieldNumber = 24,
    kUint32ArrayFieldNumber = 25,
    kUint64ArrayFieldNumber = 26,
    kFloatArrayFieldNumber = 27,
    kDoubleArrayFieldNumber = 28,
  };
  // string string = 11;
  bool has_string() const;
  private:
  bool _internal_has_string() const;
  public:
  void clear_string();
  const std::string& string() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_string(ArgT0&& arg0, ArgT... args);
  std::string* mutable_string();
  PROTOBUF_NODISCARD std::string* release_string();
  void set_allocated_string(std::string* string);
  private:
  const std::string& _internal_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_string(const std::string& value);
  std::string* _internal_mutable_string();
  public:

  // bool bool = 12;
  bool has_bool_() const;
  private:
  bool _internal_has_bool_() const;
  public:
  void clear_bool_();
  bool bool_() const;
  void set_bool_(bool value);
  private:
  bool _internal_bool_() const;
  void _internal_set_bool_(bool value);
  public:

  // sint32 int32 = 13;
  bool has_int32() const;
  private:
  bool _internal_has_int32() const;
  public:
  void clear_int32();
  int32_t int32() const;
  void set_int32(int32_t value);
  private:
  int32_t _internal_int32() const;
  void _internal_set_int32(int32_t value);
  public:

  // sint64 int64 = 14;
  bool has_int64() const;
  private:
  bool _internal_has_int64() const;
  public:
  void clear_int64();
  int64_t int64() const;
  void set_int64(int64_t value);
  private:
  int64_t _internal_int64() const;
  void _internal_set_int64(int64_t value);
  public:

  // uint32 uint32 = 15;
  bool has_uint32() const;
  private:
  bool _internal_has_uint32() const;
  public:
  void clear_uint32();
  uint32_t uint32() const;
  void set_uint32(uint32_t value);
  private:
  uint32_t _internal_uint32() const;
  void _internal_set_uint32(uint32_t value);
  public:

  // uint64 uint64 = 16;
  bool has_uint64() const;
  private:
  bool _internal_has_uint64() const;
  public:
  void clear_uint64();
  uint64_t uint64() const;
  void set_uint64(uint64_t value);
  private:
  uint64_t _internal_uint64() const;
  void _internal_set_uint64(uint64_t value);
  public:

  // float float = 17;
  bool has_float_() const;
  private:
  bool _internal_has_float_() const;
  public:
  void clear_float_();
  float float_() const;
  void set_float_(float value);
  private:
  float _internal_float_() const;
  void _internal_set_float_(float value);
  public:

  // double double = 18;
  bool has_double_() const;
  private:
  bool _internal_has_double_() const;
  public:
  void clear_double_();
  double double_() const;
  void set_double_(double value);
  private:
  double _internal_double_() const;
  void _internal_set_double_(double value);
  public:

  // .kuksa.val.v2.StringArray string_array = 21;
  bool has_string_array() const;
  private:
  bool _internal_has_string_array() const;
  public:
  void clear_string_array();
  const ::kuksa::val::v2::StringArray& string_array() const;
  PROTOBUF_NODISCARD ::kuksa::val::v2::StringArray* release_string_array();
  ::kuksa::val::v2::StringArray* mutable_string_array();
  void set_allocated_string_array(::kuksa::val::v2::StringArray* string_array);
  private:
  const ::kuksa::val::v2::StringArray& _internal_string_array() const;
  ::kuksa::val::v2::StringArray* _internal_mutable_string_array();
  public:
  void unsafe_arena_set_allocated_string_array(
      ::kuksa::val::v2::StringArray* string_array);
  ::kuksa::val::v2::StringArray* unsafe_arena_release_string_array();

  // .kuksa.val.v2.BoolArray bool_array = 22;
  bool has_bool_array() const;
  private:
  bool _internal_has_bool_array() const;
  public:
  void clear_bool_array();
  const ::kuksa::val::v2::BoolArray& bool_array() const;
  PROTOBUF_NODISCARD ::kuksa::val::v2::BoolArray* release_bool_array();
  ::kuksa::val::v2::BoolArray* mutable_bool_array();
  void set_allocated_bool_array(::kuksa::val::v2::BoolArray* bool_array);
  private:
  const ::kuksa::val::v2::BoolArray& _internal_bool_array() const;
  ::kuksa::val::v2::BoolArray* _internal_mutable_bool_array();
  public:
  void unsafe_arena_set_allocated_bool_array(
      ::kuksa::val::v2::BoolArray* bool_array);
  ::kuksa::val::v2::BoolArray* unsafe_arena_release_bool_array();

  // .kuksa.val.v2.Int32Array int32_array = 23;
  bool has_int32_array() const;
  private:
  bool _internal_has_int32_array() const;
  public:
  void clear_int32_array();
  const ::kuksa::val::v2::Int32Array& int32_array() const;
  PROTOBUF_NODISCARD ::kuksa::val::v2::Int32Array* release_int32_array();
  ::kuksa::val::v2::Int32Array* mutable_int32_array();
  void set_allocated_int32_array(::kuksa::val::v2::Int32Array* int32_array);
  private:
  const ::kuksa::val::v2::Int32Array& _internal_int32_array() const;
  ::kuksa::val::v2::Int32Array* _internal_mutable_int32_array();
  public:
  void unsafe_arena_set_allocated_int32_array(
      ::kuksa::val::v2::Int32Array* int32_array);
  ::kuksa::val::v2::Int32Array* unsafe_arena_release_int32_array();

  // .kuksa.val.v2.Int64Array int64_array = 24;
  bool has_int64_array() const;
  private:
  bool _internal_has_int64_array() const;
  public:
  void clear_int64_array();
  const ::kuksa::val::v2::Int64Array& int64_array() const;
  PROTOBUF_NODISCARD ::kuksa::val::v2::Int64Array* release_int64_array();
  ::kuksa::val::v2::Int64Array* mutable_int64_array();
  void set_allocated_int64_array(::kuksa::val::v2::Int64Array* int64_array);
  private:
  const ::kuksa::val::v2::Int64Array& _internal_int64_array() const;
  ::kuksa::val::v2::Int64Array* _internal_mutable_int64_array();
  public:
  void unsafe_arena_set_allocated_int64_array(
      ::kuksa::val::v2::Int64Array* int64_array);
  ::kuksa::val::v2::Int64Array* unsafe_arena_release_int64_array();

  // .kuksa.val.v2.Uint32Array uint32_array = 25;
  bool has_uint32_array() const;
  private:
  bool _internal_has_uint32_array() const;
  public:
  void clear_uint32_array();
  const ::kuksa::val::v2::Uint32Array& uint32_array() const;
  PROTOBUF_NODISCARD ::kuksa::val::v2::Uint32Array* release_uint32_array();
  ::kuksa::val::v2::Uint32Array* mutable_uint32_array();
  void set_allocated_uint32_array(::kuksa::val::v2::Uint32Array* uint32_array);
  private:
  const ::kuksa::val::v2::Uint32Array& _internal_uint32_array() const;
  ::kuksa::val::v2::Uint32Array* _internal_mutable_uint32_array();
  public:
  void unsafe_arena_set_allocated_uint32_array(
      ::kuksa::val::v2::Uint32Array* uint32_array);
  ::kuksa::val::v2::Uint32Array* unsafe_arena_release_uint32_array();

  // .kuksa.val.v2.Uint64Array uint64_array = 26;
  bool has_uint64_array() const;
  private:
  bool _internal_has_uint64_array() const;
  public:
  void clear_uint64_array();
  const ::kuksa::val::v2::Uint64Array& uint64_array() const;
  PROTOBUF_NODISCARD ::kuksa::val::v2::Uint64Array* release_uint64_array();
  ::kuksa::val::v2::Uint64Array* mutable_uint64_array();
  void set_allocated_uint64_array(::kuksa::val::v2::Uint64Array* uint64_array);
  private:
  const ::kuksa::val::v2::Uint64Array& _internal_uint64_array() const;
  ::kuksa::val::v2::Uint64Array* _internal_mutable_uint64_array();
  public:
  void unsafe_arena_set_allocated_uint64_array(
      ::kuksa::val::v2::Uint64Array* uint64_array);
  ::kuksa::val::v2::Uint64Array* unsafe_arena_release_uint64_array();

  // .kuksa.val.v2.FloatArray float_array = 27;
  bool has_float_array() const;
  private:
  bool _internal_has_float_array() const;
  public:
  void clear_float_array();
  const ::kuksa::val::v2::FloatArray& float_array() const;
  PROTOBUF_NODISCARD ::kuksa::val::v2::FloatArray* release_float_array();
  ::kuksa::val::v2::FloatArray* mutable_float_array();
  void set_allocated_float_array(::kuksa::val::v2::FloatArray* float_array);
  private:
  const ::kuksa::val::v2::FloatArray& _internal_float_array() const;
  ::kuksa::val::v2::FloatArray* _internal_mutable_float_array();
  public:
  void unsafe_arena_set_allocated_float_array(
      ::kuksa::val::v2::FloatArray* float_array);
  ::kuksa::val::v2::FloatArray* unsafe_arena_release_float_array();

  // .kuksa.val.v2.DoubleArray double_array = 28;
  bool has_double_array() const;
  private:
  bool _internal_has_double_array() const;
  public:
  void clear_double_array();
  const ::kuksa::val::v2::DoubleArray& double_array() const;
  PROTOBUF_NODISCARD ::kuksa::val::v2::DoubleArray* release_double_array();
  ::kuksa::val::v2::DoubleArray* mutable_double_array();
  void set_allocated_double_array(::kuksa::val::v2::DoubleArray* double_array);
  private:
  const ::kuksa::val::v2::DoubleArray& _internal_double_array() const;
  ::kuksa::val::v2::DoubleArray* _internal_mutable_double_array();
  public:
  void unsafe_arena_set_allocated_double_array(
      ::kuksa::val::v2::DoubleArray* double_array);
  ::kuksa::val::v2::DoubleArray* unsafe_arena_release_double_array();

  void clear_typed_value();
  TypedValueCase typed_value_case() const;
  // @@protoc_insertion_point(class_scope:kuksa.val.v2.Value)
 private:
  class _Internal;
  void set_has_string();
  void set_has_bool_();
  void set_has_int32();
  void set_has_int64();
  void set_has_uint32();
  void set_has_uint64();
  void set_has_float_();
  void set_has_double_();
  void set_has_string_array();
  void set_has_bool_array();
  void set_has_int32_array();
  void set_has_int64_array();
  void set_has_uint32_array();
  void set_has_uint64_array();
  void set_has_float_array();
  void set_has_double_array();

  inline bool has_typed_value() const;
  inline void clear_has_typed_value();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union TypedValueUnion {
      constexpr TypedValueUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr string_;
      bool bool__;
      int32_t int32_;
      int64_t int64_;
      uint32_t uint32_;
      uint64_t uint64_;
      float float__;
      double double__;
      ::kuksa::val::v2::StringArray* string_array_;
      ::kuksa::val::v2::BoolArray* bool_array_;
      ::kuksa::val::v2::Int32Array* int32_array_;
      ::kuksa::val::v2::Int64Array* int64_array_;
      ::kuksa::val::v2::Uint32Array* uint32_array_;
      ::kuksa::val::v2::Uint64Array* uint64_array_;
      ::kuksa::val::v2::FloatArray* float_array_;
      ::kuksa::val::v2::DoubleArray* double_array_;
    } typed_value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kuksa_2fval_2fv2_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class SignalID final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kuksa.val.v2.SignalID) */ {
 public:
  inline SignalID() : SignalID(nullptr) {}
  ~SignalID() override;
  explicit PROTOBUF_CONSTEXPR SignalID(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SignalID(const SignalID& from);
  SignalID(SignalID&& from) noexcept
    : SignalID() {
    *this = ::std::move(from);
  }

  inline SignalID& operator=(const SignalID& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignalID& operator=(SignalID&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SignalID& default_instance() {
    return *internal_default_instance();
  }
  enum SignalCase {
    kId = 1,
    kPath = 2,
    SIGNAL_NOT_SET = 0,
  };

  static inline const SignalID* internal_default_instance() {
    return reinterpret_cast<const SignalID*>(
               &_SignalID_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SignalID& a, SignalID& b) {
    a.Swap(&b);
  }
  inline void Swap(SignalID* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignalID* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SignalID* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SignalID>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SignalID& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SignalID& from) {
    SignalID::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignalID* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kuksa.val.v2.SignalID";
  }
  protected:
  explicit SignalID(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kPathFieldNumber = 2,
  };
  // int32 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // string path = 2;
  bool has_path() const;
  private:
  bool _internal_has_path() const;
  public:
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  void clear_signal();
  SignalCase signal_case() const;
  // @@protoc_insertion_point(class_scope:kuksa.val.v2.SignalID)
 private:
  class _Internal;
  void set_has_id();
  void set_has_path();

  inline bool has_signal() const;
  inline void clear_has_signal();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union SignalUnion {
      constexpr SignalUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      int32_t id_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
    } signal_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kuksa_2fval_2fv2_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class Error final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kuksa.val.v2.Error) */ {
 public:
  inline Error() : Error(nullptr) {}
  ~Error() override;
  explicit PROTOBUF_CONSTEXPR Error(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Error(const Error& from);
  Error(Error&& from) noexcept
    : Error() {
    *this = ::std::move(from);
  }

  inline Error& operator=(const Error& from) {
    CopyFrom(from);
    return *this;
  }
  inline Error& operator=(Error&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Error& default_instance() {
    return *internal_default_instance();
  }
  static inline const Error* internal_default_instance() {
    return reinterpret_cast<const Error*>(
               &_Error_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Error& a, Error& b) {
    a.Swap(&b);
  }
  inline void Swap(Error* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Error* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Error* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Error>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Error& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Error& from) {
    Error::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Error* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kuksa.val.v2.Error";
  }
  protected:
  explicit Error(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kCodeFieldNumber = 1,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .kuksa.val.v2.ErrorCode code = 1;
  void clear_code();
  ::kuksa::val::v2::ErrorCode code() const;
  void set_code(::kuksa::val::v2::ErrorCode value);
  private:
  ::kuksa::val::v2::ErrorCode _internal_code() const;
  void _internal_set_code(::kuksa::val::v2::ErrorCode value);
  public:

  // @@protoc_insertion_point(class_scope:kuksa.val.v2.Error)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    int code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kuksa_2fval_2fv2_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class Metadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kuksa.val.v2.Metadata) */ {
 public:
  inline Metadata() : Metadata(nullptr) {}
  ~Metadata() override;
  explicit PROTOBUF_CONSTEXPR Metadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Metadata(const Metadata& from);
  Metadata(Metadata&& from) noexcept
    : Metadata() {
    *this = ::std::move(from);
  }

  inline Metadata& operator=(const Metadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline Metadata& operator=(Metadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Metadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const Metadata* internal_default_instance() {
    return reinterpret_cast<const Metadata*>(
               &_Metadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Metadata& a, Metadata& b) {
    a.Swap(&b);
  }
  inline void Swap(Metadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Metadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Metadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Metadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Metadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Metadata& from) {
    Metadata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Metadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kuksa.val.v2.Metadata";
  }
  protected:
  explicit Metadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDescriptionFieldNumber = 13,
    kCommentFieldNumber = 14,
    kDeprecationFieldNumber = 15,
    kUnitFieldNumber = 16,
    kAllowedValuesFieldNumber = 17,
    kMinFieldNumber = 18,
    kMaxFieldNumber = 19,
    kIdFieldNumber = 10,
    kDataTypeFieldNumber = 11,
    kEntryTypeFieldNumber = 12,
  };
  // string description = 13;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string comment = 14;
  void clear_comment();
  const std::string& comment() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_comment(ArgT0&& arg0, ArgT... args);
  std::string* mutable_comment();
  PROTOBUF_NODISCARD std::string* release_comment();
  void set_allocated_comment(std::string* comment);
  private:
  const std::string& _internal_comment() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comment(const std::string& value);
  std::string* _internal_mutable_comment();
  public:

  // string deprecation = 15;
  void clear_deprecation();
  const std::string& deprecation() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_deprecation(ArgT0&& arg0, ArgT... args);
  std::string* mutable_deprecation();
  PROTOBUF_NODISCARD std::string* release_deprecation();
  void set_allocated_deprecation(std::string* deprecation);
  private:
  const std::string& _internal_deprecation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_deprecation(const std::string& value);
  std::string* _internal_mutable_deprecation();
  public:

  // string unit = 16;
  void clear_unit();
  const std::string& unit() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_unit(ArgT0&& arg0, ArgT... args);
  std::string* mutable_unit();
  PROTOBUF_NODISCARD std::string* release_unit();
  void set_allocated_unit(std::string* unit);
  private:
  const std::string& _internal_unit() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_unit(const std::string& value);
  std::string* _internal_mutable_unit();
  public:

  // .kuksa.val.v2.Value allowed_values = 17;
  bool has_allowed_values() const;
  private:
  bool _internal_has_allowed_values() const;
  public:
  void clear_allowed_values();
  const ::kuksa::val::v2::Value& allowed_values() const;
  PROTOBUF_NODISCARD ::kuksa::val::v2::Value* release_allowed_values();
  ::kuksa::val::v2::Value* mutable_allowed_values();
  void set_allocated_allowed_values(::kuksa::val::v2::Value* allowed_values);
  private:
  const ::kuksa::val::v2::Value& _internal_allowed_values() const;
  ::kuksa::val::v2::Value* _internal_mutable_allowed_values();
  public:
  void unsafe_arena_set_allocated_allowed_values(
      ::kuksa::val::v2::Value* allowed_values);
  ::kuksa::val::v2::Value* unsafe_arena_release_allowed_values();

  // .kuksa.val.v2.Value min = 18;
  bool has_min() const;
  private:
  bool _internal_has_min() const;
  public:
  void clear_min();
  const ::kuksa::val::v2::Value& min() const;
  PROTOBUF_NODISCARD ::kuksa::val::v2::Value* release_min();
  ::kuksa::val::v2::Value* mutable_min();
  void set_allocated_min(::kuksa::val::v2::Value* min);
  private:
  const ::kuksa::val::v2::Value& _internal_min() const;
  ::kuksa::val::v2::Value* _internal_mutable_min();
  public:
  void unsafe_arena_set_allocated_min(
      ::kuksa::val::v2::Value* min);
  ::kuksa::val::v2::Value* unsafe_arena_release_min();

  // .kuksa.val.v2.Value max = 19;
  bool has_max() const;
  private:
  bool _internal_has_max() const;
  public:
  void clear_max();
  const ::kuksa::val::v2::Value& max() const;
  PROTOBUF_NODISCARD ::kuksa::val::v2::Value* release_max();
  ::kuksa::val::v2::Value* mutable_max();
  void set_allocated_max(::kuksa::val::v2::Value* max);
  private:
  const ::kuksa::val::v2::Value& _internal_max() const;
  ::kuksa::val::v2::Value* _internal_mutable_max();
  public:
  void unsafe_arena_set_allocated_max(
      ::kuksa::val::v2::Value* max);
  ::kuksa::val::v2::Value* unsafe_arena_release_max();

  // int32 id = 10;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // .kuksa.val.v2.DataType data_type = 11;
  void clear_data_type();
  ::kuksa::val::v2::DataType data_type() const;
  void set_data_type(::kuksa::val::v2::DataType value);
  private:
  ::kuksa::val::v2::DataType _internal_data_type() const;
  void _internal_set_data_type(::kuksa::val::v2::DataType value);
  public:

  // .kuksa.val.v2.EntryType entry_type = 12;
  void clear_entry_type();
  ::kuksa::val::v2::EntryType entry_type() const;
  void set_entry_type(::kuksa::val::v2::EntryType value);
  private:
  ::kuksa::val::v2::EntryType _internal_entry_type() const;
  void _internal_set_entry_type(::kuksa::val::v2::EntryType value);
  public:

  // @@protoc_insertion_point(class_scope:kuksa.val.v2.Metadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comment_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr deprecation_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr unit_;
    ::kuksa::val::v2::Value* allowed_values_;
    ::kuksa::val::v2::Value* min_;
    ::kuksa::val::v2::Value* max_;
    int32_t id_;
    int data_type_;
    int entry_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kuksa_2fval_2fv2_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class StringArray final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kuksa.val.v2.StringArray) */ {
 public:
  inline StringArray() : StringArray(nullptr) {}
  ~StringArray() override;
  explicit PROTOBUF_CONSTEXPR StringArray(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StringArray(const StringArray& from);
  StringArray(StringArray&& from) noexcept
    : StringArray() {
    *this = ::std::move(from);
  }

  inline StringArray& operator=(const StringArray& from) {
    CopyFrom(from);
    return *this;
  }
  inline StringArray& operator=(StringArray&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StringArray& default_instance() {
    return *internal_default_instance();
  }
  static inline const StringArray* internal_default_instance() {
    return reinterpret_cast<const StringArray*>(
               &_StringArray_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(StringArray& a, StringArray& b) {
    a.Swap(&b);
  }
  inline void Swap(StringArray* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StringArray* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StringArray* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StringArray>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StringArray& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StringArray& from) {
    StringArray::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StringArray* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kuksa.val.v2.StringArray";
  }
  protected:
  explicit StringArray(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated string values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  const std::string& values(int index) const;
  std::string* mutable_values(int index);
  void set_values(int index, const std::string& value);
  void set_values(int index, std::string&& value);
  void set_values(int index, const char* value);
  void set_values(int index, const char* value, size_t size);
  std::string* add_values();
  void add_values(const std::string& value);
  void add_values(std::string&& value);
  void add_values(const char* value);
  void add_values(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_values();
  private:
  const std::string& _internal_values(int index) const;
  std::string* _internal_add_values();
  public:

  // @@protoc_insertion_point(class_scope:kuksa.val.v2.StringArray)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> values_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kuksa_2fval_2fv2_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class BoolArray final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kuksa.val.v2.BoolArray) */ {
 public:
  inline BoolArray() : BoolArray(nullptr) {}
  ~BoolArray() override;
  explicit PROTOBUF_CONSTEXPR BoolArray(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BoolArray(const BoolArray& from);
  BoolArray(BoolArray&& from) noexcept
    : BoolArray() {
    *this = ::std::move(from);
  }

  inline BoolArray& operator=(const BoolArray& from) {
    CopyFrom(from);
    return *this;
  }
  inline BoolArray& operator=(BoolArray&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BoolArray& default_instance() {
    return *internal_default_instance();
  }
  static inline const BoolArray* internal_default_instance() {
    return reinterpret_cast<const BoolArray*>(
               &_BoolArray_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(BoolArray& a, BoolArray& b) {
    a.Swap(&b);
  }
  inline void Swap(BoolArray* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BoolArray* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BoolArray* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BoolArray>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BoolArray& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BoolArray& from) {
    BoolArray::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BoolArray* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kuksa.val.v2.BoolArray";
  }
  protected:
  explicit BoolArray(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated bool values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  private:
  bool _internal_values(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      _internal_values() const;
  void _internal_add_values(bool value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      _internal_mutable_values();
  public:
  bool values(int index) const;
  void set_values(int index, bool value);
  void add_values(bool value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:kuksa.val.v2.BoolArray)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool > values_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kuksa_2fval_2fv2_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class Int32Array final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kuksa.val.v2.Int32Array) */ {
 public:
  inline Int32Array() : Int32Array(nullptr) {}
  ~Int32Array() override;
  explicit PROTOBUF_CONSTEXPR Int32Array(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Int32Array(const Int32Array& from);
  Int32Array(Int32Array&& from) noexcept
    : Int32Array() {
    *this = ::std::move(from);
  }

  inline Int32Array& operator=(const Int32Array& from) {
    CopyFrom(from);
    return *this;
  }
  inline Int32Array& operator=(Int32Array&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Int32Array& default_instance() {
    return *internal_default_instance();
  }
  static inline const Int32Array* internal_default_instance() {
    return reinterpret_cast<const Int32Array*>(
               &_Int32Array_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Int32Array& a, Int32Array& b) {
    a.Swap(&b);
  }
  inline void Swap(Int32Array* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Int32Array* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Int32Array* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Int32Array>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Int32Array& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Int32Array& from) {
    Int32Array::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Int32Array* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kuksa.val.v2.Int32Array";
  }
  protected:
  explicit Int32Array(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated sint32 values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  private:
  int32_t _internal_values(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_values() const;
  void _internal_add_values(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_values();
  public:
  int32_t values(int index) const;
  void set_values(int index, int32_t value);
  void add_values(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:kuksa.val.v2.Int32Array)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > values_;
    mutable std::atomic<int> _values_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kuksa_2fval_2fv2_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class Int64Array final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kuksa.val.v2.Int64Array) */ {
 public:
  inline Int64Array() : Int64Array(nullptr) {}
  ~Int64Array() override;
  explicit PROTOBUF_CONSTEXPR Int64Array(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Int64Array(const Int64Array& from);
  Int64Array(Int64Array&& from) noexcept
    : Int64Array() {
    *this = ::std::move(from);
  }

  inline Int64Array& operator=(const Int64Array& from) {
    CopyFrom(from);
    return *this;
  }
  inline Int64Array& operator=(Int64Array&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Int64Array& default_instance() {
    return *internal_default_instance();
  }
  static inline const Int64Array* internal_default_instance() {
    return reinterpret_cast<const Int64Array*>(
               &_Int64Array_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Int64Array& a, Int64Array& b) {
    a.Swap(&b);
  }
  inline void Swap(Int64Array* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Int64Array* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Int64Array* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Int64Array>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Int64Array& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Int64Array& from) {
    Int64Array::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Int64Array* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kuksa.val.v2.Int64Array";
  }
  protected:
  explicit Int64Array(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated sint64 values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  private:
  int64_t _internal_values(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_values() const;
  void _internal_add_values(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_values();
  public:
  int64_t values(int index) const;
  void set_values(int index, int64_t value);
  void add_values(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:kuksa.val.v2.Int64Array)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > values_;
    mutable std::atomic<int> _values_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kuksa_2fval_2fv2_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class Uint32Array final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kuksa.val.v2.Uint32Array) */ {
 public:
  inline Uint32Array() : Uint32Array(nullptr) {}
  ~Uint32Array() override;
  explicit PROTOBUF_CONSTEXPR Uint32Array(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Uint32Array(const Uint32Array& from);
  Uint32Array(Uint32Array&& from) noexcept
    : Uint32Array() {
    *this = ::std::move(from);
  }

  inline Uint32Array& operator=(const Uint32Array& from) {
    CopyFrom(from);
    return *this;
  }
  inline Uint32Array& operator=(Uint32Array&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Uint32Array& default_instance() {
    return *internal_default_instance();
  }
  static inline const Uint32Array* internal_default_instance() {
    return reinterpret_cast<const Uint32Array*>(
               &_Uint32Array_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Uint32Array& a, Uint32Array& b) {
    a.Swap(&b);
  }
  inline void Swap(Uint32Array* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Uint32Array* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Uint32Array* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Uint32Array>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Uint32Array& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Uint32Array& from) {
    Uint32Array::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Uint32Array* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kuksa.val.v2.Uint32Array";
  }
  protected:
  explicit Uint32Array(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated uint32 values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  private:
  uint32_t _internal_values(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_values() const;
  void _internal_add_values(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_values();
  public:
  uint32_t values(int index) const;
  void set_values(int index, uint32_t value);
  void add_values(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:kuksa.val.v2.Uint32Array)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > values_;
    mutable std::atomic<int> _values_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kuksa_2fval_2fv2_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class Uint64Array final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kuksa.val.v2.Uint64Array) */ {
 public:
  inline Uint64Array() : Uint64Array(nullptr) {}
  ~Uint64Array() override;
  explicit PROTOBUF_CONSTEXPR Uint64Array(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Uint64Array(const Uint64Array& from);
  Uint64Array(Uint64Array&& from) noexcept
    : Uint64Array() {
    *this = ::std::move(from);
  }

  inline Uint64Array& operator=(const Uint64Array& from) {
    CopyFrom(from);
    return *this;
  }
  inline Uint64Array& operator=(Uint64Array&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Uint64Array& default_instance() {
    return *internal_default_instance();
  }
  static inline const Uint64Array* internal_default_instance() {
    return reinterpret_cast<const Uint64Array*>(
               &_Uint64Array_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Uint64Array& a, Uint64Array& b) {
    a.Swap(&b);
  }
  inline void Swap(Uint64Array* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Uint64Array* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Uint64Array* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Uint64Array>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Uint64Array& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Uint64Array& from) {
    Uint64Array::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Uint64Array* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kuksa.val.v2.Uint64Array";
  }
  protected:
  explicit Uint64Array(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated uint64 values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  private:
  uint64_t _internal_values(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_values() const;
  void _internal_add_values(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_values();
  public:
  uint64_t values(int index) const;
  void set_values(int index, uint64_t value);
  void add_values(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:kuksa.val.v2.Uint64Array)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > values_;
    mutable std::atomic<int> _values_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kuksa_2fval_2fv2_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class FloatArray final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kuksa.val.v2.FloatArray) */ {
 public:
  inline FloatArray() : FloatArray(nullptr) {}
  ~FloatArray() override;
  explicit PROTOBUF_CONSTEXPR FloatArray(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FloatArray(const FloatArray& from);
  FloatArray(FloatArray&& from) noexcept
    : FloatArray() {
    *this = ::std::move(from);
  }

  inline FloatArray& operator=(const FloatArray& from) {
    CopyFrom(from);
    return *this;
  }
  inline FloatArray& operator=(FloatArray&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FloatArray& default_instance() {
    return *internal_default_instance();
  }
  static inline const FloatArray* internal_default_instance() {
    return reinterpret_cast<const FloatArray*>(
               &_FloatArray_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(FloatArray& a, FloatArray& b) {
    a.Swap(&b);
  }
  inline void Swap(FloatArray* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FloatArray* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FloatArray* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FloatArray>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FloatArray& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FloatArray& from) {
    FloatArray::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FloatArray* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kuksa.val.v2.FloatArray";
  }
  protected:
  explicit FloatArray(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated float values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  private:
  float _internal_values(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_values() const;
  void _internal_add_values(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_values();
  public:
  float values(int index) const;
  void set_values(int index, float value);
  void add_values(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:kuksa.val.v2.FloatArray)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > values_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kuksa_2fval_2fv2_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class DoubleArray final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kuksa.val.v2.DoubleArray) */ {
 public:
  inline DoubleArray() : DoubleArray(nullptr) {}
  ~DoubleArray() override;
  explicit PROTOBUF_CONSTEXPR DoubleArray(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DoubleArray(const DoubleArray& from);
  DoubleArray(DoubleArray&& from) noexcept
    : DoubleArray() {
    *this = ::std::move(from);
  }

  inline DoubleArray& operator=(const DoubleArray& from) {
    CopyFrom(from);
    return *this;
  }
  inline DoubleArray& operator=(DoubleArray&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DoubleArray& default_instance() {
    return *internal_default_instance();
  }
  static inline const DoubleArray* internal_default_instance() {
    return reinterpret_cast<const DoubleArray*>(
               &_DoubleArray_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(DoubleArray& a, DoubleArray& b) {
    a.Swap(&b);
  }
  inline void Swap(DoubleArray* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DoubleArray* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DoubleArray* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DoubleArray>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DoubleArray& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DoubleArray& from) {
    DoubleArray::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DoubleArray* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kuksa.val.v2.DoubleArray";
  }
  protected:
  explicit DoubleArray(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated double values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  private:
  double _internal_values(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_values() const;
  void _internal_add_values(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_values();
  public:
  double values(int index) const;
  void set_values(int index, double value);
  void add_values(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:kuksa.val.v2.DoubleArray)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > values_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_kuksa_2fval_2fv2_2ftypes_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Datapoint

// .google.protobuf.Timestamp timestamp = 1;
inline bool Datapoint::_internal_has_timestamp() const {
  return this != internal_default_instance() && _impl_.timestamp_ != nullptr;
}
inline bool Datapoint::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Datapoint::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Datapoint::timestamp() const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.Datapoint.timestamp)
  return _internal_timestamp();
}
inline void Datapoint::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kuksa.val.v2.Datapoint.timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Datapoint::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Datapoint::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:kuksa.val.v2.Datapoint.timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Datapoint::_internal_mutable_timestamp() {
  
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.timestamp_ = p;
  }
  return _impl_.timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Datapoint::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:kuksa.val.v2.Datapoint.timestamp)
  return _msg;
}
inline void Datapoint::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:kuksa.val.v2.Datapoint.timestamp)
}

// .kuksa.val.v2.Value value = 2;
inline bool Datapoint::_internal_has_value() const {
  return this != internal_default_instance() && _impl_.value_ != nullptr;
}
inline bool Datapoint::has_value() const {
  return _internal_has_value();
}
inline void Datapoint::clear_value() {
  if (GetArenaForAllocation() == nullptr && _impl_.value_ != nullptr) {
    delete _impl_.value_;
  }
  _impl_.value_ = nullptr;
}
inline const ::kuksa::val::v2::Value& Datapoint::_internal_value() const {
  const ::kuksa::val::v2::Value* p = _impl_.value_;
  return p != nullptr ? *p : reinterpret_cast<const ::kuksa::val::v2::Value&>(
      ::kuksa::val::v2::_Value_default_instance_);
}
inline const ::kuksa::val::v2::Value& Datapoint::value() const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.Datapoint.value)
  return _internal_value();
}
inline void Datapoint::unsafe_arena_set_allocated_value(
    ::kuksa::val::v2::Value* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.value_);
  }
  _impl_.value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kuksa.val.v2.Datapoint.value)
}
inline ::kuksa::val::v2::Value* Datapoint::release_value() {
  
  ::kuksa::val::v2::Value* temp = _impl_.value_;
  _impl_.value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kuksa::val::v2::Value* Datapoint::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:kuksa.val.v2.Datapoint.value)
  
  ::kuksa::val::v2::Value* temp = _impl_.value_;
  _impl_.value_ = nullptr;
  return temp;
}
inline ::kuksa::val::v2::Value* Datapoint::_internal_mutable_value() {
  
  if (_impl_.value_ == nullptr) {
    auto* p = CreateMaybeMessage<::kuksa::val::v2::Value>(GetArenaForAllocation());
    _impl_.value_ = p;
  }
  return _impl_.value_;
}
inline ::kuksa::val::v2::Value* Datapoint::mutable_value() {
  ::kuksa::val::v2::Value* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:kuksa.val.v2.Datapoint.value)
  return _msg;
}
inline void Datapoint::set_allocated_value(::kuksa::val::v2::Value* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.value_;
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(value);
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.value_ = value;
  // @@protoc_insertion_point(field_set_allocated:kuksa.val.v2.Datapoint.value)
}

// -------------------------------------------------------------------

// Value

// string string = 11;
inline bool Value::_internal_has_string() const {
  return typed_value_case() == kString;
}
inline bool Value::has_string() const {
  return _internal_has_string();
}
inline void Value::set_has_string() {
  _impl_._oneof_case_[0] = kString;
}
inline void Value::clear_string() {
  if (_internal_has_string()) {
    _impl_.typed_value_.string_.Destroy();
    clear_has_typed_value();
  }
}
inline const std::string& Value::string() const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.Value.string)
  return _internal_string();
}
template <typename ArgT0, typename... ArgT>
inline void Value::set_string(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_string()) {
    clear_typed_value();
    set_has_string();
    _impl_.typed_value_.string_.InitDefault();
  }
  _impl_.typed_value_.string_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kuksa.val.v2.Value.string)
}
inline std::string* Value::mutable_string() {
  std::string* _s = _internal_mutable_string();
  // @@protoc_insertion_point(field_mutable:kuksa.val.v2.Value.string)
  return _s;
}
inline const std::string& Value::_internal_string() const {
  if (_internal_has_string()) {
    return _impl_.typed_value_.string_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Value::_internal_set_string(const std::string& value) {
  if (!_internal_has_string()) {
    clear_typed_value();
    set_has_string();
    _impl_.typed_value_.string_.InitDefault();
  }
  _impl_.typed_value_.string_.Set(value, GetArenaForAllocation());
}
inline std::string* Value::_internal_mutable_string() {
  if (!_internal_has_string()) {
    clear_typed_value();
    set_has_string();
    _impl_.typed_value_.string_.InitDefault();
  }
  return _impl_.typed_value_.string_.Mutable(      GetArenaForAllocation());
}
inline std::string* Value::release_string() {
  // @@protoc_insertion_point(field_release:kuksa.val.v2.Value.string)
  if (_internal_has_string()) {
    clear_has_typed_value();
    return _impl_.typed_value_.string_.Release();
  } else {
    return nullptr;
  }
}
inline void Value::set_allocated_string(std::string* string) {
  if (has_typed_value()) {
    clear_typed_value();
  }
  if (string != nullptr) {
    set_has_string();
    _impl_.typed_value_.string_.InitAllocated(string, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:kuksa.val.v2.Value.string)
}

// bool bool = 12;
inline bool Value::_internal_has_bool_() const {
  return typed_value_case() == kBool;
}
inline bool Value::has_bool_() const {
  return _internal_has_bool_();
}
inline void Value::set_has_bool_() {
  _impl_._oneof_case_[0] = kBool;
}
inline void Value::clear_bool_() {
  if (_internal_has_bool_()) {
    _impl_.typed_value_.bool__ = false;
    clear_has_typed_value();
  }
}
inline bool Value::_internal_bool_() const {
  if (_internal_has_bool_()) {
    return _impl_.typed_value_.bool__;
  }
  return false;
}
inline void Value::_internal_set_bool_(bool value) {
  if (!_internal_has_bool_()) {
    clear_typed_value();
    set_has_bool_();
  }
  _impl_.typed_value_.bool__ = value;
}
inline bool Value::bool_() const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.Value.bool)
  return _internal_bool_();
}
inline void Value::set_bool_(bool value) {
  _internal_set_bool_(value);
  // @@protoc_insertion_point(field_set:kuksa.val.v2.Value.bool)
}

// sint32 int32 = 13;
inline bool Value::_internal_has_int32() const {
  return typed_value_case() == kInt32;
}
inline bool Value::has_int32() const {
  return _internal_has_int32();
}
inline void Value::set_has_int32() {
  _impl_._oneof_case_[0] = kInt32;
}
inline void Value::clear_int32() {
  if (_internal_has_int32()) {
    _impl_.typed_value_.int32_ = 0;
    clear_has_typed_value();
  }
}
inline int32_t Value::_internal_int32() const {
  if (_internal_has_int32()) {
    return _impl_.typed_value_.int32_;
  }
  return 0;
}
inline void Value::_internal_set_int32(int32_t value) {
  if (!_internal_has_int32()) {
    clear_typed_value();
    set_has_int32();
  }
  _impl_.typed_value_.int32_ = value;
}
inline int32_t Value::int32() const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.Value.int32)
  return _internal_int32();
}
inline void Value::set_int32(int32_t value) {
  _internal_set_int32(value);
  // @@protoc_insertion_point(field_set:kuksa.val.v2.Value.int32)
}

// sint64 int64 = 14;
inline bool Value::_internal_has_int64() const {
  return typed_value_case() == kInt64;
}
inline bool Value::has_int64() const {
  return _internal_has_int64();
}
inline void Value::set_has_int64() {
  _impl_._oneof_case_[0] = kInt64;
}
inline void Value::clear_int64() {
  if (_internal_has_int64()) {
    _impl_.typed_value_.int64_ = int64_t{0};
    clear_has_typed_value();
  }
}
inline int64_t Value::_internal_int64() const {
  if (_internal_has_int64()) {
    return _impl_.typed_value_.int64_;
  }
  return int64_t{0};
}
inline void Value::_internal_set_int64(int64_t value) {
  if (!_internal_has_int64()) {
    clear_typed_value();
    set_has_int64();
  }
  _impl_.typed_value_.int64_ = value;
}
inline int64_t Value::int64() const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.Value.int64)
  return _internal_int64();
}
inline void Value::set_int64(int64_t value) {
  _internal_set_int64(value);
  // @@protoc_insertion_point(field_set:kuksa.val.v2.Value.int64)
}

// uint32 uint32 = 15;
inline bool Value::_internal_has_uint32() const {
  return typed_value_case() == kUint32;
}
inline bool Value::has_uint32() const {
  return _internal_has_uint32();
}
inline void Value::set_has_uint32() {
  _impl_._oneof_case_[0] = kUint32;
}
inline void Value::clear_uint32() {
  if (_internal_has_uint32()) {
    _impl_.typed_value_.uint32_ = 0u;
    clear_has_typed_value();
  }
}
inline uint32_t Value::_internal_uint32() const {
  if (_internal_has_uint32()) {
    return _impl_.typed_value_.uint32_;
  }
  return 0u;
}
inline void Value::_internal_set_uint32(uint32_t value) {
  if (!_internal_has_uint32()) {
    clear_typed_value();
    set_has_uint32();
  }
  _impl_.typed_value_.uint32_ = value;
}
inline uint32_t Value::uint32() const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.Value.uint32)
  return _internal_uint32();
}
inline void Value::set_uint32(uint32_t value) {
  _internal_set_uint32(value);
  // @@protoc_insertion_point(field_set:kuksa.val.v2.Value.uint32)
}

// uint64 uint64 = 16;
inline bool Value::_internal_has_uint64() const {
  return typed_value_case() == kUint64;
}
inline bool Value::has_uint64() const {
  return _internal_has_uint64();
}
inline void Value::set_has_uint64() {
  _impl_._oneof_case_[0] = kUint64;
}
inline void Value::clear_uint64() {
  if (_internal_has_uint64()) {
    _impl_.typed_value_.uint64_ = uint64_t{0u};
    clear_has_typed_value();
  }
}
inline uint64_t Value::_internal_uint64() const {
  if (_internal_has_uint64()) {
    return _impl_.typed_value_.uint64_;
  }
  return uint64_t{0u};
}
inline void Value::_internal_set_uint64(uint64_t value) {
  if (!_internal_has_uint64()) {
    clear_typed_value();
    set_has_uint64();
  }
  _impl_.typed_value_.uint64_ = value;
}
inline uint64_t Value::uint64() const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.Value.uint64)
  return _internal_uint64();
}
inline void Value::set_uint64(uint64_t value) {
  _internal_set_uint64(value);
  // @@protoc_insertion_point(field_set:kuksa.val.v2.Value.uint64)
}

// float float = 17;
inline bool Value::_internal_has_float_() const {
  return typed_value_case() == kFloat;
}
inline bool Value::has_float_() const {
  return _internal_has_float_();
}
inline void Value::set_has_float_() {
  _impl_._oneof_case_[0] = kFloat;
}
inline void Value::clear_float_() {
  if (_internal_has_float_()) {
    _impl_.typed_value_.float__ = 0;
    clear_has_typed_value();
  }
}
inline float Value::_internal_float_() const {
  if (_internal_has_float_()) {
    return _impl_.typed_value_.float__;
  }
  return 0;
}
inline void Value::_internal_set_float_(float value) {
  if (!_internal_has_float_()) {
    clear_typed_value();
    set_has_float_();
  }
  _impl_.typed_value_.float__ = value;
}
inline float Value::float_() const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.Value.float)
  return _internal_float_();
}
inline void Value::set_float_(float value) {
  _internal_set_float_(value);
  // @@protoc_insertion_point(field_set:kuksa.val.v2.Value.float)
}

// double double = 18;
inline bool Value::_internal_has_double_() const {
  return typed_value_case() == kDouble;
}
inline bool Value::has_double_() const {
  return _internal_has_double_();
}
inline void Value::set_has_double_() {
  _impl_._oneof_case_[0] = kDouble;
}
inline void Value::clear_double_() {
  if (_internal_has_double_()) {
    _impl_.typed_value_.double__ = 0;
    clear_has_typed_value();
  }
}
inline double Value::_internal_double_() const {
  if (_internal_has_double_()) {
    return _impl_.typed_value_.double__;
  }
  return 0;
}
inline void Value::_internal_set_double_(double value) {
  if (!_internal_has_double_()) {
    clear_typed_value();
    set_has_double_();
  }
  _impl_.typed_value_.double__ = value;
}
inline double Value::double_() const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.Value.double)
  return _internal_double_();
}
inline void Value::set_double_(double value) {
  _internal_set_double_(value);
  // @@protoc_insertion_point(field_set:kuksa.val.v2.Value.double)
}

// .kuksa.val.v2.StringArray string_array = 21;
inline bool Value::_internal_has_string_array() const {
  return typed_value_case() == kStringArray;
}
inline bool Value::has_string_array() const {
  return _internal_has_string_array();
}
inline void Value::set_has_string_array() {
  _impl_._oneof_case_[0] = kStringArray;
}
inline void Value::clear_string_array() {
  if (_internal_has_string_array()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.typed_value_.string_array_;
    }
    clear_has_typed_value();
  }
}
inline ::kuksa::val::v2::StringArray* Value::release_string_array() {
  // @@protoc_insertion_point(field_release:kuksa.val.v2.Value.string_array)
  if (_internal_has_string_array()) {
    clear_has_typed_value();
    ::kuksa::val::v2::StringArray* temp = _impl_.typed_value_.string_array_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.typed_value_.string_array_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kuksa::val::v2::StringArray& Value::_internal_string_array() const {
  return _internal_has_string_array()
      ? *_impl_.typed_value_.string_array_
      : reinterpret_cast< ::kuksa::val::v2::StringArray&>(::kuksa::val::v2::_StringArray_default_instance_);
}
inline const ::kuksa::val::v2::StringArray& Value::string_array() const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.Value.string_array)
  return _internal_string_array();
}
inline ::kuksa::val::v2::StringArray* Value::unsafe_arena_release_string_array() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kuksa.val.v2.Value.string_array)
  if (_internal_has_string_array()) {
    clear_has_typed_value();
    ::kuksa::val::v2::StringArray* temp = _impl_.typed_value_.string_array_;
    _impl_.typed_value_.string_array_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Value::unsafe_arena_set_allocated_string_array(::kuksa::val::v2::StringArray* string_array) {
  clear_typed_value();
  if (string_array) {
    set_has_string_array();
    _impl_.typed_value_.string_array_ = string_array;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kuksa.val.v2.Value.string_array)
}
inline ::kuksa::val::v2::StringArray* Value::_internal_mutable_string_array() {
  if (!_internal_has_string_array()) {
    clear_typed_value();
    set_has_string_array();
    _impl_.typed_value_.string_array_ = CreateMaybeMessage< ::kuksa::val::v2::StringArray >(GetArenaForAllocation());
  }
  return _impl_.typed_value_.string_array_;
}
inline ::kuksa::val::v2::StringArray* Value::mutable_string_array() {
  ::kuksa::val::v2::StringArray* _msg = _internal_mutable_string_array();
  // @@protoc_insertion_point(field_mutable:kuksa.val.v2.Value.string_array)
  return _msg;
}

// .kuksa.val.v2.BoolArray bool_array = 22;
inline bool Value::_internal_has_bool_array() const {
  return typed_value_case() == kBoolArray;
}
inline bool Value::has_bool_array() const {
  return _internal_has_bool_array();
}
inline void Value::set_has_bool_array() {
  _impl_._oneof_case_[0] = kBoolArray;
}
inline void Value::clear_bool_array() {
  if (_internal_has_bool_array()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.typed_value_.bool_array_;
    }
    clear_has_typed_value();
  }
}
inline ::kuksa::val::v2::BoolArray* Value::release_bool_array() {
  // @@protoc_insertion_point(field_release:kuksa.val.v2.Value.bool_array)
  if (_internal_has_bool_array()) {
    clear_has_typed_value();
    ::kuksa::val::v2::BoolArray* temp = _impl_.typed_value_.bool_array_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.typed_value_.bool_array_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kuksa::val::v2::BoolArray& Value::_internal_bool_array() const {
  return _internal_has_bool_array()
      ? *_impl_.typed_value_.bool_array_
      : reinterpret_cast< ::kuksa::val::v2::BoolArray&>(::kuksa::val::v2::_BoolArray_default_instance_);
}
inline const ::kuksa::val::v2::BoolArray& Value::bool_array() const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.Value.bool_array)
  return _internal_bool_array();
}
inline ::kuksa::val::v2::BoolArray* Value::unsafe_arena_release_bool_array() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kuksa.val.v2.Value.bool_array)
  if (_internal_has_bool_array()) {
    clear_has_typed_value();
    ::kuksa::val::v2::BoolArray* temp = _impl_.typed_value_.bool_array_;
    _impl_.typed_value_.bool_array_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Value::unsafe_arena_set_allocated_bool_array(::kuksa::val::v2::BoolArray* bool_array) {
  clear_typed_value();
  if (bool_array) {
    set_has_bool_array();
    _impl_.typed_value_.bool_array_ = bool_array;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kuksa.val.v2.Value.bool_array)
}
inline ::kuksa::val::v2::BoolArray* Value::_internal_mutable_bool_array() {
  if (!_internal_has_bool_array()) {
    clear_typed_value();
    set_has_bool_array();
    _impl_.typed_value_.bool_array_ = CreateMaybeMessage< ::kuksa::val::v2::BoolArray >(GetArenaForAllocation());
  }
  return _impl_.typed_value_.bool_array_;
}
inline ::kuksa::val::v2::BoolArray* Value::mutable_bool_array() {
  ::kuksa::val::v2::BoolArray* _msg = _internal_mutable_bool_array();
  // @@protoc_insertion_point(field_mutable:kuksa.val.v2.Value.bool_array)
  return _msg;
}

// .kuksa.val.v2.Int32Array int32_array = 23;
inline bool Value::_internal_has_int32_array() const {
  return typed_value_case() == kInt32Array;
}
inline bool Value::has_int32_array() const {
  return _internal_has_int32_array();
}
inline void Value::set_has_int32_array() {
  _impl_._oneof_case_[0] = kInt32Array;
}
inline void Value::clear_int32_array() {
  if (_internal_has_int32_array()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.typed_value_.int32_array_;
    }
    clear_has_typed_value();
  }
}
inline ::kuksa::val::v2::Int32Array* Value::release_int32_array() {
  // @@protoc_insertion_point(field_release:kuksa.val.v2.Value.int32_array)
  if (_internal_has_int32_array()) {
    clear_has_typed_value();
    ::kuksa::val::v2::Int32Array* temp = _impl_.typed_value_.int32_array_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.typed_value_.int32_array_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kuksa::val::v2::Int32Array& Value::_internal_int32_array() const {
  return _internal_has_int32_array()
      ? *_impl_.typed_value_.int32_array_
      : reinterpret_cast< ::kuksa::val::v2::Int32Array&>(::kuksa::val::v2::_Int32Array_default_instance_);
}
inline const ::kuksa::val::v2::Int32Array& Value::int32_array() const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.Value.int32_array)
  return _internal_int32_array();
}
inline ::kuksa::val::v2::Int32Array* Value::unsafe_arena_release_int32_array() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kuksa.val.v2.Value.int32_array)
  if (_internal_has_int32_array()) {
    clear_has_typed_value();
    ::kuksa::val::v2::Int32Array* temp = _impl_.typed_value_.int32_array_;
    _impl_.typed_value_.int32_array_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Value::unsafe_arena_set_allocated_int32_array(::kuksa::val::v2::Int32Array* int32_array) {
  clear_typed_value();
  if (int32_array) {
    set_has_int32_array();
    _impl_.typed_value_.int32_array_ = int32_array;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kuksa.val.v2.Value.int32_array)
}
inline ::kuksa::val::v2::Int32Array* Value::_internal_mutable_int32_array() {
  if (!_internal_has_int32_array()) {
    clear_typed_value();
    set_has_int32_array();
    _impl_.typed_value_.int32_array_ = CreateMaybeMessage< ::kuksa::val::v2::Int32Array >(GetArenaForAllocation());
  }
  return _impl_.typed_value_.int32_array_;
}
inline ::kuksa::val::v2::Int32Array* Value::mutable_int32_array() {
  ::kuksa::val::v2::Int32Array* _msg = _internal_mutable_int32_array();
  // @@protoc_insertion_point(field_mutable:kuksa.val.v2.Value.int32_array)
  return _msg;
}

// .kuksa.val.v2.Int64Array int64_array = 24;
inline bool Value::_internal_has_int64_array() const {
  return typed_value_case() == kInt64Array;
}
inline bool Value::has_int64_array() const {
  return _internal_has_int64_array();
}
inline void Value::set_has_int64_array() {
  _impl_._oneof_case_[0] = kInt64Array;
}
inline void Value::clear_int64_array() {
  if (_internal_has_int64_array()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.typed_value_.int64_array_;
    }
    clear_has_typed_value();
  }
}
inline ::kuksa::val::v2::Int64Array* Value::release_int64_array() {
  // @@protoc_insertion_point(field_release:kuksa.val.v2.Value.int64_array)
  if (_internal_has_int64_array()) {
    clear_has_typed_value();
    ::kuksa::val::v2::Int64Array* temp = _impl_.typed_value_.int64_array_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.typed_value_.int64_array_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kuksa::val::v2::Int64Array& Value::_internal_int64_array() const {
  return _internal_has_int64_array()
      ? *_impl_.typed_value_.int64_array_
      : reinterpret_cast< ::kuksa::val::v2::Int64Array&>(::kuksa::val::v2::_Int64Array_default_instance_);
}
inline const ::kuksa::val::v2::Int64Array& Value::int64_array() const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.Value.int64_array)
  return _internal_int64_array();
}
inline ::kuksa::val::v2::Int64Array* Value::unsafe_arena_release_int64_array() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kuksa.val.v2.Value.int64_array)
  if (_internal_has_int64_array()) {
    clear_has_typed_value();
    ::kuksa::val::v2::Int64Array* temp = _impl_.typed_value_.int64_array_;
    _impl_.typed_value_.int64_array_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Value::unsafe_arena_set_allocated_int64_array(::kuksa::val::v2::Int64Array* int64_array) {
  clear_typed_value();
  if (int64_array) {
    set_has_int64_array();
    _impl_.typed_value_.int64_array_ = int64_array;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kuksa.val.v2.Value.int64_array)
}
inline ::kuksa::val::v2::Int64Array* Value::_internal_mutable_int64_array() {
  if (!_internal_has_int64_array()) {
    clear_typed_value();
    set_has_int64_array();
    _impl_.typed_value_.int64_array_ = CreateMaybeMessage< ::kuksa::val::v2::Int64Array >(GetArenaForAllocation());
  }
  return _impl_.typed_value_.int64_array_;
}
inline ::kuksa::val::v2::Int64Array* Value::mutable_int64_array() {
  ::kuksa::val::v2::Int64Array* _msg = _internal_mutable_int64_array();
  // @@protoc_insertion_point(field_mutable:kuksa.val.v2.Value.int64_array)
  return _msg;
}

// .kuksa.val.v2.Uint32Array uint32_array = 25;
inline bool Value::_internal_has_uint32_array() const {
  return typed_value_case() == kUint32Array;
}
inline bool Value::has_uint32_array() const {
  return _internal_has_uint32_array();
}
inline void Value::set_has_uint32_array() {
  _impl_._oneof_case_[0] = kUint32Array;
}
inline void Value::clear_uint32_array() {
  if (_internal_has_uint32_array()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.typed_value_.uint32_array_;
    }
    clear_has_typed_value();
  }
}
inline ::kuksa::val::v2::Uint32Array* Value::release_uint32_array() {
  // @@protoc_insertion_point(field_release:kuksa.val.v2.Value.uint32_array)
  if (_internal_has_uint32_array()) {
    clear_has_typed_value();
    ::kuksa::val::v2::Uint32Array* temp = _impl_.typed_value_.uint32_array_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.typed_value_.uint32_array_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kuksa::val::v2::Uint32Array& Value::_internal_uint32_array() const {
  return _internal_has_uint32_array()
      ? *_impl_.typed_value_.uint32_array_
      : reinterpret_cast< ::kuksa::val::v2::Uint32Array&>(::kuksa::val::v2::_Uint32Array_default_instance_);
}
inline const ::kuksa::val::v2::Uint32Array& Value::uint32_array() const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.Value.uint32_array)
  return _internal_uint32_array();
}
inline ::kuksa::val::v2::Uint32Array* Value::unsafe_arena_release_uint32_array() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kuksa.val.v2.Value.uint32_array)
  if (_internal_has_uint32_array()) {
    clear_has_typed_value();
    ::kuksa::val::v2::Uint32Array* temp = _impl_.typed_value_.uint32_array_;
    _impl_.typed_value_.uint32_array_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Value::unsafe_arena_set_allocated_uint32_array(::kuksa::val::v2::Uint32Array* uint32_array) {
  clear_typed_value();
  if (uint32_array) {
    set_has_uint32_array();
    _impl_.typed_value_.uint32_array_ = uint32_array;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kuksa.val.v2.Value.uint32_array)
}
inline ::kuksa::val::v2::Uint32Array* Value::_internal_mutable_uint32_array() {
  if (!_internal_has_uint32_array()) {
    clear_typed_value();
    set_has_uint32_array();
    _impl_.typed_value_.uint32_array_ = CreateMaybeMessage< ::kuksa::val::v2::Uint32Array >(GetArenaForAllocation());
  }
  return _impl_.typed_value_.uint32_array_;
}
inline ::kuksa::val::v2::Uint32Array* Value::mutable_uint32_array() {
  ::kuksa::val::v2::Uint32Array* _msg = _internal_mutable_uint32_array();
  // @@protoc_insertion_point(field_mutable:kuksa.val.v2.Value.uint32_array)
  return _msg;
}

// .kuksa.val.v2.Uint64Array uint64_array = 26;
inline bool Value::_internal_has_uint64_array() const {
  return typed_value_case() == kUint64Array;
}
inline bool Value::has_uint64_array() const {
  return _internal_has_uint64_array();
}
inline void Value::set_has_uint64_array() {
  _impl_._oneof_case_[0] = kUint64Array;
}
inline void Value::clear_uint64_array() {
  if (_internal_has_uint64_array()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.typed_value_.uint64_array_;
    }
    clear_has_typed_value();
  }
}
inline ::kuksa::val::v2::Uint64Array* Value::release_uint64_array() {
  // @@protoc_insertion_point(field_release:kuksa.val.v2.Value.uint64_array)
  if (_internal_has_uint64_array()) {
    clear_has_typed_value();
    ::kuksa::val::v2::Uint64Array* temp = _impl_.typed_value_.uint64_array_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.typed_value_.uint64_array_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kuksa::val::v2::Uint64Array& Value::_internal_uint64_array() const {
  return _internal_has_uint64_array()
      ? *_impl_.typed_value_.uint64_array_
      : reinterpret_cast< ::kuksa::val::v2::Uint64Array&>(::kuksa::val::v2::_Uint64Array_default_instance_);
}
inline const ::kuksa::val::v2::Uint64Array& Value::uint64_array() const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.Value.uint64_array)
  return _internal_uint64_array();
}
inline ::kuksa::val::v2::Uint64Array* Value::unsafe_arena_release_uint64_array() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kuksa.val.v2.Value.uint64_array)
  if (_internal_has_uint64_array()) {
    clear_has_typed_value();
    ::kuksa::val::v2::Uint64Array* temp = _impl_.typed_value_.uint64_array_;
    _impl_.typed_value_.uint64_array_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Value::unsafe_arena_set_allocated_uint64_array(::kuksa::val::v2::Uint64Array* uint64_array) {
  clear_typed_value();
  if (uint64_array) {
    set_has_uint64_array();
    _impl_.typed_value_.uint64_array_ = uint64_array;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kuksa.val.v2.Value.uint64_array)
}
inline ::kuksa::val::v2::Uint64Array* Value::_internal_mutable_uint64_array() {
  if (!_internal_has_uint64_array()) {
    clear_typed_value();
    set_has_uint64_array();
    _impl_.typed_value_.uint64_array_ = CreateMaybeMessage< ::kuksa::val::v2::Uint64Array >(GetArenaForAllocation());
  }
  return _impl_.typed_value_.uint64_array_;
}
inline ::kuksa::val::v2::Uint64Array* Value::mutable_uint64_array() {
  ::kuksa::val::v2::Uint64Array* _msg = _internal_mutable_uint64_array();
  // @@protoc_insertion_point(field_mutable:kuksa.val.v2.Value.uint64_array)
  return _msg;
}

// .kuksa.val.v2.FloatArray float_array = 27;
inline bool Value::_internal_has_float_array() const {
  return typed_value_case() == kFloatArray;
}
inline bool Value::has_float_array() const {
  return _internal_has_float_array();
}
inline void Value::set_has_float_array() {
  _impl_._oneof_case_[0] = kFloatArray;
}
inline void Value::clear_float_array() {
  if (_internal_has_float_array()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.typed_value_.float_array_;
    }
    clear_has_typed_value();
  }
}
inline ::kuksa::val::v2::FloatArray* Value::release_float_array() {
  // @@protoc_insertion_point(field_release:kuksa.val.v2.Value.float_array)
  if (_internal_has_float_array()) {
    clear_has_typed_value();
    ::kuksa::val::v2::FloatArray* temp = _impl_.typed_value_.float_array_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.typed_value_.float_array_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kuksa::val::v2::FloatArray& Value::_internal_float_array() const {
  return _internal_has_float_array()
      ? *_impl_.typed_value_.float_array_
      : reinterpret_cast< ::kuksa::val::v2::FloatArray&>(::kuksa::val::v2::_FloatArray_default_instance_);
}
inline const ::kuksa::val::v2::FloatArray& Value::float_array() const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.Value.float_array)
  return _internal_float_array();
}
inline ::kuksa::val::v2::FloatArray* Value::unsafe_arena_release_float_array() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kuksa.val.v2.Value.float_array)
  if (_internal_has_float_array()) {
    clear_has_typed_value();
    ::kuksa::val::v2::FloatArray* temp = _impl_.typed_value_.float_array_;
    _impl_.typed_value_.float_array_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Value::unsafe_arena_set_allocated_float_array(::kuksa::val::v2::FloatArray* float_array) {
  clear_typed_value();
  if (float_array) {
    set_has_float_array();
    _impl_.typed_value_.float_array_ = float_array;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kuksa.val.v2.Value.float_array)
}
inline ::kuksa::val::v2::FloatArray* Value::_internal_mutable_float_array() {
  if (!_internal_has_float_array()) {
    clear_typed_value();
    set_has_float_array();
    _impl_.typed_value_.float_array_ = CreateMaybeMessage< ::kuksa::val::v2::FloatArray >(GetArenaForAllocation());
  }
  return _impl_.typed_value_.float_array_;
}
inline ::kuksa::val::v2::FloatArray* Value::mutable_float_array() {
  ::kuksa::val::v2::FloatArray* _msg = _internal_mutable_float_array();
  // @@protoc_insertion_point(field_mutable:kuksa.val.v2.Value.float_array)
  return _msg;
}

// .kuksa.val.v2.DoubleArray double_array = 28;
inline bool Value::_internal_has_double_array() const {
  return typed_value_case() == kDoubleArray;
}
inline bool Value::has_double_array() const {
  return _internal_has_double_array();
}
inline void Value::set_has_double_array() {
  _impl_._oneof_case_[0] = kDoubleArray;
}
inline void Value::clear_double_array() {
  if (_internal_has_double_array()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.typed_value_.double_array_;
    }
    clear_has_typed_value();
  }
}
inline ::kuksa::val::v2::DoubleArray* Value::release_double_array() {
  // @@protoc_insertion_point(field_release:kuksa.val.v2.Value.double_array)
  if (_internal_has_double_array()) {
    clear_has_typed_value();
    ::kuksa::val::v2::DoubleArray* temp = _impl_.typed_value_.double_array_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.typed_value_.double_array_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::kuksa::val::v2::DoubleArray& Value::_internal_double_array() const {
  return _internal_has_double_array()
      ? *_impl_.typed_value_.double_array_
      : reinterpret_cast< ::kuksa::val::v2::DoubleArray&>(::kuksa::val::v2::_DoubleArray_default_instance_);
}
inline const ::kuksa::val::v2::DoubleArray& Value::double_array() const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.Value.double_array)
  return _internal_double_array();
}
inline ::kuksa::val::v2::DoubleArray* Value::unsafe_arena_release_double_array() {
  // @@protoc_insertion_point(field_unsafe_arena_release:kuksa.val.v2.Value.double_array)
  if (_internal_has_double_array()) {
    clear_has_typed_value();
    ::kuksa::val::v2::DoubleArray* temp = _impl_.typed_value_.double_array_;
    _impl_.typed_value_.double_array_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Value::unsafe_arena_set_allocated_double_array(::kuksa::val::v2::DoubleArray* double_array) {
  clear_typed_value();
  if (double_array) {
    set_has_double_array();
    _impl_.typed_value_.double_array_ = double_array;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kuksa.val.v2.Value.double_array)
}
inline ::kuksa::val::v2::DoubleArray* Value::_internal_mutable_double_array() {
  if (!_internal_has_double_array()) {
    clear_typed_value();
    set_has_double_array();
    _impl_.typed_value_.double_array_ = CreateMaybeMessage< ::kuksa::val::v2::DoubleArray >(GetArenaForAllocation());
  }
  return _impl_.typed_value_.double_array_;
}
inline ::kuksa::val::v2::DoubleArray* Value::mutable_double_array() {
  ::kuksa::val::v2::DoubleArray* _msg = _internal_mutable_double_array();
  // @@protoc_insertion_point(field_mutable:kuksa.val.v2.Value.double_array)
  return _msg;
}

inline bool Value::has_typed_value() const {
  return typed_value_case() != TYPED_VALUE_NOT_SET;
}
inline void Value::clear_has_typed_value() {
  _impl_._oneof_case_[0] = TYPED_VALUE_NOT_SET;
}
inline Value::TypedValueCase Value::typed_value_case() const {
  return Value::TypedValueCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// SignalID

// int32 id = 1;
inline bool SignalID::_internal_has_id() const {
  return signal_case() == kId;
}
inline bool SignalID::has_id() const {
  return _internal_has_id();
}
inline void SignalID::set_has_id() {
  _impl_._oneof_case_[0] = kId;
}
inline void SignalID::clear_id() {
  if (_internal_has_id()) {
    _impl_.signal_.id_ = 0;
    clear_has_signal();
  }
}
inline int32_t SignalID::_internal_id() const {
  if (_internal_has_id()) {
    return _impl_.signal_.id_;
  }
  return 0;
}
inline void SignalID::_internal_set_id(int32_t value) {
  if (!_internal_has_id()) {
    clear_signal();
    set_has_id();
  }
  _impl_.signal_.id_ = value;
}
inline int32_t SignalID::id() const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.SignalID.id)
  return _internal_id();
}
inline void SignalID::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:kuksa.val.v2.SignalID.id)
}

// string path = 2;
inline bool SignalID::_internal_has_path() const {
  return signal_case() == kPath;
}
inline bool SignalID::has_path() const {
  return _internal_has_path();
}
inline void SignalID::set_has_path() {
  _impl_._oneof_case_[0] = kPath;
}
inline void SignalID::clear_path() {
  if (_internal_has_path()) {
    _impl_.signal_.path_.Destroy();
    clear_has_signal();
  }
}
inline const std::string& SignalID::path() const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.SignalID.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline void SignalID::set_path(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_path()) {
    clear_signal();
    set_has_path();
    _impl_.signal_.path_.InitDefault();
  }
  _impl_.signal_.path_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kuksa.val.v2.SignalID.path)
}
inline std::string* SignalID::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:kuksa.val.v2.SignalID.path)
  return _s;
}
inline const std::string& SignalID::_internal_path() const {
  if (_internal_has_path()) {
    return _impl_.signal_.path_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void SignalID::_internal_set_path(const std::string& value) {
  if (!_internal_has_path()) {
    clear_signal();
    set_has_path();
    _impl_.signal_.path_.InitDefault();
  }
  _impl_.signal_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* SignalID::_internal_mutable_path() {
  if (!_internal_has_path()) {
    clear_signal();
    set_has_path();
    _impl_.signal_.path_.InitDefault();
  }
  return _impl_.signal_.path_.Mutable(      GetArenaForAllocation());
}
inline std::string* SignalID::release_path() {
  // @@protoc_insertion_point(field_release:kuksa.val.v2.SignalID.path)
  if (_internal_has_path()) {
    clear_has_signal();
    return _impl_.signal_.path_.Release();
  } else {
    return nullptr;
  }
}
inline void SignalID::set_allocated_path(std::string* path) {
  if (has_signal()) {
    clear_signal();
  }
  if (path != nullptr) {
    set_has_path();
    _impl_.signal_.path_.InitAllocated(path, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:kuksa.val.v2.SignalID.path)
}

inline bool SignalID::has_signal() const {
  return signal_case() != SIGNAL_NOT_SET;
}
inline void SignalID::clear_has_signal() {
  _impl_._oneof_case_[0] = SIGNAL_NOT_SET;
}
inline SignalID::SignalCase SignalID::signal_case() const {
  return SignalID::SignalCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Error

// .kuksa.val.v2.ErrorCode code = 1;
inline void Error::clear_code() {
  _impl_.code_ = 0;
}
inline ::kuksa::val::v2::ErrorCode Error::_internal_code() const {
  return static_cast< ::kuksa::val::v2::ErrorCode >(_impl_.code_);
}
inline ::kuksa::val::v2::ErrorCode Error::code() const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.Error.code)
  return _internal_code();
}
inline void Error::_internal_set_code(::kuksa::val::v2::ErrorCode value) {
  
  _impl_.code_ = value;
}
inline void Error::set_code(::kuksa::val::v2::ErrorCode value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:kuksa.val.v2.Error.code)
}

// string message = 2;
inline void Error::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& Error::message() const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.Error.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Error::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kuksa.val.v2.Error.message)
}
inline std::string* Error::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:kuksa.val.v2.Error.message)
  return _s;
}
inline const std::string& Error::_internal_message() const {
  return _impl_.message_.Get();
}
inline void Error::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* Error::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* Error::release_message() {
  // @@protoc_insertion_point(field_release:kuksa.val.v2.Error.message)
  return _impl_.message_.Release();
}
inline void Error::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kuksa.val.v2.Error.message)
}

// -------------------------------------------------------------------

// Metadata

// int32 id = 10;
inline void Metadata::clear_id() {
  _impl_.id_ = 0;
}
inline int32_t Metadata::_internal_id() const {
  return _impl_.id_;
}
inline int32_t Metadata::id() const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.Metadata.id)
  return _internal_id();
}
inline void Metadata::_internal_set_id(int32_t value) {
  
  _impl_.id_ = value;
}
inline void Metadata::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:kuksa.val.v2.Metadata.id)
}

// .kuksa.val.v2.DataType data_type = 11;
inline void Metadata::clear_data_type() {
  _impl_.data_type_ = 0;
}
inline ::kuksa::val::v2::DataType Metadata::_internal_data_type() const {
  return static_cast< ::kuksa::val::v2::DataType >(_impl_.data_type_);
}
inline ::kuksa::val::v2::DataType Metadata::data_type() const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.Metadata.data_type)
  return _internal_data_type();
}
inline void Metadata::_internal_set_data_type(::kuksa::val::v2::DataType value) {
  
  _impl_.data_type_ = value;
}
inline void Metadata::set_data_type(::kuksa::val::v2::DataType value) {
  _internal_set_data_type(value);
  // @@protoc_insertion_point(field_set:kuksa.val.v2.Metadata.data_type)
}

// .kuksa.val.v2.EntryType entry_type = 12;
inline void Metadata::clear_entry_type() {
  _impl_.entry_type_ = 0;
}
inline ::kuksa::val::v2::EntryType Metadata::_internal_entry_type() const {
  return static_cast< ::kuksa::val::v2::EntryType >(_impl_.entry_type_);
}
inline ::kuksa::val::v2::EntryType Metadata::entry_type() const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.Metadata.entry_type)
  return _internal_entry_type();
}
inline void Metadata::_internal_set_entry_type(::kuksa::val::v2::EntryType value) {
  
  _impl_.entry_type_ = value;
}
inline void Metadata::set_entry_type(::kuksa::val::v2::EntryType value) {
  _internal_set_entry_type(value);
  // @@protoc_insertion_point(field_set:kuksa.val.v2.Metadata.entry_type)
}

// string description = 13;
inline void Metadata::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& Metadata::description() const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.Metadata.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Metadata::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kuksa.val.v2.Metadata.description)
}
inline std::string* Metadata::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:kuksa.val.v2.Metadata.description)
  return _s;
}
inline const std::string& Metadata::_internal_description() const {
  return _impl_.description_.Get();
}
inline void Metadata::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* Metadata::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* Metadata::release_description() {
  // @@protoc_insertion_point(field_release:kuksa.val.v2.Metadata.description)
  return _impl_.description_.Release();
}
inline void Metadata::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kuksa.val.v2.Metadata.description)
}

// string comment = 14;
inline void Metadata::clear_comment() {
  _impl_.comment_.ClearToEmpty();
}
inline const std::string& Metadata::comment() const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.Metadata.comment)
  return _internal_comment();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Metadata::set_comment(ArgT0&& arg0, ArgT... args) {
 
 _impl_.comment_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kuksa.val.v2.Metadata.comment)
}
inline std::string* Metadata::mutable_comment() {
  std::string* _s = _internal_mutable_comment();
  // @@protoc_insertion_point(field_mutable:kuksa.val.v2.Metadata.comment)
  return _s;
}
inline const std::string& Metadata::_internal_comment() const {
  return _impl_.comment_.Get();
}
inline void Metadata::_internal_set_comment(const std::string& value) {
  
  _impl_.comment_.Set(value, GetArenaForAllocation());
}
inline std::string* Metadata::_internal_mutable_comment() {
  
  return _impl_.comment_.Mutable(GetArenaForAllocation());
}
inline std::string* Metadata::release_comment() {
  // @@protoc_insertion_point(field_release:kuksa.val.v2.Metadata.comment)
  return _impl_.comment_.Release();
}
inline void Metadata::set_allocated_comment(std::string* comment) {
  if (comment != nullptr) {
    
  } else {
    
  }
  _impl_.comment_.SetAllocated(comment, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.comment_.IsDefault()) {
    _impl_.comment_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kuksa.val.v2.Metadata.comment)
}

// string deprecation = 15;
inline void Metadata::clear_deprecation() {
  _impl_.deprecation_.ClearToEmpty();
}
inline const std::string& Metadata::deprecation() const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.Metadata.deprecation)
  return _internal_deprecation();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Metadata::set_deprecation(ArgT0&& arg0, ArgT... args) {
 
 _impl_.deprecation_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kuksa.val.v2.Metadata.deprecation)
}
inline std::string* Metadata::mutable_deprecation() {
  std::string* _s = _internal_mutable_deprecation();
  // @@protoc_insertion_point(field_mutable:kuksa.val.v2.Metadata.deprecation)
  return _s;
}
inline const std::string& Metadata::_internal_deprecation() const {
  return _impl_.deprecation_.Get();
}
inline void Metadata::_internal_set_deprecation(const std::string& value) {
  
  _impl_.deprecation_.Set(value, GetArenaForAllocation());
}
inline std::string* Metadata::_internal_mutable_deprecation() {
  
  return _impl_.deprecation_.Mutable(GetArenaForAllocation());
}
inline std::string* Metadata::release_deprecation() {
  // @@protoc_insertion_point(field_release:kuksa.val.v2.Metadata.deprecation)
  return _impl_.deprecation_.Release();
}
inline void Metadata::set_allocated_deprecation(std::string* deprecation) {
  if (deprecation != nullptr) {
    
  } else {
    
  }
  _impl_.deprecation_.SetAllocated(deprecation, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.deprecation_.IsDefault()) {
    _impl_.deprecation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kuksa.val.v2.Metadata.deprecation)
}

// string unit = 16;
inline void Metadata::clear_unit() {
  _impl_.unit_.ClearToEmpty();
}
inline const std::string& Metadata::unit() const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.Metadata.unit)
  return _internal_unit();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Metadata::set_unit(ArgT0&& arg0, ArgT... args) {
 
 _impl_.unit_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kuksa.val.v2.Metadata.unit)
}
inline std::string* Metadata::mutable_unit() {
  std::string* _s = _internal_mutable_unit();
  // @@protoc_insertion_point(field_mutable:kuksa.val.v2.Metadata.unit)
  return _s;
}
inline const std::string& Metadata::_internal_unit() const {
  return _impl_.unit_.Get();
}
inline void Metadata::_internal_set_unit(const std::string& value) {
  
  _impl_.unit_.Set(value, GetArenaForAllocation());
}
inline std::string* Metadata::_internal_mutable_unit() {
  
  return _impl_.unit_.Mutable(GetArenaForAllocation());
}
inline std::string* Metadata::release_unit() {
  // @@protoc_insertion_point(field_release:kuksa.val.v2.Metadata.unit)
  return _impl_.unit_.Release();
}
inline void Metadata::set_allocated_unit(std::string* unit) {
  if (unit != nullptr) {
    
  } else {
    
  }
  _impl_.unit_.SetAllocated(unit, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.unit_.IsDefault()) {
    _impl_.unit_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kuksa.val.v2.Metadata.unit)
}

// .kuksa.val.v2.Value allowed_values = 17;
inline bool Metadata::_internal_has_allowed_values() const {
  return this != internal_default_instance() && _impl_.allowed_values_ != nullptr;
}
inline bool Metadata::has_allowed_values() const {
  return _internal_has_allowed_values();
}
inline void Metadata::clear_allowed_values() {
  if (GetArenaForAllocation() == nullptr && _impl_.allowed_values_ != nullptr) {
    delete _impl_.allowed_values_;
  }
  _impl_.allowed_values_ = nullptr;
}
inline const ::kuksa::val::v2::Value& Metadata::_internal_allowed_values() const {
  const ::kuksa::val::v2::Value* p = _impl_.allowed_values_;
  return p != nullptr ? *p : reinterpret_cast<const ::kuksa::val::v2::Value&>(
      ::kuksa::val::v2::_Value_default_instance_);
}
inline const ::kuksa::val::v2::Value& Metadata::allowed_values() const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.Metadata.allowed_values)
  return _internal_allowed_values();
}
inline void Metadata::unsafe_arena_set_allocated_allowed_values(
    ::kuksa::val::v2::Value* allowed_values) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.allowed_values_);
  }
  _impl_.allowed_values_ = allowed_values;
  if (allowed_values) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kuksa.val.v2.Metadata.allowed_values)
}
inline ::kuksa::val::v2::Value* Metadata::release_allowed_values() {
  
  ::kuksa::val::v2::Value* temp = _impl_.allowed_values_;
  _impl_.allowed_values_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kuksa::val::v2::Value* Metadata::unsafe_arena_release_allowed_values() {
  // @@protoc_insertion_point(field_release:kuksa.val.v2.Metadata.allowed_values)
  
  ::kuksa::val::v2::Value* temp = _impl_.allowed_values_;
  _impl_.allowed_values_ = nullptr;
  return temp;
}
inline ::kuksa::val::v2::Value* Metadata::_internal_mutable_allowed_values() {
  
  if (_impl_.allowed_values_ == nullptr) {
    auto* p = CreateMaybeMessage<::kuksa::val::v2::Value>(GetArenaForAllocation());
    _impl_.allowed_values_ = p;
  }
  return _impl_.allowed_values_;
}
inline ::kuksa::val::v2::Value* Metadata::mutable_allowed_values() {
  ::kuksa::val::v2::Value* _msg = _internal_mutable_allowed_values();
  // @@protoc_insertion_point(field_mutable:kuksa.val.v2.Metadata.allowed_values)
  return _msg;
}
inline void Metadata::set_allocated_allowed_values(::kuksa::val::v2::Value* allowed_values) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.allowed_values_;
  }
  if (allowed_values) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(allowed_values);
    if (message_arena != submessage_arena) {
      allowed_values = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, allowed_values, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.allowed_values_ = allowed_values;
  // @@protoc_insertion_point(field_set_allocated:kuksa.val.v2.Metadata.allowed_values)
}

// .kuksa.val.v2.Value min = 18;
inline bool Metadata::_internal_has_min() const {
  return this != internal_default_instance() && _impl_.min_ != nullptr;
}
inline bool Metadata::has_min() const {
  return _internal_has_min();
}
inline void Metadata::clear_min() {
  if (GetArenaForAllocation() == nullptr && _impl_.min_ != nullptr) {
    delete _impl_.min_;
  }
  _impl_.min_ = nullptr;
}
inline const ::kuksa::val::v2::Value& Metadata::_internal_min() const {
  const ::kuksa::val::v2::Value* p = _impl_.min_;
  return p != nullptr ? *p : reinterpret_cast<const ::kuksa::val::v2::Value&>(
      ::kuksa::val::v2::_Value_default_instance_);
}
inline const ::kuksa::val::v2::Value& Metadata::min() const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.Metadata.min)
  return _internal_min();
}
inline void Metadata::unsafe_arena_set_allocated_min(
    ::kuksa::val::v2::Value* min) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.min_);
  }
  _impl_.min_ = min;
  if (min) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kuksa.val.v2.Metadata.min)
}
inline ::kuksa::val::v2::Value* Metadata::release_min() {
  
  ::kuksa::val::v2::Value* temp = _impl_.min_;
  _impl_.min_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kuksa::val::v2::Value* Metadata::unsafe_arena_release_min() {
  // @@protoc_insertion_point(field_release:kuksa.val.v2.Metadata.min)
  
  ::kuksa::val::v2::Value* temp = _impl_.min_;
  _impl_.min_ = nullptr;
  return temp;
}
inline ::kuksa::val::v2::Value* Metadata::_internal_mutable_min() {
  
  if (_impl_.min_ == nullptr) {
    auto* p = CreateMaybeMessage<::kuksa::val::v2::Value>(GetArenaForAllocation());
    _impl_.min_ = p;
  }
  return _impl_.min_;
}
inline ::kuksa::val::v2::Value* Metadata::mutable_min() {
  ::kuksa::val::v2::Value* _msg = _internal_mutable_min();
  // @@protoc_insertion_point(field_mutable:kuksa.val.v2.Metadata.min)
  return _msg;
}
inline void Metadata::set_allocated_min(::kuksa::val::v2::Value* min) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.min_;
  }
  if (min) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(min);
    if (message_arena != submessage_arena) {
      min = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, min, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.min_ = min;
  // @@protoc_insertion_point(field_set_allocated:kuksa.val.v2.Metadata.min)
}

// .kuksa.val.v2.Value max = 19;
inline bool Metadata::_internal_has_max() const {
  return this != internal_default_instance() && _impl_.max_ != nullptr;
}
inline bool Metadata::has_max() const {
  return _internal_has_max();
}
inline void Metadata::clear_max() {
  if (GetArenaForAllocation() == nullptr && _impl_.max_ != nullptr) {
    delete _impl_.max_;
  }
  _impl_.max_ = nullptr;
}
inline const ::kuksa::val::v2::Value& Metadata::_internal_max() const {
  const ::kuksa::val::v2::Value* p = _impl_.max_;
  return p != nullptr ? *p : reinterpret_cast<const ::kuksa::val::v2::Value&>(
      ::kuksa::val::v2::_Value_default_instance_);
}
inline const ::kuksa::val::v2::Value& Metadata::max() const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.Metadata.max)
  return _internal_max();
}
inline void Metadata::unsafe_arena_set_allocated_max(
    ::kuksa::val::v2::Value* max) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.max_);
  }
  _impl_.max_ = max;
  if (max) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kuksa.val.v2.Metadata.max)
}
inline ::kuksa::val::v2::Value* Metadata::release_max() {
  
  ::kuksa::val::v2::Value* temp = _impl_.max_;
  _impl_.max_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kuksa::val::v2::Value* Metadata::unsafe_arena_release_max() {
  // @@protoc_insertion_point(field_release:kuksa.val.v2.Metadata.max)
  
  ::kuksa::val::v2::Value* temp = _impl_.max_;
  _impl_.max_ = nullptr;
  return temp;
}
inline ::kuksa::val::v2::Value* Metadata::_internal_mutable_max() {
  
  if (_impl_.max_ == nullptr) {
    auto* p = CreateMaybeMessage<::kuksa::val::v2::Value>(GetArenaForAllocation());
    _impl_.max_ = p;
  }
  return _impl_.max_;
}
inline ::kuksa::val::v2::Value* Metadata::mutable_max() {
  ::kuksa::val::v2::Value* _msg = _internal_mutable_max();
  // @@protoc_insertion_point(field_mutable:kuksa.val.v2.Metadata.max)
  return _msg;
}
inline void Metadata::set_allocated_max(::kuksa::val::v2::Value* max) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.max_;
  }
  if (max) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(max);
    if (message_arena != submessage_arena) {
      max = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, max, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.max_ = max;
  // @@protoc_insertion_point(field_set_allocated:kuksa.val.v2.Metadata.max)
}

// -------------------------------------------------------------------

// StringArray

// repeated string values = 1;
inline int StringArray::_internal_values_size() const {
  return _impl_.values_.size();
}
inline int StringArray::values_size() const {
  return _internal_values_size();
}
inline void StringArray::clear_values() {
  _impl_.values_.Clear();
}
inline std::string* StringArray::add_values() {
  std::string* _s = _internal_add_values();
  // @@protoc_insertion_point(field_add_mutable:kuksa.val.v2.StringArray.values)
  return _s;
}
inline const std::string& StringArray::_internal_values(int index) const {
  return _impl_.values_.Get(index);
}
inline const std::string& StringArray::values(int index) const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.StringArray.values)
  return _internal_values(index);
}
inline std::string* StringArray::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:kuksa.val.v2.StringArray.values)
  return _impl_.values_.Mutable(index);
}
inline void StringArray::set_values(int index, const std::string& value) {
  _impl_.values_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:kuksa.val.v2.StringArray.values)
}
inline void StringArray::set_values(int index, std::string&& value) {
  _impl_.values_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:kuksa.val.v2.StringArray.values)
}
inline void StringArray::set_values(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.values_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:kuksa.val.v2.StringArray.values)
}
inline void StringArray::set_values(int index, const char* value, size_t size) {
  _impl_.values_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kuksa.val.v2.StringArray.values)
}
inline std::string* StringArray::_internal_add_values() {
  return _impl_.values_.Add();
}
inline void StringArray::add_values(const std::string& value) {
  _impl_.values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:kuksa.val.v2.StringArray.values)
}
inline void StringArray::add_values(std::string&& value) {
  _impl_.values_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:kuksa.val.v2.StringArray.values)
}
inline void StringArray::add_values(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:kuksa.val.v2.StringArray.values)
}
inline void StringArray::add_values(const char* value, size_t size) {
  _impl_.values_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:kuksa.val.v2.StringArray.values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StringArray::values() const {
  // @@protoc_insertion_point(field_list:kuksa.val.v2.StringArray.values)
  return _impl_.values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
StringArray::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:kuksa.val.v2.StringArray.values)
  return &_impl_.values_;
}

// -------------------------------------------------------------------

// BoolArray

// repeated bool values = 1;
inline int BoolArray::_internal_values_size() const {
  return _impl_.values_.size();
}
inline int BoolArray::values_size() const {
  return _internal_values_size();
}
inline void BoolArray::clear_values() {
  _impl_.values_.Clear();
}
inline bool BoolArray::_internal_values(int index) const {
  return _impl_.values_.Get(index);
}
inline bool BoolArray::values(int index) const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.BoolArray.values)
  return _internal_values(index);
}
inline void BoolArray::set_values(int index, bool value) {
  _impl_.values_.Set(index, value);
  // @@protoc_insertion_point(field_set:kuksa.val.v2.BoolArray.values)
}
inline void BoolArray::_internal_add_values(bool value) {
  _impl_.values_.Add(value);
}
inline void BoolArray::add_values(bool value) {
  _internal_add_values(value);
  // @@protoc_insertion_point(field_add:kuksa.val.v2.BoolArray.values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
BoolArray::_internal_values() const {
  return _impl_.values_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
BoolArray::values() const {
  // @@protoc_insertion_point(field_list:kuksa.val.v2.BoolArray.values)
  return _internal_values();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
BoolArray::_internal_mutable_values() {
  return &_impl_.values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
BoolArray::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:kuksa.val.v2.BoolArray.values)
  return _internal_mutable_values();
}

// -------------------------------------------------------------------

// Int32Array

// repeated sint32 values = 1;
inline int Int32Array::_internal_values_size() const {
  return _impl_.values_.size();
}
inline int Int32Array::values_size() const {
  return _internal_values_size();
}
inline void Int32Array::clear_values() {
  _impl_.values_.Clear();
}
inline int32_t Int32Array::_internal_values(int index) const {
  return _impl_.values_.Get(index);
}
inline int32_t Int32Array::values(int index) const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.Int32Array.values)
  return _internal_values(index);
}
inline void Int32Array::set_values(int index, int32_t value) {
  _impl_.values_.Set(index, value);
  // @@protoc_insertion_point(field_set:kuksa.val.v2.Int32Array.values)
}
inline void Int32Array::_internal_add_values(int32_t value) {
  _impl_.values_.Add(value);
}
inline void Int32Array::add_values(int32_t value) {
  _internal_add_values(value);
  // @@protoc_insertion_point(field_add:kuksa.val.v2.Int32Array.values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
Int32Array::_internal_values() const {
  return _impl_.values_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
Int32Array::values() const {
  // @@protoc_insertion_point(field_list:kuksa.val.v2.Int32Array.values)
  return _internal_values();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
Int32Array::_internal_mutable_values() {
  return &_impl_.values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
Int32Array::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:kuksa.val.v2.Int32Array.values)
  return _internal_mutable_values();
}

// -------------------------------------------------------------------

// Int64Array

// repeated sint64 values = 1;
inline int Int64Array::_internal_values_size() const {
  return _impl_.values_.size();
}
inline int Int64Array::values_size() const {
  return _internal_values_size();
}
inline void Int64Array::clear_values() {
  _impl_.values_.Clear();
}
inline int64_t Int64Array::_internal_values(int index) const {
  return _impl_.values_.Get(index);
}
inline int64_t Int64Array::values(int index) const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.Int64Array.values)
  return _internal_values(index);
}
inline void Int64Array::set_values(int index, int64_t value) {
  _impl_.values_.Set(index, value);
  // @@protoc_insertion_point(field_set:kuksa.val.v2.Int64Array.values)
}
inline void Int64Array::_internal_add_values(int64_t value) {
  _impl_.values_.Add(value);
}
inline void Int64Array::add_values(int64_t value) {
  _internal_add_values(value);
  // @@protoc_insertion_point(field_add:kuksa.val.v2.Int64Array.values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
Int64Array::_internal_values() const {
  return _impl_.values_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
Int64Array::values() const {
  // @@protoc_insertion_point(field_list:kuksa.val.v2.Int64Array.values)
  return _internal_values();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
Int64Array::_internal_mutable_values() {
  return &_impl_.values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
Int64Array::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:kuksa.val.v2.Int64Array.values)
  return _internal_mutable_values();
}

// -------------------------------------------------------------------

// Uint32Array

// repeated uint32 values = 1;
inline int Uint32Array::_internal_values_size() const {
  return _impl_.values_.size();
}
inline int Uint32Array::values_size() const {
  return _internal_values_size();
}
inline void Uint32Array::clear_values() {
  _impl_.values_.Clear();
}
inline uint32_t Uint32Array::_internal_values(int index) const {
  return _impl_.values_.Get(index);
}
inline uint32_t Uint32Array::values(int index) const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.Uint32Array.values)
  return _internal_values(index);
}
inline void Uint32Array::set_values(int index, uint32_t value) {
  _impl_.values_.Set(index, value);
  // @@protoc_insertion_point(field_set:kuksa.val.v2.Uint32Array.values)
}
inline void Uint32Array::_internal_add_values(uint32_t value) {
  _impl_.values_.Add(value);
}
inline void Uint32Array::add_values(uint32_t value) {
  _internal_add_values(value);
  // @@protoc_insertion_point(field_add:kuksa.val.v2.Uint32Array.values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
Uint32Array::_internal_values() const {
  return _impl_.values_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
Uint32Array::values() const {
  // @@protoc_insertion_point(field_list:kuksa.val.v2.Uint32Array.values)
  return _internal_values();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
Uint32Array::_internal_mutable_values() {
  return &_impl_.values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
Uint32Array::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:kuksa.val.v2.Uint32Array.values)
  return _internal_mutable_values();
}

// -------------------------------------------------------------------

// Uint64Array

// repeated uint64 values = 1;
inline int Uint64Array::_internal_values_size() const {
  return _impl_.values_.size();
}
inline int Uint64Array::values_size() const {
  return _internal_values_size();
}
inline void Uint64Array::clear_values() {
  _impl_.values_.Clear();
}
inline uint64_t Uint64Array::_internal_values(int index) const {
  return _impl_.values_.Get(index);
}
inline uint64_t Uint64Array::values(int index) const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.Uint64Array.values)
  return _internal_values(index);
}
inline void Uint64Array::set_values(int index, uint64_t value) {
  _impl_.values_.Set(index, value);
  // @@protoc_insertion_point(field_set:kuksa.val.v2.Uint64Array.values)
}
inline void Uint64Array::_internal_add_values(uint64_t value) {
  _impl_.values_.Add(value);
}
inline void Uint64Array::add_values(uint64_t value) {
  _internal_add_values(value);
  // @@protoc_insertion_point(field_add:kuksa.val.v2.Uint64Array.values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
Uint64Array::_internal_values() const {
  return _impl_.values_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
Uint64Array::values() const {
  // @@protoc_insertion_point(field_list:kuksa.val.v2.Uint64Array.values)
  return _internal_values();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
Uint64Array::_internal_mutable_values() {
  return &_impl_.values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
Uint64Array::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:kuksa.val.v2.Uint64Array.values)
  return _internal_mutable_values();
}

// -------------------------------------------------------------------

// FloatArray

// repeated float values = 1;
inline int FloatArray::_internal_values_size() const {
  return _impl_.values_.size();
}
inline int FloatArray::values_size() const {
  return _internal_values_size();
}
inline void FloatArray::clear_values() {
  _impl_.values_.Clear();
}
inline float FloatArray::_internal_values(int index) const {
  return _impl_.values_.Get(index);
}
inline float FloatArray::values(int index) const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.FloatArray.values)
  return _internal_values(index);
}
inline void FloatArray::set_values(int index, float value) {
  _impl_.values_.Set(index, value);
  // @@protoc_insertion_point(field_set:kuksa.val.v2.FloatArray.values)
}
inline void FloatArray::_internal_add_values(float value) {
  _impl_.values_.Add(value);
}
inline void FloatArray::add_values(float value) {
  _internal_add_values(value);
  // @@protoc_insertion_point(field_add:kuksa.val.v2.FloatArray.values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
FloatArray::_internal_values() const {
  return _impl_.values_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
FloatArray::values() const {
  // @@protoc_insertion_point(field_list:kuksa.val.v2.FloatArray.values)
  return _internal_values();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
FloatArray::_internal_mutable_values() {
  return &_impl_.values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
FloatArray::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:kuksa.val.v2.FloatArray.values)
  return _internal_mutable_values();
}

// -------------------------------------------------------------------

// DoubleArray

// repeated double values = 1;
inline int DoubleArray::_internal_values_size() const {
  return _impl_.values_.size();
}
inline int DoubleArray::values_size() const {
  return _internal_values_size();
}
inline void DoubleArray::clear_values() {
  _impl_.values_.Clear();
}
inline double DoubleArray::_internal_values(int index) const {
  return _impl_.values_.Get(index);
}
inline double DoubleArray::values(int index) const {
  // @@protoc_insertion_point(field_get:kuksa.val.v2.DoubleArray.values)
  return _internal_values(index);
}
inline void DoubleArray::set_values(int index, double value) {
  _impl_.values_.Set(index, value);
  // @@protoc_insertion_point(field_set:kuksa.val.v2.DoubleArray.values)
}
inline void DoubleArray::_internal_add_values(double value) {
  _impl_.values_.Add(value);
}
inline void DoubleArray::add_values(double value) {
  _internal_add_values(value);
  // @@protoc_insertion_point(field_add:kuksa.val.v2.DoubleArray.values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
DoubleArray::_internal_values() const {
  return _impl_.values_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
DoubleArray::values() const {
  // @@protoc_insertion_point(field_list:kuksa.val.v2.DoubleArray.values)
  return _internal_values();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
DoubleArray::_internal_mutable_values() {
  return &_impl_.values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
DoubleArray::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:kuksa.val.v2.DoubleArray.values)
  return _internal_mutable_values();
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v2
}  // namespace val
}  // namespace kuksa

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::kuksa::val::v2::ErrorCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::kuksa::val::v2::ErrorCode>() {
  return ::kuksa::val::v2::ErrorCode_descriptor();
}
template <> struct is_proto_enum< ::kuksa::val::v2::DataType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::kuksa::val::v2::DataType>() {
  return ::kuksa::val::v2::DataType_descriptor();
}
template <> struct is_proto_enum< ::kuksa::val::v2::EntryType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::kuksa::val::v2::EntryType>() {
  return ::kuksa::val::v2::EntryType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_kuksa_2fval_2fv2_2ftypes_2eproto
